<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GMP原理和调度</title>
    <url>/2021/02/19/GMP%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h1><h1 id="原理与调度"><a href="#原理与调度" class="headerlink" title="原理与调度"></a>原理与调度</h1><h3 id="一、-Golang-quot-调度器-quot-的由来？"><a href="#一、-Golang-quot-调度器-quot-的由来？" class="headerlink" title="一、** Golang &quot; **调度器&quot; 的由来？"></a><strong>一、**</strong> Golang &quot; <strong>**调度器&quot; 的由来？</strong></h3><h4 id="1-单进程时代不需要调度器"><a href="#1-单进程时代不需要调度器" class="headerlink" title="(1)  单进程时代不需要调度器"></a><strong>(1)</strong>  <strong>单进程时代不需要调度器</strong></h4><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活 (计算) 的是 CPU。早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是 &quot;单进程时代&quot;</p>
<p>一切的程序只能串行发生。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_9a10d7ef5dcd2443.jpg"  alt=""></p>
<p>早期的单进程操作系统，面临 2 个问题：</p>
<p>1.</p>
<p>单一的执行流程，计算机只能一个任务一个任务处理。</p>
<p>1.<br>2.</p>
<p>进程阻塞所带来的 CPU 时间浪费。</p>
<p>1.</p>
<p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p>
<p>后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把 CPU 利用起来，CPU 就不浪费了。</p>
<h4 id="2-多进程-线程时代有了调度器需求"><a href="#2-多进程-线程时代有了调度器需求" class="headerlink" title="(2)  多进程  /  线程时代有了调度器需求"></a><strong>(2)</strong>  <strong>多进程</strong>  <strong>/</strong>  <strong>线程时代有了调度器需求</strong></h4><p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_e8b4f01c66c01c29.jpg"  alt=""></p>
<p>在多进程 / 多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞 cpu 可以立刻切换到其他进程中去执行，而且调度 cpu 的算法可以保证在运行的进程都可以被分配到 cpu 的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p>
<p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU 虽然利用起来了，但如果进程过多，CPU 有很大的一部分都被用来进行进程调度了。</p>
<p>怎么才能提高 CPU 的利用率呢？</p>
<p>但是对于 Linux 操作系统来讲，cpu 对进程的态度和线程的态度是一样的。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_31c64b66f20d03f.jpg"  alt=""></p>
<p>很明显，CPU 调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</p>
<h4 id="3-协程来提高-CPU-利用率"><a href="#3-协程来提高-CPU-利用率" class="headerlink" title="(3)  协程来提高  CPU  利用率"></a><strong>(3)</strong>  <strong>协程来提高</strong>  <strong>CPU</strong>  <strong>利用率</strong></h4><p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存 (进程虚拟内存会占用 4GB [32 位操作系统], 而线程也要大约 4MB)。</p>
<p>大量的进程 / 线程出现了新的问题</p>
<ul>
<li>高内存占用</li>
<li>调度的高消耗 CPU</li>
</ul>
<p>好了，然后工程师们就发现，其实一个线程分为 &quot;内核态 &quot;线程和&quot; 用户态 &quot;线程。</p>
<p>一个 &quot;用户态线程&quot; 必须要绑定一个 &quot;内核态线程&quot;，但是 CPU 并不知道有 &quot;用户态线程&quot; 的存在，它只知道它运行的是一个 &quot;内核态线程&quot;(Linux 的 PCB 进程控制块)。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_11556ee2bcf7cd16.jpg"  alt=""></p>
<p>这样，我们再去细化去分类一下，内核线程依然叫 &quot;线程 (thread)&quot;，用户线程叫 &quot;协程 (co-routine)&quot;.</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_5c31db15f6d30fbd.jpg"  alt=""></p>
<p>​ 看到这里，我们就要开脑洞了，既然一个协程 (co-routine) 可以绑定一个线程 (thread)，那么能不能多个协程 (co-routine) 绑定一个或者多个线程 (thread) 上呢。</p>
<p>​ 之后，我们就看到了有 3 中协程和线程的映射关系：</p>
<p>s=&quot;default&quot;&amp;gt;</p>
<p>N:1 关系</p>
<p>N 个协程绑定 1 个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1 个进程的所有协程都绑定在 1 个线程上</p>
<p>缺点：</p>
<p>-</p>
<p>某个程序用不了硬件的多核加速能力</p>
<h2 id=""><a href="#" class="headerlink" title="-"></a>-</h2><p>一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</p>
<p>-</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_91b214bbac539e0.jpg"  alt=""></p>
<p>s=&quot;default&quot;&amp;gt;</p>
<p>1:1 关系</p>
<p>1 个协程绑定 1 个线程，这种最容易实现。协程的调度都由 CPU 完成了，不存在 N:1 缺点，</p>
<p>缺点：</p>
<ul>
<li>协程的创建、删除和切换的代价都由 CPU 完成，有点略显昂贵了。</li>
</ul>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_a50cb95705d607ef.jpg"  alt=""></p>
<p>s=&quot;default&quot;&amp;gt;</p>
<p>M:N 关系</p>
<p>M 个协程绑定 1 个线程，是 N:1 和 1:1 类型的结合，克服了以上 2 种模型的缺点，但实现起来最为复杂。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_e9806759bfe2189.jpg"  alt=""></p>
<p>​ 协程跟线程是有区别的，线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的，一个协程让出 CPU 后，才执行下一个协程。</p>
<h4 id="4-Go-语言的协程-goroutine"><a href="#4-Go-语言的协程-goroutine" class="headerlink" title="(4) Go  语言的协程  goroutine"></a><strong>(4) Go</strong>  <strong>语言的协程</strong>  <strong>goroutine</strong></h4><p>Go 为了提供更容易使用的并发方法，使用了 goroutine 和 channel。goroutine 来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被 runtime 调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p>
<p>Go 中，协程被称为 goroutine，它非常轻量，一个 goroutine 只占几 KB，并且这几 KB 就足够 goroutine 运行完，这就能在有限的内存空间内支持大量 goroutine，支持了更多的并发。虽然一个 goroutine 的栈只占几 KB，但实际是可伸缩的，如果需要更多内容，runtime 会自动为 goroutine 分配。</p>
<p>Goroutine 特点：</p>
<ul>
<li>占用内存更小（几 kb）</li>
<li>调度更灵活 (runtime 调度)</li>
</ul>
<h4 id="5-被废弃的-goroutine-调度器"><a href="#5-被废弃的-goroutine-调度器" class="headerlink" title="(5)  被废弃的  goroutine  调度器"></a><strong>(5)</strong>  <strong>被废弃的</strong>  <strong>goroutine</strong>  <strong>调度器</strong></h4><p>​好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。</p>
<p>Go 目前使用的调度器是 2012 年重新设计的，因为之前的调度器性能存在问题，所以使用 4 年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？</p>
<p>大部分文章都是会用 G 来表示 Goroutine，用 M 来表示线程，那么我们也会用这种表达的对应关系。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_d4cfd5c5e1fb8f09.jpg"  alt=""></p>
<p>下面我们来看看被废弃的 golang 调度器是如何实现的？</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_88f301944a91f10.jpg"  alt=""></p>
<p>M 想要执行、放回 G 都必须访问全局 G 队列，并且 M 有多个，即多线程访问同一资源需要加锁进行保证互斥 / 同步，所以全局 G 队列是有互斥锁进行保护的。</p>
<p>老调度器有几个缺点：</p>
<ul>
<li>创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的锁竞争。</li>
<li>M 转移 G 会造成延迟和额外的系统负载。比如当 G 中包含创建新协程的时候，M 创建了 G&#39;，为了继续执行 G，需要把 G&#39;交给 M&#39;执行，也造成了很差的局部性，因为 G&#39;和 G 是相关的，最好放在 M 上执行，而不是其他 M&#39;。</li>
<li>系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ul>
<h3 id="二、-Goroutine-调度器的-GMP-模型的设计思想"><a href="#二、-Goroutine-调度器的-GMP-模型的设计思想" class="headerlink" title="二、** Goroutine ** 调度器的 ** GMP ** 模型的设计思想"></a><strong>二、**</strong> Goroutine <strong>** 调度器的 **</strong> GMP <strong>** 模型的设计思想</strong></h3><p>面对之前调度器的问题，Go 设计了新的调度器。</p>
<p>在新调度器中，出列 M (thread) 和 G (goroutine)，又引进了 P (Processor)。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_da03985e1208831.jpg"  alt=""></p>
<p>Processor，它包含了运行 goroutine 的资源，如果线程想运行 goroutine，必须先获取 P，P 中还包含了可运行的 G 队列。</p>
<h4 id="1-GMP-模型"><a href="#1-GMP-模型" class="headerlink" title="(1) GMP  模型"></a><strong>(1) GMP</strong>  <strong>模型</strong></h4><p>在 Go 中，线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_3bcd9445db4f33ff.jpg"  alt=""></p>
<ul>
<li>全局队列（Global Queue）：存放等待运行的 G。</li>
<li>P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G&#39;时，G&#39;优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。</li>
<li>P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。</li>
<li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li>
</ul>
<p>Goroutine 调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行。</p>
<p>有关 P 和 M 的个数问题</p>
<p>1、P 的数量：</p>
<ul>
<li>由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行。</li>
</ul>
<p>2、M 的数量:</p>
<ul>
<li>go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li>
<li>runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量</li>
<li>一个 M 阻塞了，会创建新的 M。</li>
</ul>
<p>M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。</p>
<p>P 和 M 何时会被创建</p>
<p>1、P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。</p>
<p>2、M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。</p>
<h4 id="2-调度器的设计策略"><a href="#2-调度器的设计策略" class="headerlink" title="(2)  调度器的设计策略"></a><strong>(2)</strong>  <strong>调度器的设计策略</strong></h4><p>复用线程：避免频繁的创建、销毁线程，而是对线程的复用。</p>
<p>1）work stealing 机制</p>
<p>​ 当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。</p>
<p>2）hand off 机制</p>
<p>​ 当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。</p>
<p>利用并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。</p>
<p>抢占：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。</p>
<p>全局 G 队列：在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。</p>
<h4 id="3-go-func-调度流程"><a href="#3-go-func-调度流程" class="headerlink" title="(3) go func ()  调度流程"></a><strong>(3) go func ()</strong>  <strong>调度流程</strong></h4><p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_b86e232af1e750e8.jpg"  alt=""></p>
<p>从上图我们可以分析出几个结论：</p>
<p>​ 1、我们通过 go func () 来创建一个 goroutine；</p>
<p>​ 2、有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中；</p>
<p>​ 3、G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行；</p>
<p>​ 4、一个 M 调度 G 执行的过程是一个循环机制；</p>
<p>​ 5、当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P；</p>
<p>​ 6、当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中。</p>
<h4 id="4-调度器的生命周期"><a href="#4-调度器的生命周期" class="headerlink" title="(4)  调度器的生命周期"></a><strong>(4)</strong>  <strong>调度器的生命周期</strong></h4><p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_83a96dc5add31f85.png"  alt=""></p>
<p>特殊的 M0 和 G0</p>
<p>M0</p>
<p>M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。</p>
<p>G0</p>
<p>G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。</p>
<p>我们来跟踪一段代码</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p>fmt.Println(&quot;Hello world&quot;)</p>
<p>}</p>
<p>接下来我们来针对上面的代码对调度器里面的结构做一个分析。</p>
<p>也会经历如上图所示的过程：</p>
<ul>
<li>1.runtime 创建最初的线程 m0 和 goroutine g0，并把 2 者关联。</li>
<li>2.调度器初始化：初始化 m0、栈、垃圾回收，以及创建和初始化由 GOMAXPROCS 个 P 构成的 P 列表。</li>
<li>3.示例代码中的 main 函数是 main.main，runtime 中也有 1 个 main 函数 ——runtime.main，代码经过编译后，runtime.main 会调用 main.main，程序启动时会为 runtime.main 创建 goroutine，称它为 main goroutine 吧，然后把 main goroutine 加入到 P 的本地队列。</li>
<li>4.启动 m0，m0 已经绑定了 P，会从 P 的本地队列获取 G，获取到 main goroutine。</li>
<li>5.G 拥有栈，M 根据 G 中的栈信息和调度信息设置运行环境</li>
<li>6.M 运行 G</li>
<li>7.G 退出，再次回到 M 获取可运行的 G，这样重复下去，直到 main.main 退出，runtime.main 执行 Defer 和 Panic 处理，或调用 runtime.exit 退出程序。</li>
</ul>
<p>调度器的生命周期几乎占满了一个 Go 程序的一生，runtime.main 的 goroutine 执行之前都是为调度器做准备工作，runtime.main 的 goroutine 运行，才是调度器的真正开始，直到 runtime.main 结束而结束。</p>
<h4 id="5-可视化-GMP-编程"><a href="#5-可视化-GMP-编程" class="headerlink" title="(5)  可视化  GMP  编程"></a><strong>(5)</strong>  <strong>可视化</strong>  <strong>GMP</strong>  <strong>编程</strong></h4><p>有 2 种方式可以查看一个程序的 GMP 的数据。</p>
<p>方式 1：go tool trace</p>
<p>trace 记录了运行时的信息，能提供可视化的 Web 页面。</p>
<p>简单测试代码：main 函数创建 trace，trace 会运行在单独的 goroutine 中，然后 main 打印&quot;Hello World&quot; 退出。</p>
<p>trace.go</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;os&quot;</p>
<p>&quot;fmt&quot;</p>
<p>&quot;runtime/trace&quot;</p>
<p>)</p>
<p>func <strong>main</strong> () {</p>
<p><em>// <strong>创建</strong> trace__文件</em></p>
<p>f, err := os.Create(&quot;trace.out&quot;)</p>
<p><strong>if</strong> err != nil {</p>
<p>panic(err)</p>
<p>}</p>
<p>defer f.Close()</p>
<p><em>// <strong>启动</strong> trace goroutine</em></p>
<p>err = trace.Start(f)</p>
<p><strong>if</strong> err != nil {</p>
<p>panic(err)</p>
<p>}</p>
<p>defer trace.Stop()</p>
<p><em>//main</em></p>
<p>fmt.Println(&quot;Hello World&quot;)</p>
<p>}</p>
<p>运行程序</p>
<p>$ go run trace.go</p>
<p>Hello World</p>
<p>会得到一个 trace.out 文件，然后我们可以用一个工具打开，来分析这个文件。</p>
<p>$ go tool trace trace. <strong>out</strong> 2020/02/2310:44:11 Parsing trace…2020/02/2310:44:11 Splitting trace…2020/02/2310:44:11 Opening browser. Trace viewer <strong>is</strong> listening <strong>on</strong> http:<em>//127.0.0.1:33479</em></p>
<p>我们可以通过浏览器打开 <a href="http://127.0.0.1:33479/" target="_blank" rel="noopener">http://127.0.0.1:33479</a> 网址，点击 view trace 能够看见可视化的调度流程。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_a8050339b8b7ad3b.jpg"  alt=""></p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_8d8b6100eea3b20c.jpg"  alt=""></p>
<p>G 信息</p>
<p>点击 Goroutines 那一行可视化的数据条，我们会看到一些详细的信息。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_9697b67e1ee5a700.jpg"  alt=""></p>
<p>一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论。</p>
<p>其中 G1 应该就是 main goroutine (执行 main 函数的协程)，在一段时间内处于可运行和运行的状态。</p>
<p>M 信息</p>
<p>点击 Threads 那一行可视化的数据条，我们会看到一些详细的信息。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_20fa1e2d0baac7a8.jpg"  alt=""></p>
<p>一共有两个 M 在程序中，一个是特殊的 M0，用于初始化使用，这个我们不必讨论。</p>
<p>P 信息</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_570d791a69fa0f6a.jpg"  alt=""></p>
<p>G1 中调用了 main.main，创建了 trace goroutine g18。G1 运行在 P1 上，G18 运行在 P0 上。</p>
<p>这里有两个 P，我们知道，一个 P 必须绑定一个 M 才能调度 G。</p>
<p>我们在来看看上面的 M 信息。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_15d96264bb9bd21f.jpg"  alt=""></p>
<p>我们会发现，确实 G18 在 P0 上被运行的时候，确实在 Threads 行多了一个 M 的数据，点击查看如下：</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_3dbf3fcec37f839f.jpg"  alt=""></p>
<p>多了一个 M2 应该就是 P0 为了执行 G18 而动态创建的 M2.</p>
<p>方式 2：Debug trace</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;time&quot;</p>
<p>)</p>
<p>func <strong>main</strong> () {</p>
<p><strong>for</strong> i := 0; i &amp;lt; 5; i++ {</p>
<p>time.Sleep(time.Second)</p>
<p>fmt.Println(&quot;Hello World&quot;)</p>
<p>}</p>
<p>}</p>
<p>编译</p>
<p>$ go build trace2.go</p>
<p>通过 Debug 方式运行</p>
<p>$ GODEBUG=schedtrace=1000 ./trace2</p>
<p>SCHED 0ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=1 idlethreads=1 runqueue=0 [00]</p>
<p>Hello World</p>
<p>SCHED 1003ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [00]</p>
<p>Hello World</p>
<p>SCHED 2014ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [00]</p>
<p>Hello World</p>
<p>SCHED 3015ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [00]</p>
<p>Hello World</p>
<p>SCHED 4023ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [00]</p>
<p>Hello World</p>
<ul>
<li>SCHED：调试信息输出标志字符串，代表本行是 goroutine 调度器的输出；</li>
<li>0ms：即从程序启动到输出这行日志的时间；</li>
<li>gomaxprocs: P 的数量，本例有 2 个 P, 因为默认的 P 的属性是和 cpu 核心数量默认一致，当然也可以通过 GOMAXPROCS 来设置；</li>
<li>idleprocs: 处于 idle 状态的 P 的数量；通过 gomaxprocs 和 idleprocs 的差值，我们就可知道执行 go 代码的 P 的数量；</li>
<li>threads: os threads/M 的数量，包含 scheduler 使用的 m 数量，加上 runtime 自用的类似 sysmon 这样的 thread 的数量；</li>
<li>spinningthreads: 处于自旋状态的 os thread 数量；</li>
<li>idlethread: 处于 idle 状态的 os thread 的数量；</li>
<li>runqueue=0： Scheduler 全局队列中 G 的数量；</li>
<li>[0 0]: 分别为 2 个 P 的 local queue 中的 G 的数量。</li>
</ul>
<h3 id="三、-Go-调度器调度场景过程全解析"><a href="#三、-Go-调度器调度场景过程全解析" class="headerlink" title="三、** Go ** 调度器调度场景过程全解析"></a><strong>三、**</strong> Go <strong>** 调度器调度场景过程全解析</strong></h3><p>(1) 场景 1</p>
<p>P 拥有 G1，M1 获取 P 后开始运行 G1，G1 使用 go func() 创建了 G2，为了局部性 G2 优先加入到 P1 的本地队列。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_d210bee748a0335f.jpg"  alt=""></p>
<p>(2) 场景 2</p>
<p>G1 运行完成后 (函数：goexit)，M 上运行的 goroutine 切换为 G0，G0 负责调度时协程的切换（函数：schedule）。从 P 的本地队列取 G2，从 G0 切换到 G2，并开始运行 G2 (函数：execute)。实现了线程 M1 的复用。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_69da45871335ceba.jpg"  alt=""></p>
<p>(3) 场景 3</p>
<p>假设每个 P 的本地队列只能存 3 个 G。G2 要创建了 6 个 G，前 3 个 G（G3, G4, G5）已经加入 p1 的本地队列，p1 本地队列满了。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_cd3112fa3f90bded.jpg"  alt=""></p>
<p>(4) 场景 4</p>
<p>G2 在创建 G7 的时候，发现 P1 的本地队列已满，需要执行负载均衡 (把 P1 中本地队列中前一半的 G，还有新创建 G 转移到全局队列)</p>
<p>（实现中并不一定是新的 G，如果 G 是 G2 之后就执行的，会被保存在本地队列，利用某个老的 G 替换新 G 加入全局队列）</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_81d8edb24cdd39f5.jpg"  alt=""></p>
<p>这些 G 被转移到全局队列时，会被打乱顺序。所以 G3,G4,G7 被转移到全局队列。</p>
<p>(5) 场景 5</p>
<p>G2 创建 G8 时，P1 的本地队列未满，所以 G8 会被加入到 P1 的本地队列。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_e9532624e7372a44.jpg"  alt=""></p>
<p>G8 加入到 P1 点本地队列的原因还是因为 P1 此时在与 M1 绑定，而 G2 此时是 M1 在执行。所以 G2 创建的新的 G 会优先放置到自己的 M 绑定的 P 上。</p>
<p>(6) 场景 6</p>
<p>规定：在创建 G 时，运行的 G 会尝试唤醒其他空闲的 P 和 M 组合去执行。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_1615e00d25253b16.jpg"  alt=""></p>
<p>假定 G2 唤醒了 M2，M2 绑定了 P2，并运行 G0，但 P2 本地队列没有 G，M2 此时为自旋线程（没有 G 但为运行状态的线程，不断寻找 G）。</p>
<p>(7) 场景 7</p>
<p>M2 尝试从全局队列 (简称 &quot;GQ&quot;) 取一批 G 放到 P2 的本地队列（函数：findrunnable()）。M2 从全局队列取的 G 数量符合下面的公式：</p>
<p>n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))</p>
<p>至少从全局队列取 1 个 g，但每次不要从全局队列移动太多的 g 到 p 本地队列，给其他 p 留点。这是从全局队列到 P 本地队列的负载均衡。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_25cd9205ba8e16d4.jpg"  alt=""></p>
<p>假定我们场景中一共有 4 个 P（GOMAXPROCS 设置为 4，那么我们允许最多就能用 4 个 P 来供 M 使用）。所以 M2 只从能从全局队列取 1 个 G（即 G3）移动 P2 本地队列，然后完成从 G0 到 G3 的切换，运行 G3。</p>
<p>(8) 场景 8</p>
<p>假设 G2 一直在 M1 上运行，经过 2 轮后，M2 已经把 G7、G4 从全局队列获取到了 P2 的本地队列并完成运行，全局队列和 P2 的本地队列都空了，如场景 8 图的左半部分。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_79937e489737b72b.jpg"  alt=""></p>
<p>全局队列已经没有 G，那 m 就要执行 work stealing (偷取)：从其他有 G 的 P 哪里偷取一半 G 过来，放到自己的 P 本地队列。P2 从 P1 的本地队列尾部取一半的 G，本例中一半则只有 1 个 G8，放到 P2 的本地队列并执行。</p>
<p>(9) 场景 9</p>
<p>G1 本地队列 G5、G6 已经被其他 M 偷走并运行完成，当前 M1 和 M2 分别在运行 G2 和 G8，M3 和 M4 没有 goroutine 可以运行，M3 和 M4 处于自旋状态，它们不断寻找 goroutine。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_f3298f5574443ab9.jpg"  alt=""></p>
<p>为什么要让 m3 和 m4 自旋，自旋本质是在运行，线程在运行却没有执行 G，就变成了浪费 CPU. 为什么不销毁现场，来节约 CPU 资源。因为创建和销毁 CPU 也会浪费时间，我们希望当有新 goroutine 创建时，立刻能有 M 运行它，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费 CPU，所以系统中最多有 GOMAXPROCS 个自旋的线程 (当前例子中的 GOMAXPROCS=4，所以一共 4 个 P)，多余的没事做线程会让他们休眠。</p>
<p>(10) 场景 10</p>
<p>​ 假定当前除了 M3 和 M4 为自旋线程，还有 M5 和 M6 为空闲的线程 (没有得到 P 的绑定，注意我们这里最多就只能够存在 4 个 P，所以 P 的数量应该永远是 M&amp;gt;=P, 大部分都是 M 在抢占需要运行的 P)，G8 创建了 G9，G8 进行了阻塞的系统调用，M2 和 P2 立即解绑，P2 会执行以下判断：如果 P2 本地队列有 G、全局队列有 G 或有空闲的 M，P2 都会立马唤醒 1 个 M 和它绑定，否则 P2 则会加入到空闲 P 列表，等待 M 来获取可用的 p。本场景中，P2 本地队列有 G9，可以和其他空闲的线程 M5 绑定。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_bdbc32943cf5669b.jpg"  alt=""></p>
<p>(11) 场景 11</p>
<p>G8 创建了 G9，假如 G8 进行了非阻塞系统调用。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-19xbhf4_html_c07db9eea1c32e10.jpg"  alt=""></p>
<p>​ M2 和 P2 会解绑，但 M2 会记住 P2，然后 G8 和 M2 进入系统调用状态。当 G8 和 M2 退出系统调用时，会尝试获取 P2，如果无法获取，则获取空闲的 P，如果依然没有，G8 会被记为可运行状态，并加入到全局队列，M2 因为没有 P 的绑定而变成休眠状态 (长时间休眠等待 GC 回收销毁)。</p>
<h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a><strong>四、小结</strong></h3><p>总结，Go 调度器很轻量也很简单，足以撑起 goroutine 的调度工作，并且让 Go 具有了原生（强大）并发的能力。Go 调度本质是把大量的 goroutine 分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Channel</title>
    <url>/2021/02/19/Channel/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a><strong>channel</strong></h3><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p>
<p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p>
<p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</p>
<p>如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>
<h3 id="channel-类型"><a href="#channel-类型" class="headerlink" title="channel** 类型**"></a><strong>channel**</strong> 类型**</h3><p>channel是一种类型，一种引用类型。声明通道类型的格式如下：</p>
<p><strong>var</strong> 变量 chan 元素类型</p>
<p>举几个例子：</p>
<p><strong>var</strong> ch1 chan <strong>int</strong> <em>//</em> <em>声明一个传递整型的通道</em></p>
<p><strong>var</strong> ch2 chan <strong>bool</strong> <em>//</em> <em>声明一个传递布尔型的通道</em></p>
<p><strong>var</strong> ch3 chan [] <strong>int</strong> <em>//</em> <em>声明一个传递 <strong>int</strong> 切片的通道</em></p>
<h3 id="创建-channel"><a href="#创建-channel" class="headerlink" title="创建** channel**"></a><strong>创建**</strong> channel**</h3><p>通道是引用类型，通道类型的空值是nil。</p>
<p><strong>var</strong> ch chan <strong>int</strong></p>
<p>fmt.Println(ch) <em>// &amp;lt;nil&amp;gt;</em></p>
<p>声明的通道后需要使用make函数初始化之后才能使用。</p>
<p>创建channel的格式如下：</p>
<p><strong>make</strong> ( <strong>chan</strong> 元素类型, [缓冲大小])</p>
<p>channel的缓冲大小是可选的。</p>
<p>举几个例子：</p>
<p>ch4 := make(chan <strong>int</strong> )</p>
<p>ch5 := make(chan <strong>bool</strong> )</p>
<p>ch6 := make(chan [] <strong>int</strong> )</p>
<h3 id="channel-操作"><a href="#channel-操作" class="headerlink" title="channel** 操作**"></a><strong>channel**</strong> 操作**</h3><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p>
<p>发送和接收都使用&amp;lt;-符号。</p>
<p>现在我们先使用以下语句定义一个通道：</p>
<p>ch := make(chan <strong>int</strong> )</p>
<h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a><strong>发送</strong></h4><p>将一个值发送到通道中。</p>
<p>ch &amp;lt;- 10_//_ <em>把 <strong>10</strong> 发送到 <strong>ch</strong> 中</em></p>
<h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a><strong>接收</strong></h4><p>从一个通道中接收值。</p>
<p>x := &amp;lt;- ch <em>//</em> <em>从 <strong>ch</strong> 中接收值并赋值给变量__x</em></p>
<p>&amp;lt;-ch <em>//</em> <em>从 <strong>ch</strong> 中接收值，忽略结果</em></p>
<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a><strong>关闭</strong></h4><p>我们通过调用内置的close函数来关闭通道。</p>
<p><strong>close</strong> (ch)</p>
<p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p>
<p>关闭后的通道有以下特点：</p>
<p>1.对一个关闭的通道再发送值就会导致panic。</p>
<p>2.对一个关闭的通道进行接收会一直获取值直到通道为空。</p>
<p>3.对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</p>
<p>4.关闭一个已经关闭的通道会导致panic。</p>
<h3 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a><strong>无缓冲的通道</strong></h3><p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-1ixaacp_html_99ba5965f74becad.png"  alt=""></p>
<p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p>
<p><strong>func**</strong> main**() {</p>
<p>ch := make(chan int)</p>
<p>ch &amp;lt;- 10</p>
<p>fmt.Println(&quot;发送成功&quot;)</p>
<p>}</p>
<p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p>
<p>fatalerror: all goroutines are asleep - deadlock!</p>
<p>goroutine 1 [chan send]:</p>
<p>main.main()</p>
<p>…/src/github.com/pprof/studygo/day06/channel02/main.go:8 +0x54</p>
<p>为什么会出现deadlock错误呢？</p>
<p>因为我们使用ch := make(chan int)创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</p>
<p>上面的代码会阻塞在ch &amp;lt;- 10这一行代码形成死锁，那如何解决这个问题呢？</p>
<p>一种方法是启用一个goroutine去接收值，例如：</p>
<p><strong>func**</strong> recv<strong>(</strong>c <strong><strong>chan</strong></strong> int**) {</p>
<p>ret := &amp;lt;-c</p>
<p>fmt.Println(&quot;接收成功&quot;, ret)</p>
<p>} <strong>func**</strong> main**() {</p>
<p>ch := make(chan int)</p>
<p>go recv(ch) // 启用goroutine从通道接收值</p>
<p>ch &amp;lt;- 10</p>
<p>fmt.Println(&quot;发送成功&quot;)</p>
<p>}</p>
<p>无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。</p>
<p>使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。</p>
<h3 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a><strong>有缓冲的通道</strong></h3><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-1ixaacp_html_5a006db06901e8fc.png"  alt=""></p>
<p>我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p>
<p><strong>func**</strong> main**() {</p>
<p>ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道</p>
<p>ch &amp;lt;- 10</p>
<p>fmt.Println(&quot;发送成功&quot;)</p>
<p>}</p>
<p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p>
<p>我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，虽然我们很少会这么做。</p>
<h3 id="close"><a href="#close" class="headerlink" title="close()"></a><strong>close()</strong></h3><p>可以通过内置的close()函数关闭channel（如果你的管道不往里存值或者取值的时候一定记得关闭管道）</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p>c := make(chan <strong>int</strong> )</p>
<p>go <strong>func</strong> () {</p>
<p><strong>for</strong> i := 0; i &amp;lt; 5; i++ {</p>
<p>c &amp;lt;- i</p>
<p>}</p>
<p>close(c)</p>
<p>}()</p>
<p><strong>for</strong> {</p>
<p><strong>if</strong> data, ok := &amp;lt;-c; ok {</p>
<p>fmt.Println(data)</p>
<p>} <strong>else</strong> {</p>
<p><strong>break</strong></p>
<p>}</p>
<p>}</p>
<p>fmt.Println(&quot;main结束&quot;)</p>
<p>}</p>
<h3 id="如何优雅的从通道循环取值"><a href="#如何优雅的从通道循环取值" class="headerlink" title="如何优雅的从通道循环取值"></a><strong>如何优雅的从通道循环取值</strong></h3><p>当通过通道发送有限的数据时，我们可以通过close函数关闭通道来告知从该通道接收值的goroutine停止等待。当通道被关闭时，往该通道发送值会引发panic，从该通道里接收的值一直都是类型零值。那如何判断一个通道是否被关闭了呢？</p>
<p>我们来看下面这个例子：</p>
<p><em>// channel</em> _练习_func <strong>main</strong> () {</p>
<p>ch1 := make(chan <strong>int</strong> )</p>
<p>ch2 := make(chan <strong>int</strong> )</p>
<p><em>//</em> <em>开启 <strong>goroutine</strong> 将 <strong>0~100</strong> 的数发送到 <strong>ch1</strong> 中</em></p>
<p>go <strong>func</strong> () {</p>
<p><strong>for</strong> i := 0; i &amp;lt; 100; i++ {</p>
<p>ch1 &amp;lt;- i</p>
<p>}</p>
<p>close(ch1)</p>
<p>}()</p>
<p><em>//</em> <em>开启 <strong>goroutine</strong> 从 <strong>ch1</strong> 中接收值，并将该值的平方发送到 <strong>ch2</strong> 中</em></p>
<p>go <strong>func</strong> () {</p>
<p><strong>for</strong> {</p>
<p>i, ok := &amp;lt;-ch1 <em>//</em> <em>通道关闭后再取值__ok=false</em></p>
<p><strong>if</strong>!ok {</p>
<p><strong>break</strong></p>
<p>}</p>
<p>ch2 &amp;lt;- i * i</p>
<p>}</p>
<p>close(ch2)</p>
<p>}()</p>
<p><em>//</em> <em>在主 <strong>goroutine</strong> 中从 <strong>ch2</strong> 中接收值打印</em></p>
<p><strong>for</strong> i := range ch2 { <em>//</em> <em>通道关闭后会退出 <strong>for range</strong> 循环</em></p>
<p>fmt.Println(i)</p>
<p>}</p>
<p>}</p>
<p>从上面的例子中我们看到有两种方式在接收值的时候判断通道是否被关闭，我们通常使用的是for range的方式。</p>
<h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a><strong>单向通道</strong></h3><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p>
<p>Go语言中提供了单向通道来处理这种情况。例如，我们把上面的例子改造如下：</p>
<p>func <strong>counter</strong> ( <strong>out</strong> chan&amp;lt;- <strong>int</strong> ) {</p>
<p><strong>for</strong> i := 0; i &amp;lt; 100; i++ {</p>
<p><strong>out</strong> &amp;lt;- i</p>
<p>}</p>
<p>close( <strong>out</strong> )</p>
<p>}</p>
<p>func <strong>squarer</strong> ( <strong>out</strong> chan&amp;lt;- <strong>int</strong> , <strong>in</strong> &amp;lt;-chan <strong>int</strong> ) {</p>
<p><strong>for</strong> i := range <strong>in</strong> {</p>
<p><strong>out</strong> &amp;lt;- i * i</p>
<p>}</p>
<p>close( <strong>out</strong> )</p>
<p>}func <strong>printer</strong> ( <strong>in</strong> &amp;lt;-chan <strong>int</strong> ) {</p>
<p><strong>for</strong> i := range <strong>in</strong> {</p>
<p>fmt.Println(i)</p>
<p>}</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>ch1 := make(chan <strong>int</strong> )</p>
<p>ch2 := make(chan <strong>int</strong> )</p>
<p>go <strong>counter</strong> (ch1)</p>
<p>go <strong>squarer</strong> (ch2, ch1)</p>
<p><strong>printer</strong> (ch2)</p>
<p>}</p>
<p>其中，</p>
<p>1.chan&amp;lt;- <strong>int</strong> 是一个只能发送的通道，可以发送但是不能接收；</p>
<p>2.&amp;lt;-chan <strong>int</strong> 是一个只能接收的通道，可以接收但是不能发送。</p>
<p>在函数传参及任何赋值操作中将双向通道转换为单向通道是可以的，但反过来是不可以的。</p>
<p>注意:关闭已经关闭的channel也会引发panic。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Goroutine池</title>
    <url>/2021/02/19/Goroutine%E6%B1%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h1><h1 id="池"><a href="#池" class="headerlink" title="池"></a>池</h1><h3 id="worker-pool-（-goroutine-池）"><a href="#worker-pool-（-goroutine-池）" class="headerlink" title="worker pool** （ goroutine 池）**"></a><strong>worker pool**</strong> （ <strong><strong>goroutine</strong></strong> 池）**</h3><ul>
<li>本质上是生产者消费者模型</li>
<li>可以有效控制goroutine数量，防止暴涨</li>
<li>需求：<ul>
<li>计算一个数字的各个位数之和，例如数字123，结果为1+2+3=6</li>
<li>随机生成数字进行计算</li>
</ul>
</li>
<li>控制台输出结果如下：</li>
</ul>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-b9ss8m_html_c0ba2d4575a166d7.png"  alt=""></p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;math/rand&quot;)</p>
<p>type Job <strong>struct</strong> {</p>
<p><em>// id</em></p>
<p>Id <strong>int</strong></p>
<p><em>//</em> <em>需要计算的随机数</em></p>
<p>RandNum <strong>int</strong></p>
<p>}</p>
<p>type Result <strong>struct</strong> {</p>
<p><em>//</em> <em>这里必须传对象实例</em></p>
<p>job *Job</p>
<p><em>//</em> <em>求和</em></p>
<p>sum <strong>int</strong></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><em>//</em> <em>需要 <strong>2</strong> 个管道</em></p>
<p><em>// 1.job__管道</em></p>
<p>jobChan := make(chan *Job, 128)</p>
<p><em>// 2.__结果管道</em></p>
<p>resultChan := make(chan *Result, 128)</p>
<p><em>// 3.__创建工作池</em></p>
<p>createPool(64, jobChan, resultChan)</p>
<p><em>// 4.__开个打印的协程</em></p>
<p>go <strong>func</strong> (resultChan chan *Result) {</p>
<p><em>//</em> <em>遍历结果管道打印</em></p>
<p><strong>for</strong> result := range resultChan {</p>
<p>fmt.Printf(&quot;job id:%v randnum:%v result:%d\n&quot;, result.job.Id,</p>
<p>result.job.RandNum, result.sum)</p>
<p>}</p>
<p>}(resultChan)</p>
<p><strong>var</strong> id <strong>int</strong></p>
<p><em>//</em> <em>循环创建 <strong>job</strong> ，输入到管道</em></p>
<p><strong>for</strong> {</p>
<p>id++</p>
<p><em>//</em> <em>生成随机数</em></p>
<p>r_num := rand.Int()</p>
<p>job := &amp;Job{</p>
<p>Id: id,</p>
<p>RandNum: r_num,</p>
<p>}</p>
<p>jobChan &amp;lt;- job</p>
<p>}</p>
<p>}</p>
<p><em>//</em> <em>创建工作池 __//</em> <em>参数_</em> 1__：开几个协程_func <strong>createPool</strong> (num <strong>int</strong> , jobChan chan *Job, resultChan chan *Result) {</p>
<p><em>//</em> <em>根据开协程个数，去跑运行</em></p>
<p><strong>for</strong> i := 0; i &amp;lt; num; i++ {</p>
<p>go <strong>func</strong> (jobChan chan *Job, resultChan chan *Result) {</p>
<p><em>//</em> <em>执行运算</em></p>
<p><em>//</em> <em>遍历 <strong>job</strong> 管道所有数据，进行相加</em></p>
<p><strong>for</strong> job := range jobChan {</p>
<p><em>//</em> <em>随机数接过来</em></p>
<p>r_num := job.RandNum</p>
<p><em>//</em> <em>随机数每一位相加</em></p>
<p><em>//</em> <em>定义返回值</em></p>
<p><strong>var</strong> sum <strong>int</strong></p>
<p><strong>for</strong> r_num != 0 {</p>
<p>tmp := r_num % 10</p>
<p>sum += tmp</p>
<p>r_num /= 10</p>
<p>}</p>
<p><em>//</em> <em>想要的结果是__Result</em></p>
<p>r := &amp;Result{</p>
<p>job: job,</p>
<p>sum: sum,</p>
<p>}</p>
<p><em>//__运算结果扔到管道</em></p>
<p>resultChan &amp;lt;- r</p>
<p>}</p>
<p>}(jobChan, resultChan)</p>
<p>}</p>
<p>}</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Goroutine</title>
    <url>/2021/02/19/Gorouytine/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h1><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p>
<p>Go语言中的goroutine就是这样一种机制，goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>
<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。</p>
<h4 id="使用-goroutine"><a href="#使用-goroutine" class="headerlink" title="使用** goroutine**"></a><strong>使用**</strong> goroutine**</h4><p>Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。</p>
<p>一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。</p>
<h4 id="启动单个-goroutine"><a href="#启动单个-goroutine" class="headerlink" title="启动单个** goroutine**"></a><strong>启动单个**</strong> goroutine**</h4><p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个go关键字。</p>
<p>举个例子如下：</p>
<p>func <strong>hello</strong> () {</p>
<p>fmt.Println(&quot;Hello Goroutine!&quot;)</p>
<p>}func <strong>main</strong> () {</p>
<p>hello()</p>
<p>fmt.Println(&quot;main goroutine done!&quot;)</p>
<p>}</p>
<p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完Hello Goroutine!后打印main goroutine done!。</p>
<p>接下来我们在调用hello函数前面加上关键字go，也就是启动一个goroutine去执行hello这个函数。</p>
<p>func <strong>main</strong> () {</p>
<p>go <strong>hello</strong> () <em>//</em> <em>启动另外一个 <strong>goroutine</strong> 去执行 <strong>hello</strong> 函数</em></p>
<p>fmt. <strong>Println</strong> (&quot;main goroutine done!&quot;)</p>
<p>}</p>
<p>这一次的执行结果只打印了main goroutine done!，并没有打印Hello Goroutine!。为什么呢？</p>
<p>在程序启动时，Go程序就会为main()函数创建一个默认的goroutine。</p>
<p>当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p>
<p>所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是time.Sleep了。</p>
<p>func <strong>main</strong> () {</p>
<p>go <strong>hello</strong> () <em>//</em> <em>启动另外一个 <strong>goroutine</strong> 去执行 <strong>hello</strong> 函数</em></p>
<p>fmt. <strong>Println</strong> (&quot;main goroutine done!&quot;)</p>
<p>time. <strong>Sleep</strong> (time.Second)</p>
<p>}</p>
<p>执行上面的代码你会发现，这一次先打印main goroutine done!，然后紧接着打印Hello Goroutine!。</p>
<p>首先为什么会先打印main goroutine done!是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的goroutine是继续执行的。</p>
<h4 id="启动多个-goroutine"><a href="#启动多个-goroutine" class="headerlink" title="启动多个** goroutine**"></a><strong>启动多个**</strong> goroutine**</h4><p>在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步）</p>
<p><strong>var</strong> wg sync.WaitGroup</p>
<p>func <strong>hello</strong> (i <strong>int</strong> ) {</p>
<p>defer wg.Done() <em>// goroutine <strong>结束就登记</strong> -1</em></p>
<p>fmt.Println(&quot;Hello Goroutine!&quot;, i)</p>
<p>}func <strong>main</strong> () {</p>
<p><strong>for</strong> i := 0; i &amp;lt; 10; i++ {</p>
<p>wg.Add(1) <em>//</em> <em>启动一个 <strong>goroutine</strong> 就登记__+1</em></p>
<p>go <strong>hello</strong> (i)</p>
<p>}</p>
<p>wg. <strong>Wait</strong> () <em>//</em> <em>等待所有登记的 <strong>goroutine</strong> 都结束</em></p>
<p>}</p>
<p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h4><ul>
<li>如果主协程退出了，其他任务还执行吗（运行下面的代码测试一下吧）</li>
</ul>
<p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;time&quot;</p>
<p>)</p>
<p>func <strong>main</strong> () {</p>
<p><em>//</em> <em>合起来写</em></p>
<p>go <strong>func</strong> () {</p>
<p>i := 0</p>
<p><strong>for</strong> {</p>
<p>i++</p>
<p>fmt.Printf(&quot;new goroutine: i = %d\n&quot;, i)</p>
<p>time.Sleep(time.Second)</p>
<p>}</p>
<p>}()</p>
<p>i := 0</p>
<p><strong>for</strong> {</p>
<p>i++</p>
<p>fmt.Printf(&quot;main goroutine: i = %d\n&quot;, i)</p>
<p>time.Sleep(time.Second)</p>
<p><strong>if</strong> i == 2 {</p>
<p><strong>break</strong></p>
<p>}</p>
<p>}</p>
<p>}</p>
<h3 id="goroutine-与线程"><a href="#goroutine-与线程" class="headerlink" title="goroutine** 与线程**"></a><strong>goroutine**</strong> 与线程**</h3><h4 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a><strong>可增长的栈</strong></h4><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的goroutine也是可以的。</p>
<h4 id="goroutine-调度"><a href="#goroutine-调度" class="headerlink" title="goroutine** 调度**"></a><strong>goroutine**</strong> 调度**</h4><p>GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<ul>
<li>1.G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li>
<li>2.P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>
<li>3.M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li>
</ul>
<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>
<p>P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go module</title>
    <url>/2021/02/19/go-modulie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="go-module"><a href="#go-module" class="headerlink" title="go module"></a>go module</h1><h3 id="为什么需要依赖管理"><a href="#为什么需要依赖管理" class="headerlink" title="为什么需要依赖管理"></a><strong>为什么需要依赖管理</strong></h3><ul>
<li>最早的时候，Go所依赖的所有的第三方库都放在GOPATH这个目录下面。这就导致了同一个库只能保存一个版本的代码。如果不同的项目依赖同一个第三方的库的不同版本，应该怎么解决？</li>
</ul>
<h3 id="go-module-1"><a href="#go-module-1" class="headerlink" title="go module"></a><strong>go module</strong></h3><p>go module是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，go module将是Go语言默认的依赖管理工具。</p>
<h3 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a><strong>GO111MODULE</strong></h3><p>要启用go module支持首先要设置环境变量GO111MODULE，通过它可以开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是auto。</p>
<p>-</p>
<p>GO111MODULE=off禁用模块支持，编译时会从GOPATH和vendor文件夹中查找包。</p>
<h2 id=""><a href="#" class="headerlink" title="-"></a>-</h2><p>GO111MODULE=on启用模块支持，编译时会忽略GOPATH和vendor文件夹，只根据 go.mod下载依赖。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="-"></a>-</h2><p>GO111MODULE=auto，当项目在$GOPATH/src外且项目根目录有go.mod文件时，开启模块支持。</p>
<p>-</p>
<p>简单来说，设置GO111MODULE=on之后就可以使用go module了，以后就没有必要在GOPATH中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。</p>
<p>使用 go module 管理依赖后会在项目根目录下生成两个文件go.mod和go.sum。</p>
<h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a><strong>GOPROXY</strong></h3><p>Go1.11之后设置GOPROXY命令为：</p>
<p><strong>export</strong> GOPROXY=https:<em>//goproxy.cn</em></p>
<p>Go1.13之后GOPROXY默认值为 <a href="https://proxy.golang.org/" target="_blank" rel="noopener">https://proxy.golang.org</a> ，在国内是无法访问的，所以十分建议大家设置GOPROXY，这里我推荐使用goproxy.cn。</p>
<p>go env -w GOPROXY=<a href="https://goproxy.cn,direct" target="_blank" rel="noopener">https://goproxy.cn,direct</a></p>
<h3 id="go-mod-命令"><a href="#go-mod-命令" class="headerlink" title="go mod** 命令**"></a><strong>go mod**</strong> 命令**</h3><p>常用的go mod命令如下：</p>
<p>go mod download 下载依赖的module到本地 <strong>cache</strong> （默认为$GOPATH/pkg/ <strong>mod</strong> 目录）</p>
<p><strong>go**</strong> mod** edit 编辑go.mod文件</p>
<p><strong>go**</strong> mod** graph 打印模块依赖图</p>
<p><strong>go**</strong> mod** init 初始化当前文件夹, 创建go.mod文件</p>
<p><strong>go**</strong> mod <strong>tidy 增加缺少的</strong> module <strong>，删除无用的</strong> module**</p>
<p><strong>go**</strong> mod** vendor 将依赖复制到vendor下</p>
<p><strong>go**</strong> mod <strong>**verify</strong> 校验依赖</p>
<p><strong>go**</strong> mod** why 解释为什么需要依赖</p>
<h3 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a><strong>go get</strong></h3><p>在项目中执行go get命令可以下载依赖包，并且还可以指定下载的版本。</p>
<ul>
<li>运行go get -u将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li>
<li>运行go get -u=patch将会升级到最新的修订版本</li>
<li>运行go get package<a href="https://github.com/version" target="_blank" rel="noopener">@version</a>将会升级到指定的版本号version<br>如果下载所有依赖可以使用go mod download命令。</li>
</ul>
<h3 id="简单粗暴的使用-go-module"><a href="#简单粗暴的使用-go-module" class="headerlink" title="简单粗暴的使用** go module**"></a><strong>简单粗暴的使用**</strong> go module**</h3><p>1.set GO111MODULE=on</p>
<p>2.SET GOPROXY=<a href="https://goproxy.cn/" target="_blank" rel="noopener">https://goproxy.cn</a> (这是win环境下的) export GOPROXY=<a href="https://goproxy.cn/" target="_blank" rel="noopener">https://goproxy.cn</a> (这是mac环境下的)</p>
<p>3.go mod init [包名] // 初始化项目(如果你是初始化项目直接 go mod init 就好了)</p>
<p>4.在你的目录文件下会生成go.mod和go.sum文件 go.mod 里面包含了你的所有的包！</p>
<p>5.在文件里面引入包名的时候有的编辑器会报错但是是可以正常编译的</p>
<p>6.下载包使用go get</p>
<p>7.修改包的版本号直接去go.mod文件修改然后go mod download</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Sync</title>
    <url>/2021/02/19/Sync/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h1><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a><strong>sync.WaitGroup</strong></h3><p>在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 sync.WaitGroup有以下几个方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>(wg * WaitGroup) Add(delta int)</td>
<td>计数器+delta</td>
</tr>
<tr>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>(wg *WaitGroup) Done()</td>
<td>计数器-1</td>
</tr>
<tr>
<td>(wg *WaitGroup) Wait()</td>
<td>阻塞直到计数器变为0</td>
</tr>
</tbody></table>
<p>sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p>
<p>我们利用sync.WaitGroup将上面的代码优化一下：</p>
<p><strong>var</strong> wg sync.WaitGroup</p>
<p>func <strong>hello</strong> () {</p>
<p>defer wg.Done()</p>
<p>fmt.Println(&quot;Hello Goroutine!&quot;)</p>
<p>}func <strong>main</strong> () {</p>
<p>wg.Add(1)</p>
<p>go <strong>hello</strong> () <em>//</em> <em>启动另外一个 <strong>goroutine</strong> 去执行 <strong>hello</strong> 函数</em></p>
<p>fmt. <strong>Println</strong> (&quot;main goroutine done!&quot;)</p>
<p>wg. <strong>Wait</strong> ()</p>
<p>}</p>
<p>需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针。</p>
<h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a><strong>sync.Once</strong></h3><p>说在前面的话：这是一个进阶知识点。</p>
<p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p>
<p>Go语言中的sync包中提供了一个针对只执行一次场景的解决方案–sync.Once。</p>
<p>sync.Once只有一个Do方法，其签名如下：</p>
<p>func (o *Once) Do(f <strong>func</strong> ()) {}</p>
<p>注意：如果要执行的函数f需要传递参数就需要搭配闭包来使用。</p>
<h4 id="加载配置文件示例"><a href="#加载配置文件示例" class="headerlink" title="加载配置文件示例"></a><strong>加载配置文件示例</strong></h4><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p>
<p>var icons map[string]image.Image</p>
<p>func <strong>loadIcons</strong> () {</p>
<p>icons = map[string]image.Image{</p>
<p>&quot;left&quot;: loadIcon(&quot;left.png&quot;),</p>
<p>&quot;up&quot;: loadIcon(&quot;up.png&quot;),</p>
<p>&quot;right&quot;: loadIcon(&quot;right.png&quot;),</p>
<p>&quot;down&quot;: loadIcon(&quot;down.png&quot;),</p>
<p>}</p>
<p>}</p>
<p><em>// Icon</em> <em>被多个 <strong>goroutine</strong> 调用时不是并发安全的</em></p>
<p>func Icon(name string) image.Image {</p>
<p><strong>if</strong> icons == nil {</p>
<p>loadIcons()</p>
<p>}</p>
<p><strong>return</strong> icons[name]</p>
<p>}</p>
<p>多个goroutine并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个goroutine都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p>
<p>func <strong>loadIcons</strong> () {</p>
<p>icons = make(map[string]image.Image)</p>
<p>icons[&quot;left&quot;] = loadIcon(&quot;left.png&quot;)</p>
<p>icons[&quot;up&quot;] = loadIcon(&quot;up.png&quot;)</p>
<p>icons[&quot;right&quot;] = loadIcon(&quot;right.png&quot;)</p>
<p>icons[&quot;down&quot;] = loadIcon(&quot;down.png&quot;)</p>
<p>}</p>
<p>在这种情况下就会出现即使判断了icons不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的goroutine操作，但是这样做又会引发性能问题。</p>
<p>使用sync.Once改造的示例代码如下：</p>
<p><strong>var</strong> icons map[<strong>string</strong>]image.Image</p>
<p><strong>var</strong> loadIconsOnce sync.Once</p>
<p>func <strong>loadIcons</strong> () {</p>
<p>icons = map[<strong>string</strong>]image.Image{</p>
<p>&quot;left&quot;: loadIcon(&quot;left.png&quot;),</p>
<p>&quot;up&quot;: loadIcon(&quot;up.png&quot;),</p>
<p>&quot;right&quot;: loadIcon(&quot;right.png&quot;),</p>
<p>&quot;down&quot;: loadIcon(&quot;down.png&quot;),</p>
<p>}</p>
<p>}</p>
<p><em>// Icon</em> _是并发安全的_func <strong>Icon</strong> (name <strong>string</strong> ) image.Image {</p>
<p>loadIconsOnce.Do(loadIcons)</p>
<p><strong>return</strong> icons[name]</p>
<p>}</p>
<p>sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>
<h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a><strong>sync.Map</strong></h3><p>Go语言中内置的map不是并发安全的。请看下面的示例：</p>
<p><strong>var</strong> m = make(map[<strong>string</strong>] <strong>int</strong> )</p>
<p>func <strong>get</strong> (key <strong>string</strong> ) <strong>int</strong> {</p>
<p><strong>return</strong> m[key]</p>
<p>}</p>
<p>func <strong>set</strong> (key <strong>string</strong> , <strong>value**</strong> int**) {</p>
<p>m[key] = <strong>value</strong></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>wg := sync.WaitGroup{}</p>
<p><strong>for</strong> i := 0; i &amp;lt; 20; i++ {</p>
<p>wg.Add(1)</p>
<p>go <strong>func</strong> (n <strong>int</strong> ) {</p>
<p>key := strconv.Itoa(n)</p>
<p><strong>set</strong> (key, n)</p>
<p>fmt.Printf(&quot;k=:%v,v:=%v\n&quot;, key, <strong>get</strong> (key))</p>
<p>wg.Done()</p>
<p>}(i)</p>
<p>}</p>
<p>wg.Wait()</p>
<p>}</p>
<p>上面的代码开启少量几个goroutine的时候可能没什么问题，当并发多了之后执行上面的代码就会报fatal error: concurrent map writes错误。</p>
<p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。</p>
<p><strong>var</strong> m = sync.Map{}</p>
<p>func <strong>main</strong> () {</p>
<p>wg := sync.WaitGroup{}</p>
<p><strong>for</strong> i := 0; i &amp;lt; 20; i++ {</p>
<p>wg.Add(1)</p>
<p>go <strong>func</strong> (n <strong>int</strong> ) {</p>
<p>key := strconv.Itoa(n)</p>
<p>m.Store(key, n)</p>
<p><strong>value</strong> , _ := m.Load(key)</p>
<p>fmt.Printf(&quot;k=:%v,v:=%v\n&quot;, key, <strong>value</strong> )</p>
<p>wg.Done()</p>
<p>}(i)</p>
<p>}</p>
<p>wg.Wait()</p>
<p>}</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>runtime包</title>
    <url>/2021/02/19/runtime%E5%8C%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h1><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h3 id="runtime-Gosched"><a href="#runtime-Gosched" class="headerlink" title="runtime.Gosched()"></a><strong>runtime.Gosched()</strong></h3><p>让出CPU时间片，重新等待安排任务(大概意思就是本来计划的好好的周末出去烧烤，但是你妈让你去相亲,两种情况第一就是你相亲速度非常快，见面就黄不耽误你继续烧烤，第二种情况就是你相亲速度特别慢，见面就是你侬我侬的，耽误了烧烤，但是还馋就是耽误了烧烤你还得去烧烤)</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;runtime&quot;</p>
<p>)</p>
<p>func <strong>main</strong> () {</p>
<p>go <strong>func</strong> (s string) {</p>
<p><strong>for</strong> i := 0; i &amp;lt; 2; i++ {</p>
<p>fmt.Println(s)</p>
<p>}</p>
<p>}(&quot;world&quot;)</p>
<p><em>//</em> <em>主协程</em></p>
<p><strong>for</strong> i := 0; i &amp;lt; 2; i++ {</p>
<p><em>//</em> <em>切一下，再次分配任务</em></p>
<p>runtime.Gosched()</p>
<p>fmt.Println(&quot;hello&quot;)</p>
<p>}</p>
<p>}</p>
<h3 id="runtime-Goexit"><a href="#runtime-Goexit" class="headerlink" title="runtime.Goexit()"></a><strong>runtime.Goexit()</strong></h3><p>退出当前协程(一边烧烤一边相亲，突然发现相亲对象太丑影响烧烤，果断让她滚蛋，然后也就没有然后了)</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;runtime&quot;</p>
<p>)</p>
<p>func <strong>main</strong> () {</p>
<p>go <strong>func</strong> () {</p>
<p>defer fmt.Println(&quot;A.defer&quot;)</p>
<p>func() {</p>
<p>defer fmt.Println(&quot;B.defer&quot;)</p>
<p><em>//</em> <em>结束协程</em></p>
<p>runtime.Goexit()</p>
<p>defer fmt.Println(&quot;C.defer&quot;)</p>
<p>fmt.Println(&quot;B&quot;)</p>
<p>}()</p>
<p>fmt.Println(&quot;A&quot;)</p>
<p>}()</p>
<p><strong>for</strong> {</p>
<p>}</p>
<p>}</p>
<h3 id="runtime-GOMAXPROCS"><a href="#runtime-GOMAXPROCS" class="headerlink" title="runtime.GOMAXPROCS"></a><strong>runtime.GOMAXPROCS</strong></h3><p>Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>
<p>Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。</p>
<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
<p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p>
<p>func <strong>a</strong> () {</p>
<p><strong>for</strong> i := 1; i &amp;lt; 10; i++ {</p>
<p>fmt.Println(&quot;A:&quot;, i)</p>
<p>}</p>
<p>}</p>
<p>func <strong>b</strong> () {</p>
<p><strong>for</strong> i := 1; i &amp;lt; 10; i++ {</p>
<p>fmt.Println(&quot;B:&quot;, i)</p>
<p>}</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>runtime.GOMAXPROCS(1)</p>
<p>go <strong>a</strong> ()</p>
<p>go <strong>b</strong> ()</p>
<p>time. <strong>Sleep</strong> (time.Second)</p>
<p>}</p>
<p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。</p>
<p>func <strong>a</strong> () {</p>
<p><strong>for</strong> i := 1; i &amp;lt; 10; i++ {</p>
<p>fmt.Println(&quot;A:&quot;, i)</p>
<p>}</p>
<p>}</p>
<p>func <strong>b</strong> () {</p>
<p><strong>for</strong> i := 1; i &amp;lt; 10; i++ {</p>
<p>fmt.Println(&quot;B:&quot;, i)</p>
<p>}</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>runtime.GOMAXPROCS(2)</p>
<p>go <strong>a</strong> ()</p>
<p>go <strong>b</strong> ()</p>
<p>time. <strong>Sleep</strong> (time.Second)</p>
<p>}</p>
<p>Go语言中的操作系统线程和goroutine的关系：</p>
<ul>
<li>1.一个操作系统线程对应用户态多个goroutine。</li>
<li>2.go程序可以同时使用多个操作系统线程。</li>
<li>3.goroutine和OS线程是多对多的关系，即m:n。</li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>并发和安全锁</title>
    <url>/2021/02/19/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%AE%89%E5%85%A8%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h1><p>有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p>
<p>举个例子：</p>
<p><strong>var</strong> x int64 <strong>var</strong> wg sync.WaitGroup</p>
<p>func <strong>add</strong> () {</p>
<p><strong>for</strong> i := 0; i &amp;lt; 5000; i++ {</p>
<p>x = x + 1</p>
<p>}</p>
<p>wg.Done()</p>
<p>}func <strong>main</strong> () {</p>
<p>wg.Add(2)</p>
<p>go <strong>add</strong> ()</p>
<p>go <strong>add</strong> ()</p>
<p>wg. <strong>Wait</strong> ()</p>
<p>fmt. <strong>Println</strong> (x)</p>
<p>}</p>
<p>上面的代码中我们开启了两个goroutine去累加变量x的值，这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><strong>互斥锁</strong></h3><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p>
<p><strong>var</strong> x int64 <strong>var</strong> wg sync.WaitGroup <strong>var**</strong> lock** sync.Mutex</p>
<p>func <strong>add</strong> () {</p>
<p><strong>for</strong> i := 0; i &amp;lt; 5000; i++ {</p>
<p><strong>lock</strong>.Lock() <em>//</em> <em>加锁</em></p>
<p>x = x + 1</p>
<p><strong>lock</strong>.Unlock() <em>//</em> <em>解锁</em></p>
<p>}</p>
<p>wg.Done()</p>
<p>}func <strong>main</strong> () {</p>
<p>wg.Add(2)</p>
<p>go <strong>add</strong> ()</p>
<p>go <strong>add</strong> ()</p>
<p>wg. <strong>Wait</strong> ()</p>
<p>fmt. <strong>Println</strong> (x)</p>
<p>}</p>
<p>使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。</p>
<h3 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a><strong>读写互斥锁</strong></h3><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的RWMutex类型。</p>
<p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。</p>
<p>读写锁示例：</p>
<p><strong>var</strong> (</p>
<p>x int64</p>
<p>wg sync.WaitGroup</p>
<p><strong>lock</strong> sync.Mutex</p>
<p>rwlock sync.RWMutex</p>
<p>)</p>
<p>func <strong>write</strong> () {</p>
<p><em>// lock.Lock() //</em> <em>加互斥锁</em></p>
<p>rwlock.Lock() <em>//</em> <em>加写锁</em></p>
<p>x = x + 1</p>
<p>time.Sleep(10 * time.Millisecond) <em>//</em> <em>假设读操作耗时 <strong>10</strong> 毫秒</em></p>
<p>rwlock.Unlock() <em>//</em> <em>解写锁</em></p>
<p><em>// lock.Unlock() //</em> <em>解互斥锁</em></p>
<p>wg.Done()</p>
<p>}</p>
<p>func <strong>read</strong> () {</p>
<p><em>// lock.Lock() //</em> <em>加互斥锁</em></p>
<p>rwlock.RLock() <em>//</em> <em>加读锁</em></p>
<p>time.Sleep(time.Millisecond) <em>//</em> <em>假设读操作耗时 <strong>1</strong> 毫秒</em></p>
<p>rwlock.RUnlock() <em>//</em> <em>解读锁</em></p>
<p><em>// lock.Unlock() //</em> <em>解互斥锁</em></p>
<p>wg.Done()</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>start := time.Now()</p>
<p><strong>for</strong> i := 0; i &amp;lt; 10; i++ {</p>
<p>wg.Add(1)</p>
<p>go <strong>write</strong> ()</p>
<p>}</p>
<p><strong>for</strong> i := 0; i &amp;lt; 1000; i++ {</p>
<p>wg.Add(1)</p>
<p>go <strong>read</strong> ()</p>
<p>}</p>
<p>wg. <strong>Wait</strong> ()</p>
<p>end := time.Now()</p>
<p>fmt.Println(end.Sub(start))</p>
<p>}</p>
<p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>表达式</title>
    <url>/2021/02/19/%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>Golang 表达式 ：根据调用者不同，方法分为两种表现形式:</p>
<p><strong>instance</strong>.method( <strong>args</strong>…) <strong>—</strong> &amp;gt; &amp;lt; <strong>type</strong> &amp;gt;.func( <strong>instance</strong> , <strong>args</strong>…)</p>
<p>前者称为 method value，后者 method expression。</p>
<p>两者都可像普通函数那样赋值和传参，区别在于 method value 绑定实例，而 method expression 则须显式传参。</p>
<p>package main</p>
<p>import &quot;fmt&quot;</p>
<p>type User <strong>struct</strong> {</p>
<p><strong>id**</strong> int**</p>
<p>name string</p>
<p>}</p>
<p>func ( <strong>self</strong> *User) Test() {</p>
<p>fmt.Printf(&quot;%p, %v\n&quot;, <strong>self</strong> , <strong>self</strong> )</p>
<p>}</p>
<p>func main() {</p>
<p>u := User{1, &quot;Tom&quot;}</p>
<p>u.Test()</p>
<p>mValue := u.Test</p>
<p>mValue() <em>//</em> <em>隐式传递</em> <em>receiver</em></p>
<p>mExpression := (*User).Test</p>
<p>mExpression(&amp;u) <em>//</em> <em>显式传递</em> <em>receiver</em></p>
<p>}</p>
<p>输出结果:</p>
<p>0xc42000a060, &amp;{1 Tom}</p>
<p>0xc42000a060, &amp;{1 Tom}</p>
<p>0xc42000a060, &amp;{1 Tom}</p>
<p>需要注意，method value 会复制 receiver。</p>
<p>package main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>type User <strong>struct</strong> {</p>
<p>id <strong>int</strong></p>
<p>name string</p>
<p>}</p>
<p>func (self User) Test() {</p>
<p>fmt.Println(self)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>u := User{1, &quot;Tom&quot;}</p>
<p>mValue := u.Test <em>//</em> <em>立即复制</em> <em>receiver__，因为不是指针类型，不受后续修改影响。</em></p>
<p>u.id, u.name = 2, &quot;Jack&quot;</p>
<p>u.Test()</p>
<p>mValue()</p>
<p>}</p>
<p>输出结果</p>
<p>{2 Jack}</p>
<p>{1 Tom}</p>
<p>在汇编层面，method value 和闭包的实现方式相同，实际返回 FuncVal 类型对象。</p>
<p>FuncVal { method_address, receiver_copy }</p>
<p>可依据方法集转换 method expression，注意 receiver 类型的差异。</p>
<p>package main</p>
<p>import &quot;fmt&quot;</p>
<p>type User <strong>struct</strong> {</p>
<p><strong>id**</strong> int**</p>
<p>name string</p>
<p>}</p>
<p>func ( <strong>self</strong> *User) TestPointer() {</p>
<p>fmt.Printf(&quot;TestPointer: %p, %v\n&quot;, <strong>self</strong> , <strong>self</strong> )</p>
<p>}</p>
<p>func ( <strong>self</strong> User) TestValue() {</p>
<p>fmt.Printf(&quot;TestValue: %p, %v\n&quot;, &amp; <strong>self</strong> , <strong>self</strong> )</p>
<p>}</p>
<p>func main() {</p>
<p>u := User{1, &quot;Tom&quot;}</p>
<p>fmt.Printf(&quot;User: %p, %v\n&quot;, &amp;u, u)</p>
<p>mv := User.TestValue</p>
<p>mv(u)</p>
<p>mp := (*User).TestPointer</p>
<p>mp(&amp;u)</p>
<p>mp2 := (*User).TestValue <em>// *User</em> <em>方法集包含</em> <em>TestValue__。签名变为</em> <em>func TestValue(self *User)__。实际依然是</em> <em>receiver value copy__。</em></p>
<p>mp2(&amp;u)</p>
<p>}</p>
<p>输出:</p>
<p>User: 0xc42000a060, {1 Tom}</p>
<p>TestValue: 0xc42000a0a0, {1 Tom}</p>
<p>TestPointer: 0xc42000a060, &amp;{1 Tom}</p>
<p>TestValue: 0xc42000a100, {1 Tom}</p>
<p>将方法 &quot;还原&quot; 成函数，就容易理解下面的代码了。</p>
<p>package main</p>
<p>type Data <strong>struct</strong> {}</p>
<p>func (Data) TestValue() {}</p>
<p>func (*Data) TestPointer() {}</p>
<p>func main() {</p>
<p>var p *Data = nil</p>
<p>p.TestPointer()</p>
<p>(*Data)(nil).TestPointer() <em>// method value</em></p>
<p>(*Data).TestPointer(nil) <em>// method expression</em></p>
<p><em>// p.TestValue() // invalid memory address or nil pointer dereference</em></p>
<p><em>// (Data)(nil).TestValue() // cannot convert nil to type Data</em></p>
<p><em>// Data.TestValue(nil) // cannot use nil as type Data in function argument</em></p>
<p>}</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包、递归</title>
    <url>/2021/02/19/%E9%97%AD%E5%8C%85%E3%80%81%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="闭包、递归"><a href="#闭包、递归" class="headerlink" title="闭包、递归"></a>闭包、递归</h1><h3 id="闭包详解"><a href="#闭包详解" class="headerlink" title="闭包详解"></a><strong>闭包详解</strong></h3><p>闭包的应该都听过，但到底什么是闭包呢？</p>
<p>闭包是由函数及其相关引用环境组合而成的实体(即：闭包=函数+引用环境)。</p>
<p>&quot;官方&quot;的解释是：所谓&quot;闭包&quot;，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>
<p>维基百科讲，闭包（Closure），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p>
<p>看着上面的描述，会发现闭包和匿名函数似乎有些像。可是可能还是有些云里雾里的。因为跳过闭包的创建过程直接理解闭包的定义是非常困难的。目前在JavaScript、Go、PHP、Scala、Scheme、Common Lisp、Smalltalk、Groovy、Ruby、 Python、Lua、objective c、Swift 以及Java8以上等语言中都能找到对闭包不同程度的支持。通过支持闭包的语法可以发现一个特点，他们都有垃圾回收(GC)机制。<br> javascript应该是普及度比较高的编程语言了，通过这个来举例应该好理解写。看下面的代码，只要关注script里方法的定义和调用就可以了。</p>
<p><strong>&amp;lt;!DOCTYPE html&amp;gt;</strong> &amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;head&amp;gt;</p>
<p>&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;lt;script src=&quot;<a href="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js&quot;type=&quot;text/javascript&quot;\&gt;\&lt;/script\&gt;\&lt;script\" target="_blank" rel="noopener">http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js&quot;type=&quot;text/javascript&quot;\&gt;\&lt;/script\&gt;\&lt;script\</a>&gt; <strong>function**</strong> a**(){</p>
<p><strong>var</strong> i=0;</p>
<p><strong>function**</strong> b**(){</p>
<p>console.log(++i);</p>
<p>document.write(&quot;&amp;lt;h1&amp;gt;&quot;+i+&quot;&amp;lt;/h1&amp;gt;&quot;);</p>
<p>}</p>
<p><strong>return</strong> b;</p>
<p>}</p>
<p>$( <strong>function</strong> (){</p>
<p><strong>var</strong> c=a();</p>
<p>c();</p>
<p>c();</p>
<p>c();</p>
<p><em>//a(); //__不会有信息输出</em></p>
<p>document.write(&quot;&amp;lt;h1&amp;gt;=============&amp;lt;/h1&amp;gt;&quot;);</p>
<p><strong>var</strong> c2=a();</p>
<p>c2();</p>
<p>c2();</p>
<p>});</p>
<p>&amp;lt;/script&amp;gt;</p>
<p>这段代码有两个特点：</p>
<p>函数b嵌套在函数a内部<br>函数a返回函数b<br>这样在执行完var c=a()后，变量c实际上是指向了函数b()，再执行函数c()后就会显示i的值，第一次为1，第二次为2，第三次为3，以此类推。<br>其实，这段代码就创建了一个闭包。因为函数a()外的变量c引用了函数a()内的函数b()，就是说：</p>
<p>当函数a()的内部函数b()被函数a()外的一个变量引用的时候，就创建了一个闭包。<br>在上面的例子中，由于闭包的存在使得函数a()返回后，a中的i始终存在，这样每次执行c()，i都是自加1后的值。<br>从上面可以看出闭包的作用就是在a()执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a()所占用的资源，因为a()的内部函数b()的执行需要依赖a()中的变量i。</p>
<p>在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。变量的作用域仅限于包含它们的函数，因此无法从其它程序代码部分进行访问。不过，变量的生存期是可以很长，在一次函数调用期间所创建所生成的值在下次函数调用时仍然存在。正因为这一特点，闭包可以用来完成信息隐藏，并进而应用于需要状态表达的某些编程范型中。<br>下面来想象另一种情况，如果a()返回的不是函数b()，情况就完全不同了。因为a()执行完后，b()没有被返回给a()的外界，只是被a()所引用，而此时a()也只会被b()引 用，因此函数a()和b()互相引用但又不被外界打扰（被外界引用），函数a和b就会被GC回收。所以直接调用a();是页面并没有信息输出。</p>
<p>下面来说闭包的另一要素引用环境。c()跟c2()引用的是不同的环境，在调用i++时修改的不是同一个i，因此两次的输出都是1。函数a()每进入一次，就形成了一个新的环境，对应的闭包中，函数都是同一个函数，环境却是引用不同的环境。这和c()和c()的调用顺序都是无关的。</p>
<h3 id="Go-的闭包"><a href="#Go-的闭包" class="headerlink" title="Go** 的闭包**"></a><strong>Go**</strong> 的闭包**</h3><p>Go语言是支持闭包的，这里只是简单地讲一下在Go语言中闭包是如何实现的。<br>下面我来将之前的JavaScript的闭包例子用Go来实现。</p>
<p><strong>package**</strong> main**</p>
<p><strong>import</strong> (</p>
<p>&quot; <strong>fmt</strong>&quot;</p>
<p>)</p>
<p><strong>func**</strong> a<strong>()</strong>func<strong>()</strong>int** {</p>
<p>i := 0</p>
<p>b := func() int {</p>
<p>i++</p>
<p>fmt.Println(i)</p>
<p>return i</p>
<p>}</p>
<p><strong>return**</strong> b**</p>
<p>}</p>
<p><strong>func**</strong> main**() {</p>
<p>c := a()</p>
<p>c()</p>
<p>c()</p>
<p>c()</p>
<p>a() //不会输出i</p>
<p>}</p>
<p>输出结果：</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>可以发现，输出和之前的JavaScript的代码是一致的。具体的原因和上面的也是一样的，这说明Go语言是支持闭包的。</p>
<p>闭包复制的是原对象指针，这就很容易解释延迟引用现象。</p>
<p><strong>package**</strong> main**</p>
<p><strong>import</strong>&quot; <strong>fmt</strong>&quot;</p>
<p><strong>func**</strong> test<strong>()</strong>func**() {</p>
<p>x := 100</p>
<p>fmt.Printf(&quot;x (%p) = %d\n&quot;, &amp;x, x)</p>
<p>return func() {</p>
<p>fmt.Printf(&quot;x (%p) = %d\n&quot;, &amp;x, x)</p>
<p>}</p>
<p>}</p>
<p><strong>func**</strong> main**() {</p>
<p>f := test()</p>
<p>f()</p>
<p>}</p>
<p>输出:</p>
<p>x (0xc42007c008) = 100</p>
<p>x (0xc42007c008) = 100</p>
<p>在汇编层 ，test 实际返回的是 FuncVal 对象，其中包含了匿名函数地址、闭包对象指针。当调 匿名函数时，只需以某个寄存器传递该对象即可。</p>
<p>FuncVal { func_address, closure_var_pointer … }</p>
<p>外部引用函数参数局部变量</p>
<p>package main</p>
<p>import &quot;fmt&quot;</p>
<p><em>//</em> _外部引用函数参数局部变量_func <strong>add</strong> ( <strong>base**</strong> int<strong>)</strong>func<strong>(</strong>int<strong>)</strong>int**{</p>
<p><strong>return</strong> func(i <strong>int</strong> ) <strong>int</strong> {</p>
<p><strong>base</strong> += i</p>
<p><strong>return**</strong> base**</p>
<p>}</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>tmp1 := <strong>add</strong> (10)</p>
<p>fmt.Println(tmp1(1), tmp1(2))</p>
<p><em>//</em> <em>此时 <strong>tmp1</strong> 和 <strong>tmp2</strong> 不是一个实体了</em></p>
<p>tmp2 := <strong>add</strong> (100)</p>
<p>fmt.Println(tmp2(1), tmp2(2))</p>
<p>}</p>
<p>返回2个闭包</p>
<p>package main</p>
<p>import &quot;fmt&quot;</p>
<p><em>//</em> <em>返回 <em>_2</em></em> 个函数类型的返回值_func <strong>test01</strong> ( <strong>base**</strong> int<strong>) (func(</strong>int<strong>)</strong>int <strong>,</strong> func<strong>(</strong>int<strong>)</strong>int**) {</p>
<p><em>//</em> <em>定义 <strong>2</strong> 个函数，并返回</em></p>
<p><em>//</em> <em>相加</em></p>
<p><strong>add</strong> := func(i <strong>int</strong> ) <strong>int</strong> {</p>
<p><strong>base</strong> += i</p>
<p><strong>return**</strong> base**</p>
<p>}</p>
<p><em>//</em> <em>相减</em></p>
<p>sub := func(i <strong>int</strong> ) <strong>int</strong> {</p>
<p><strong>base</strong> -= i</p>
<p><strong>return**</strong> base**</p>
<p>}</p>
<p><em>//</em> <em>返回</em></p>
<p><strong>return**</strong> add**, sub</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>f1, f2 := test01(10)</p>
<p><em>// base__一直是没有消</em></p>
<p>fmt.Println(f1(1), f2(2))</p>
<p><em>//</em> <em>此时 <strong>base</strong> 是__9</em></p>
<p>fmt.Println(f1(3), f2(4))</p>
<p>}</p>
<h3 id="Go-语言递归函数"><a href="#Go-语言递归函数" class="headerlink" title="Go  语言递归函数"></a><strong>Go</strong>  <strong>语言递归函数</strong></h3><p>递归，就是在运行的过程中调用自己。<br>一个函数调用自己，就叫做递归函数。</p>
<p>构成递归需具备的条件：</p>
<p>1.子问题须与原始问题为同样的事，且更为简单。</p>
<p>2.不能无限制地调用本身，须有个出口，化简为非递归状况处理。</p>
<h4 id="数字阶乘"><a href="#数字阶乘" class="headerlink" title="数字阶乘"></a><strong>数字阶乘</strong></h4><p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且0的阶乘为1。自然数n的阶乘写作n!。1808年，基斯顿·卡曼引进这个表示法。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>func <strong>factorial</strong> (i <strong>int</strong> ) <strong>int</strong> {</p>
<p><strong>if</strong> i &amp;lt;= 1 {</p>
<p><strong>return</strong> 1</p>
<p>}</p>
<p><strong>return</strong> i * factorial(i-1)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>var i <strong>int</strong> = 7</p>
<p>fmt.Printf(&quot;Factorial of %d is %d\n&quot;, i, factorial(i))</p>
<p>}</p>
<p>输出结果：</p>
<p>Factorial <strong>of</strong> 7 <strong>is</strong> 5040</p>
<h3 id="斐波那契数列-Fibonacci"><a href="#斐波那契数列-Fibonacci" class="headerlink" title="斐波那契数列** (Fibonacci)**"></a><strong>斐波那契数列**</strong> (Fibonacci)**</h3><p>这个数列从第3项开始，每一项都等于前两项之和。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>func <strong>fibonaci</strong> (i <strong>int</strong> ) <strong>int</strong> {</p>
<p><strong>if</strong> i == 0 {</p>
<p><strong>return</strong> 0</p>
<p>}</p>
<p><strong>if</strong> i == 1 {</p>
<p><strong>return</strong> 1</p>
<p>}</p>
<p><strong>return</strong> fibonaci(i-1) + fibonaci(i-2)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>var i <strong>int</strong></p>
<p><strong>for</strong> i = 0; i &amp;lt; 10; i++ {</p>
<p>fmt.Printf(&quot;%d\n&quot;, fibonaci(i))</p>
<p>}</p>
<p>}</p>
<p>输出结果：</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>5</p>
<p>8</p>
<p>13</p>
<p>21</p>
<p>34</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试</title>
    <url>/2021/02/19/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>不写测试的开发不是好程序员。我个人非常崇尚TDD（Test Driven Development）的，然而可惜的是国内的程序员都不太关注测试这一部分。 这篇文章主要介绍下在Go语言中如何做单元测试和基准测试。</p>
<h2 id="go-test-工具"><a href="#go-test-工具" class="headerlink" title="go test** 工具**"></a><strong>go test**</strong> 工具**</h2><p>Go语言中的测试依赖go test命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。</p>
<p>go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以_test.go为后缀名的源代码文件都是go test测试的一部分，不会被go build编译到最终的可执行文件中。</p>
<p>在*_test.go文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>测试函数</td>
<td>函数名前缀为Test</td>
<td>测试程序的一些逻辑行为是否正确</td>
</tr>
<tr>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>基准函数</td>
<td>函数名前缀为Benchmark</td>
<td>测试函数的性能</td>
</tr>
<tr>
<td>示例函数</td>
<td>函数名前缀为Example</td>
<td>为文档提供示例文档</td>
</tr>
</tbody></table>
<p>go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p>
<p>Golang单元测试对文件名和方法名，参数都有很严格的要求。</p>
<p>1、文件名必须以 <strong>xx_test</strong>.go命名</p>
<p>2、方法必须是 <strong>Test</strong> [^a-z]开头</p>
<p>3、方法参数必须 <strong>t</strong> \ <strong>*testing</strong>.T</p>
<p>4、使用 <strong>go**</strong> test**执行单元测试</p>
<p>go test的参数解读：</p>
<p>go test是go语言自带的测试工具，其中包含的是两类，单元测试和性能测试</p>
<p>通过go help test可以看到go test的使用说明：</p>
<p>格式形如：<br> go test [-c] [-i] [build flags] [packages] [flags for test binary]</p>
<p>参数解读：</p>
<p>-c : 编译go test成为可执行的二进制文件，但是不运行测试。</p>
<p>-i : 安装测试包依赖的package，但是不运行测试。</p>
<p>关于build flags，调用go help build，这些是编译运行过程中需要使用到的参数，一般设置为空</p>
<p>关于packages，调用go help packages，这些是关于包的管理，一般设置为空</p>
<p>关于flags for test binary，调用go help testflag，这些是go test过程中经常使用到的参数</p>
<p>-test.v : 是否输出全部的单元测试用例（不管成功或者失败），默认没有加上，所以只输出失败的单元测试用例。</p>
<p>-test.run pattern: 只跑哪些单元测试用例</p>
<p>-test.bench patten: 只跑那些性能测试用例</p>
<p>-test.benchmem : 是否在性能测试的时候输出内存情况</p>
<p>-test.benchtime t : 性能测试运行的时间，默认是1s</p>
<p>-test.cpuprofile cpu.out : 是否输出cpu性能分析文件</p>
<p>-test.memprofile mem.out : 是否输出内存性能分析文件</p>
<p>-test.blockprofile block.out : 是否输出内部goroutine阻塞的性能分析文件</p>
<p>-test.memprofilerate n : 内存性能分析的时候有一个分配了多少的时候才打点记录的问题。这个参数就是设置打点的内存分配间隔，也就是profile中一个sample代表的内存大小。默认是设置为512 * 1024的。如果你将它设置为1，则每分配一个内存块就会在profile中有个打点，那么生成的profile的sample就会非常多。如果你设置为0，那就是不做打点了。</p>
<p>你可以通过设置memprofilerate=1和GOGC=off来关闭内存回收，并且对每个内存块的分配进行观察。</p>
<p>-test.blockprofilerate n: 基本同上，控制的是goroutine阻塞时候打点的纳秒数。默认不设置就相当于-test.blockprofilerate=1，每一纳秒都打点记录一下</p>
<p>-test.parallel n : 性能测试的程序并行cpu数，默认等于GOMAXPROCS。</p>
<p>-test.timeout t : 如果测试用例运行时间超过t，则抛出panic</p>
<p>-test.cpu 1,2,4 : 程序运行在哪些CPU上面，使用二进制的1所在位代表，和nginx的nginx_worker_cpu_affinity是一个道理</p>
<p>-test.short : 将那些运行时间较长的测试用例运行时间缩短</p>
<p>目录结构：</p>
<p>test</p>
<p>|</p>
<p>—— calc.go</p>
<p>|</p>
<p>—— calc_test.go</p>
<h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a><strong>测试函数</strong></h2><h3 id="测试函数的格式"><a href="#测试函数的格式" class="headerlink" title="测试函数的格式"></a><strong>测试函数的格式</strong></h3><p>每个测试函数必须导入testing包，测试函数的基本格式（签名）如下：</p>
<p>func <strong>TestName</strong> (t *testing.T){</p>
<p><em>// …</em></p>
<p>}</p>
<p>测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头，举几个例子：\</p>
<p>func <strong>TestAdd</strong> (t *testing.T){ … }func <strong>TestSum</strong> (t *testing.T){ … }func <strong>TestLog</strong> (t *testing.T){ … }</p>
<p>其中参数t用于报告测试失败和附加的日志信息。 testing.T的拥有的方法如下：</p>
<p>func (c *T) Error(args … <strong>interface</strong> {})</p>
<p>func (c *T) Errorf(format <strong>string</strong> , args … <strong>interface</strong> {})</p>
<p>func (c *T) Fail()</p>
<p>func (c *T) FailNow()</p>
<p>func (c *T) Failed() <strong>bool**</strong> func<strong>(c *T)</strong>Fatal<strong>(args …</strong>interface<strong>{})</strong>func<strong>(c *T)</strong>Fatalf<strong>(format</strong>string <strong>, args …</strong> interface<strong>{})</strong>func<strong>(c *T)</strong>Log<strong>(args …</strong>interface<strong>{})</strong>func<strong>(c *T)</strong>Logf<strong>(format</strong>string <strong>, args …</strong> interface<strong>{})</strong>func<strong>(c *T)</strong>Name<strong>()</strong>string <strong>**func</strong> (t *T) <strong>Parallel</strong> () <strong>func</strong> (t *T) <strong>Run</strong> (name <strong>string</strong> , f func(t *T)) <strong>bool**</strong> func<strong>(c *T)</strong>Skip<strong>(args …</strong>interface<strong>{})</strong>func<strong>(c *T)</strong>SkipNow<strong>()</strong>func<strong>(c *T)</strong>Skipf<strong>(format</strong>string <strong>, args …</strong> interface<strong>{})</strong>func<strong>(c *T)</strong>Skipped<strong>()</strong>bool**</p>
<h3 id="测试函数示例"><a href="#测试函数示例" class="headerlink" title="测试函数示例"></a><strong>测试函数示例</strong></h3><p>就像细胞是构成我们身体的基本单位，一个软件程序也是由很多单元组件构成的。单元组件可以是函数、结构体、方法和最终用户可能依赖的任意东西。总之我们需要确保这些组件是能够正常运行的。单元测试是一些利用各种方法测试单元组件的程序，它会将结果与预期输出进行比较。</p>
<p>接下来，我们定义一个split的包，包中定义了一个Split函数，具体实现如下：</p>
<p><em>// split/split.go</em></p>
<p>package split</p>
<p><strong>import</strong>&quot;strings&quot;</p>
<p><em>// split package with a single split function.</em></p>
<p>_// Split slices s into all substrings separated by sep and// returns a slice of the substrings between those separators._func <strong>Split</strong> (s, sep string) (result []string) {</p>
<p>i := strings.Index(s, sep)</p>
<p><strong>for</strong> i &amp;gt; -1 {</p>
<p>result = append(result, s[:i])</p>
<p>s = s[i+1:]</p>
<p>i = strings.Index(s, sep)</p>
<p>}</p>
<p>result = append(result, s)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>在当前目录下，我们创建一个split_test.go的测试文件，并定义一个测试函数如下：</p>
<p><em>// split/split_test.go</em></p>
<p>package split</p>
<p><strong>import</strong> (</p>
<p>&quot;reflect&quot;</p>
<p>&quot;testing&quot;</p>
<p>)</p>
<p>func <strong>TestSplit</strong> (t *testing.T) { <em>//</em> <em>测试函数名必须以 <strong>Test</strong> 开头，必须接收一个 <strong>*testing.T</strong> 类型参数</em></p>
<p>got := Split(&quot;a:b:c&quot;, &quot;:&quot;) <em>//</em> <em>程序输出的结果</em></p>
<p>want := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;} <em>//</em> <em>期望的结果</em></p>
<p><strong>if</strong>!reflect.DeepEqual(want, got) { <em>//</em> <em>因为 <strong>slice</strong> 不能比较直接，借助反射包中的方法比较</em></p>
<p>t.Errorf(&quot;excepted:%v, got:%v&quot;, want, got) <em>//</em> <em>测试失败输出错误提示</em></p>
<p>}</p>
<p>}</p>
<p>此时split这个包中的文件如下：</p>
<p><strong>split</strong> $ ls -l</p>
<p>total 16</p>
<p>-rw-r–r– 1 pprof staff 40842915:50 <strong>split</strong>.go</p>
<p>-rw-r–r– 1 pprof staff 46642916:04 split_test.go</p>
<p>在split包路径下，执行go test命令，可以看到输出结果如下：</p>
<p><strong>split</strong> $ go test</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 0.005 <strong>s</strong></p>
<p>一个测试用例有点单薄，我们再编写一个测试使用多个字符切割字符串的例子，在split_test.go中添加如下测试函数：</p>
<p>func <strong>TestMoreSplit</strong> (t *testing.T) {</p>
<p>got := Split(&quot;abcd&quot;, &quot;bc&quot;)</p>
<p>want := []string{&quot;a&quot;, &quot;d&quot;}</p>
<p><strong>if</strong>!reflect.DeepEqual(want, got) {</p>
<p>t.Errorf(&quot;excepted:%v, got:%v&quot;, want, got)</p>
<p>}</p>
<p>}</p>
<p>再次运行go test命令，输出结果如下：</p>
<p>split $ go test</p>
<p>— FAIL: TestMultiSplit (0.00s)</p>
<p>split_test.go:20: excepted:[a d], got:[a cd]</p>
<p>FAIL</p>
<p>exit status 1</p>
<p>FAIL github.com/pprof/studygo/code_demo/test_demo/split 0.006s</p>
<p>这一次，我们的测试失败了。我们可以为go test命令添加-v参数，查看测试函数名称和运行时间：</p>
<p>split $ go test -v</p>
<p>=== RUN TestSplit</p>
<p>— PASS: TestSplit (0.00s)</p>
<p>=== RUN TestMoreSplit</p>
<p>— FAIL: TestMoreSplit (0.00s)</p>
<p>split_test.go:21: excepted:[a d], got:[a cd]</p>
<p>FAIL</p>
<p>exit status 1</p>
<p>FAIL github.com/pprof/studygo/code_demo/test_demo/split 0.005s</p>
<p>这一次我们能清楚的看到是TestMoreSplit这个测试没有成功。 还可以在go test命令后添加-run参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被go test命令执行。</p>
<p>split $ go test -v -run=&quot;More&quot;</p>
<p>=== RUN TestMoreSplit</p>
<p>— FAIL: TestMoreSplit (0.00s)</p>
<p>split_test.go:21: excepted:[a d], got:[a cd]</p>
<p>FAIL</p>
<p>exit status 1</p>
<p>FAIL github.com/pprof/studygo/code_demo/test_demo/split 0.006s</p>
<p>现在我们回过头来解决我们程序中的问题。很显然我们最初的split函数并没有考虑到sep为多个字符的情况，我们来修复下这个Bug：</p>
<p>package split</p>
<p><strong>import</strong>&quot;strings&quot;</p>
<p><em>// split package with a single split function.</em></p>
<p>_// Split slices s into all substrings separated by sep and// returns a slice of the substrings between those separators._func <strong>Split</strong> (s, sep string) (result []string) {</p>
<p>i := strings.Index(s, sep)</p>
<p><strong>for</strong> i &amp;gt; -1 {</p>
<p>result = append(result, s[:i])</p>
<p>s = s[i+len(sep):] <em>//</em> <em>这里使用<strong>len(sep)</strong>获取 <strong>sep</strong> 的长度</em></p>
<p>i = strings.Index(s, sep)</p>
<p>}</p>
<p>result = append(result, s)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>这一次我们再来测试一下，我们的程序。注意，当我们修改了我们的代码之后不要仅仅执行那些失败的测试函数，我们应该完整的运行所有的测试，保证不会因为修改代码而引入了新的问题。</p>
<p>split $ go test -v</p>
<p><em>=== RUN TestSplit</em></p>
<p>— PASS: TestSplit (0.00s)</p>
<p><em>=== RUN TestMoreSplit</em></p>
<p>— PASS: TestMoreSplit (0.00s)</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/split 0.006s</p>
<p>这一次我们的测试都通过了</p>
<h2 id="测试组"><a href="#测试组" class="headerlink" title="测试组"></a><strong>测试组</strong></h2><p>我们现在还想要测试一下split函数对中文字符串的支持，这个时候我们可以再编写一个TestChineseSplit测试函数，但是我们也可以使用如下更友好的一种方式来添加更多的测试用例。</p>
<p>func <strong>TestSplit</strong> (t *testing.T) {</p>
<p><em>//</em> <em>定义一个测试用例类型</em></p>
<p>type test <strong>struct</strong> {</p>
<p>input string</p>
<p>sep string</p>
<p>want []string</p>
<p>}</p>
<p><em>//</em> <em>定义一个存储测试用例的切片</em></p>
<p>tests := []test{</p>
<p>{input: &quot;a:b:c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},</p>
<p>{input: &quot;a:b:c&quot;, sep: &quot;,&quot;, want: []string{&quot;a:b:c&quot;}},</p>
<p>{input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},</p>
<p>{input: &quot;枯藤老树昏鸦&quot;, sep: &quot;老&quot;, want: []string{&quot;枯藤&quot;, &quot;树昏鸦&quot;}},</p>
<p>}</p>
<p><em>//</em> <em>遍历切片，逐一执行测试用例</em></p>
<p><strong>for</strong> _, tc := range tests {</p>
<p>got := Split(tc.input, tc.sep)</p>
<p><strong>if</strong>!reflect.DeepEqual(got, tc.want) {</p>
<p>t.Errorf(&quot;excepted:%v, got:%v&quot;, tc.want, got)</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>我们通过上面的代码把多个测试用例合到一起，再次执行go test命令。</p>
<p><strong>split</strong> $ go test -v</p>
<p>=== RUN TestSplit</p>
<p>— FAIL: TestSplit (0.00 <strong>s</strong> )</p>
<p>split_test.go:42: excepted:[枯藤 树昏鸦], got:[枯藤 树昏鸦]</p>
<p>FAIL</p>
<p><strong>exit</strong> status 1</p>
<p>FAIL github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 0.006 <strong>s</strong></p>
<p>我们的测试出现了问题，仔细看打印的测试失败提示信息：excepted:[枯藤 树昏鸦], got:[枯藤 树昏鸦]，你会发现[枯藤 树昏鸦]中有个不明显的空串，这种情况下十分推荐使用%#v的格式化方式。</p>
<p>我们修改下测试用例的格式化输出错误提示部分：</p>
<p>func TestSplit(t *testing.T) {</p>
<p>…</p>
<p><strong>for</strong> _, tc := range tests {</p>
<p>got := Split(tc.input, tc.sep)</p>
<p><strong>if</strong>!reflect.DeepEqual(got, tc.want) {</p>
<p>t.Errorf(&quot;excepted:%#v, got:%#v&quot;, tc.want, got)</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>此时运行go test命令后就能看到比较明显的提示信息了：</p>
<p>split $ go test -v</p>
<p>=== RUN TestSplit</p>
<p>— FAIL: TestSplit (0.00s)</p>
<p>split_test.go:42: excepted:[]string{&quot;枯藤&quot;, &quot;树昏鸦&quot;}, got:[]string{&quot;&quot;, &quot;枯藤&quot;, &quot;树昏鸦&quot;}</p>
<p>FAIL</p>
<p>exit status 1</p>
<p>FAIL github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s</p>
<h2 id="子测试"><a href="#子测试" class="headerlink" title="子测试"></a><strong>子测试</strong></h2><p>看起来都挺不错的，但是如果测试用例比较多的时候，我们是没办法一眼看出来具体是哪个测试用例失败了。我们可能会想到下面的解决办法</p>
<p>func <strong>TestSplit</strong> (t *testing.T) {</p>
<p>type test <strong>struct</strong> { <em>//</em> <em>定义 <strong>test</strong> 结构体</em></p>
<p>input string</p>
<p>sep string</p>
<p>want []string</p>
<p>}</p>
<p>tests := map[string]test{ <em>//</em> <em>测试用例使用 <strong>map</strong> 存储</em></p>
<p>&quot;simple&quot;: {input: &quot;a:b:c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},</p>
<p>&quot;wrong sep&quot;: {input: &quot;a:b:c&quot;, sep: &quot;,&quot;, want: []string{&quot;a:b:c&quot;}},</p>
<p>&quot;more sep&quot;: {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},</p>
<p>&quot;leading sep&quot;: {input: &quot;枯藤老树昏鸦&quot;, sep: &quot;老&quot;, want: []string{&quot;枯藤&quot;, &quot;树昏鸦&quot;}},</p>
<p>}</p>
<p><strong>for</strong> name, tc := range tests {</p>
<p>got := Split(tc.input, tc.sep)</p>
<p><strong>if</strong>!reflect.DeepEqual(got, tc.want) {</p>
<p>t.Errorf(&quot;name:%s excepted:%#v, got:%#v&quot;, name, tc.want, got) <em>//</em> <em>将测试用例的 <strong>name</strong> 格式化输出</em></p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>上面的做法是能够解决问题的。同时Go1.7+中新增了子测试，我们可以按照如下方式使用t.Run执行子测试：</p>
<p>func <strong>TestSplit</strong> (t *testing.T) {</p>
<p>type test <strong>struct</strong> { <em>//</em> <em>定义 <strong>test</strong> 结构体</em></p>
<p>input string</p>
<p>sep string</p>
<p>want []string</p>
<p>}</p>
<p>tests := map[string]test{ <em>//</em> <em>测试用例使用 <strong>map</strong> 存储</em></p>
<p>&quot;simple&quot;: {input: &quot;a:b:c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},</p>
<p>&quot;wrong sep&quot;: {input: &quot;a:b:c&quot;, sep: &quot;,&quot;, want: []string{&quot;a:b:c&quot;}},</p>
<p>&quot;more sep&quot;: {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},</p>
<p>&quot;leading sep&quot;: {input: &quot;枯藤老树昏鸦&quot;, sep: &quot;老&quot;, want: []string{&quot;枯藤&quot;, &quot;树昏鸦&quot;}},</p>
<p>}</p>
<p><strong>for</strong> name, tc := range tests {</p>
<p>t.Run(name, func(t *testing.T) { <em>//</em> <em>使用<strong>t.Run()</strong>执行子测试</em></p>
<p>got := Split(tc.input, tc.sep)</p>
<p><strong>if</strong>!reflect.DeepEqual(got, tc.want) {</p>
<p>t.Errorf(&quot;excepted:%#v, got:%#v&quot;, tc.want, got)</p>
<p>}</p>
<p>})</p>
<p>}</p>
<p>}</p>
<p>此时我们再执行go test命令就能够看到更清晰的输出内容了：</p>
<p>split $ go test -v</p>
<p>=== RUN TestSplit</p>
<p>=== RUN TestSplit/leading_sep</p>
<p>=== RUN TestSplit/simple</p>
<p>=== RUN TestSplit/wrong_sep</p>
<p>=== RUN TestSplit/more_sep</p>
<p>— FAIL: TestSplit (0.00s)</p>
<p>— FAIL: TestSplit/leading_sep (0.00s)</p>
<p>split_test.go:83: excepted:[]string{&quot;枯藤&quot;, &quot;树昏鸦&quot;}, got:[]string{&quot;&quot;, &quot;枯藤&quot;, &quot;树昏鸦&quot;}</p>
<p>— PASS: TestSplit/simple (0.00s)</p>
<p>— PASS: TestSplit/wrong_sep (0.00s)</p>
<p>— PASS: TestSplit/more_sep (0.00s)</p>
<p>FAIL</p>
<p>exit status 1</p>
<p>FAIL github.com/pprof/studygo/code_demo/test_demo/split 0.006s</p>
<p>这个时候我们要把测试用例中的错误修改回来：</p>
<p>func <strong>TestSplit</strong> (t *testing.T) {</p>
<p>…</p>
<p>tests := map[string]test{ <em>//</em> <em>测试用例使用 <strong>map</strong> 存储</em></p>
<p>&quot;simple&quot;: {input: &quot;a:b:c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},</p>
<p>&quot;wrong sep&quot;: {input: &quot;a:b:c&quot;, sep: &quot;,&quot;, want: []string{&quot;a:b:c&quot;}},</p>
<p>&quot;more sep&quot;: {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},</p>
<p>&quot;leading sep&quot;: {input: &quot;枯藤老树昏鸦&quot;, sep: &quot;老&quot;, want: []string{&quot;&quot;, &quot;枯藤&quot;, &quot;树昏鸦&quot;}},</p>
<p>}</p>
<p>…</p>
<p>}</p>
<p>我们都知道可以通过-run=RegExp来指定运行的测试用例，还可以通过/来指定要运行的子测试用例，例如：go test -v -run=Split/simple只会运行simple对应的子测试用例。</p>
<h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a><strong>测试覆盖率</strong></h2><p>测试覆盖率是你的代码被测试套件覆盖的百分比。通常我们使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。</p>
<p>Go提供内置功能来检查你的代码覆盖率。我们可以使用go test -cover来查看测试覆盖率。例如：</p>
<p><strong>split</strong> $ go test -cover</p>
<p>PASS</p>
<p>coverage: 100.0% of statements</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 0.005 <strong>s</strong></p>
<p>从上面的结果可以看到我们的测试用例覆盖了100%的代码。</p>
<p>Go还提供了一个额外的-coverprofile参数，用来将覆盖率相关的记录信息输出到一个文件。例如：</p>
<p><strong>split</strong> $ go test -cover -coverprofile=c.out</p>
<p>PASS</p>
<p>coverage: 100.0% of statements</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 0.005 <strong>s</strong></p>
<p>上面的命令会将覆盖率相关的信息输出到当前文件夹下面的c.out文件中，然后我们执行go tool cover -html=c.out，使用cover工具来处理生成的记录信息，该命令会打开本地的浏览器窗口生成一个HTML报告。</p>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a><strong>基准测试</strong></h2><h3 id="基准测试函数格式"><a href="#基准测试函数格式" class="headerlink" title="基准测试函数格式"></a><strong>基准测试函数格式</strong></h3><p>基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：</p>
<p>func <strong>BenchmarkName</strong> (b *testing.B){</p>
<p><em>// …</em></p>
<p>}</p>
<p>基准测试以Benchmark为前缀，需要一个*testing.B类型的参数b，基准测试必须要执行b.N次，这样的测试才有对照性，b.N的值是系统根据实际情况去调整的，从而保证测试的稳定性。 testing.B拥有的方法如下：</p>
<p>func (c *B) Error(args … <strong>interface</strong> {})</p>
<p>func (c *B) Errorf(format <strong>string</strong> , args … <strong>interface</strong> {})</p>
<p>func (c *B) Fail()</p>
<p>func (c *B) FailNow()</p>
<p>func (c *B) Failed() <strong>bool**</strong> func<strong>(c *B)</strong>Fatal<strong>(args …</strong>interface<strong>{})</strong>func<strong>(c *B)</strong>Fatalf<strong>(format</strong>string <strong>, args …</strong> interface<strong>{})</strong>func<strong>(c *B)</strong>Log<strong>(args …</strong>interface<strong>{})</strong>func<strong>(c *B)</strong>Logf<strong>(format</strong>string <strong>, args …</strong> interface<strong>{})</strong>func<strong>(c *B)</strong>Name<strong>()</strong>string <strong>**func</strong> (b *B) <strong>ReportAllocs</strong> () <strong>func</strong> (b *B) <strong>ResetTimer</strong> () <strong>func</strong> (b *B) <strong>Run</strong> (name <strong>string</strong> , f func(b *B)) <strong>bool**</strong> func<strong>(b *B)</strong>RunParallel<strong>(body func(*PB))</strong>func<strong>(b *B)</strong>SetBytes<strong>(n int64)</strong>func<strong>(b *B)</strong>SetParallelism<strong>(p</strong>int<strong>)</strong>func<strong>(c *B)</strong>Skip<strong>(args …</strong>interface<strong>{})</strong>func<strong>(c *B)</strong>SkipNow<strong>()</strong>func<strong>(c *B)</strong>Skipf<strong>(format</strong>string <strong>, args …</strong> interface<strong>{})</strong>func<strong>(c *B)</strong>Skipped<strong>()</strong>bool <strong>**func</strong> (b *B) <strong>StartTimer</strong> () <strong>func</strong> (b *B) <strong>StopTimer</strong> ()</p>
<h3 id="基准测试示例"><a href="#基准测试示例" class="headerlink" title="基准测试示例"></a><strong>基准测试示例</strong></h3><p>我们为split包中的Split函数编写基准测试如下：</p>
<p>func <strong>BenchmarkSplit</strong> (b *testing.B) {</p>
<p><strong>for</strong> i := 0; i &amp;lt; b.N; i++ {</p>
<p>Split(&quot;枯藤老树昏鸦&quot;, &quot;老&quot;)</p>
<p>}</p>
<p>}</p>
<p>基准测试并不会默认执行，需要增加-bench参数，所以我们通过执行go test -bench=Split命令执行基准测试，输出结果如下：</p>
<p><strong>split</strong> $ go test -bench=Split</p>
<p>goos: darwin</p>
<p>goarch: amd64</p>
<p>pkg: github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong></p>
<p>BenchmarkSplit-810000000203 ns/op</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 2.255 <strong>s</strong></p>
<p>其中BenchmarkSplit-8表示对Split函数进行基准测试，数字8表示GOMAXPROCS的值，这个对于并发基准测试很重要。10000000和203ns/op表示每次调用Split函数耗时203ns，这个结果是10000000次调用的平均值。</p>
<p>我们还可以为基准测试添加-benchmem参数，来获得内存分配的统计数据。</p>
<p><strong>split</strong> $ go test -bench=Split -benchmem</p>
<p>goos: darwin</p>
<p>goarch: amd64</p>
<p>pkg: github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong></p>
<p>BenchmarkSplit-810000000215 ns/op 112 B/op 3 allocs/op</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 2.394 <strong>s</strong></p>
<p>其中，112 B/op表示每次操作内存分配了112字节，3 allocs/op则表示每次操作进行了3次内存分配。 我们将我们的Split函数优化如下：</p>
<p>func <strong>Split</strong> (s, sep string) (result []string) {</p>
<p>result = make([]string, 0, strings.Count(s, sep)+1)</p>
<p>i := strings.Index(s, sep)</p>
<p><strong>for</strong> i &amp;gt; -1 {</p>
<p>result = append(result, s[:i])</p>
<p>s = s[i+len(sep):] <em>//</em> <em>这里使用<strong>len(sep)</strong>获取 <strong>sep</strong> 的长度</em></p>
<p>i = strings.Index(s, sep)</p>
<p>}</p>
<p>result = append(result, s)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>这一次我们提前使用make函数将result初始化为一个容量足够大的切片，而不再像之前一样通过调用append函数来追加。我们来看一下这个改进会带来多大的性能提升：</p>
<p><strong>split</strong> $ go test -bench=Split -benchmem</p>
<p>goos: darwin</p>
<p>goarch: amd64</p>
<p>pkg: github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong></p>
<p>BenchmarkSplit-810000000127 ns/op 48 B/op 1 allocs/op</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 1.423 <strong>s</strong></p>
<p>这个使用make函数提前分配内存的改动，减少了2/3的内存分配次数，并且减少了一半的内存分配。</p>
<h3 id="性能比较函数"><a href="#性能比较函数" class="headerlink" title="性能比较函数"></a><strong>性能比较函数</strong></h3><p>上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？我们通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。</p>
<p>性能比较函数通常是一个带有参数的函数，被多个不同的Benchmark函数传入不同的值来调用。举个例子如下：</p>
<p>func <strong>benchmark</strong> (b *testing.B, size <strong>int</strong> ){<em>/* … */</em>}func <strong>Benchmark10</strong> (b *testing.B){ benchmark(b, 10) }func <strong>Benchmark100</strong> (b *testing.B){ benchmark(b, 100) }func <strong>Benchmark1000</strong> (b *testing.B){ benchmark(b, 1000) }</p>
<p>例如我们编写了一个计算斐波那契数列的函数如下：</p>
<p><em>// fib.go</em></p>
<p><em>// Fib</em> <em>是一个计算第 <em>_n</em></em> 个斐波那契数的函数_func <strong>Fib</strong> (n <strong>int</strong> ) <strong>int</strong> {</p>
<p><strong>if</strong> n &amp;lt; 2 {</p>
<p><strong>return</strong> n</p>
<p>}</p>
<p><strong>return</strong> Fib(n-1) + Fib(n-2)</p>
<p>}</p>
<p>我们编写的性能比较函数如下：</p>
<p><em>// fib_test.go</em></p>
<p>func <strong>benchmarkFib</strong> (b *testing.B, n <strong>int</strong> ) {</p>
<p><strong>for</strong> i := 0; i &amp;lt; b.N; i++ {</p>
<p>Fib(n)</p>
<p>}</p>
<p>}</p>
<p>func <strong>BenchmarkFib1</strong> (b *testing.B) { benchmarkFib(b, 1) }func <strong>BenchmarkFib2</strong> (b *testing.B) { benchmarkFib(b, 2) }func <strong>BenchmarkFib3</strong> (b *testing.B) { benchmarkFib(b, 3) }func <strong>BenchmarkFib10</strong> (b *testing.B) { benchmarkFib(b, 10) }func <strong>BenchmarkFib20</strong> (b *testing.B) { benchmarkFib(b, 20) }func <strong>BenchmarkFib40</strong> (b *testing.B) { benchmarkFib(b, 40) }</p>
<p>运行基准测试：</p>
<p>split $ go test -bench=.</p>
<p>goos: darwin</p>
<p>goarch: amd64</p>
<p>pkg: github.com/pprof/studygo/code_demo/test_demo/fib</p>
<p>BenchmarkFib1-8 1000000000 2.03 ns/op</p>
<p>BenchmarkFib2-8 300000000 5.39 ns/op</p>
<p>BenchmarkFib3-8 200000000 9.71 ns/op</p>
<p>BenchmarkFib10-8 5000000 325 ns/op</p>
<p>BenchmarkFib20-8 30000 42460 ns/op</p>
<p>BenchmarkFib40-8 2 638524980 ns/op</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/fib 12.944s</p>
<p>这里需要注意的是，默认情况下，每个基准测试至少运行1秒。如果在Benchmark函数返回时没有到1秒，则b.N的值会按1,2,5,10,20,50，…增加，并且函数再次运行。</p>
<p>最终的BenchmarkFib40只运行了两次，每次运行的平均值只有不到一秒。像这种情况下我们应该可以使用-benchtime标志增加最小基准时间，以产生更准确的结果。例如：</p>
<p>split $ go test -bench=Fib40 -benchtime=20s</p>
<p>goos: darwin</p>
<p>goarch: amd64</p>
<p>pkg: github.com/pprof/studygo/code_demo/test_demo/fib</p>
<p>BenchmarkFib40-8 50 663205114 ns/op</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/fib 33.849s</p>
<p>这一次BenchmarkFib40函数运行了50次，结果就会更准确一些了。</p>
<p>使用性能比较函数做测试的时候一个容易犯的错误就是把b.N作为输入的大小，例如以下两个例子都是错误的示范：</p>
<p><em>//</em> _错误示范__1_func <strong>BenchmarkFibWrong</strong> (b *testing.B) {</p>
<p><strong>for</strong> n := 0; n &amp;lt; b.N; n++ {</p>
<p>Fib(n)</p>
<p>}</p>
<p>}</p>
<p><em>//</em> _错误示范__2_func <strong>BenchmarkFibWrong2</strong> (b *testing.B) {</p>
<p>Fib(b.N)</p>
<p>}</p>
<h3 id="重置时间"><a href="#重置时间" class="headerlink" title="重置时间"></a><strong>重置时间</strong></h3><p>b.ResetTimer之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。例如：</p>
<p>func <strong>BenchmarkSplit</strong> (b *testing.B) {</p>
<p>time.Sleep(5 * time.Second) <em>//</em> <em>假设需要做一些耗时的无关操作</em></p>
<p>b.ResetTimer() <em>//</em> <em>重置计时器</em></p>
<p><strong>for</strong> i := 0; i &amp;lt; b.N; i++ {</p>
<p>Split(&quot;枯藤老树昏鸦&quot;, &quot;老&quot;)</p>
<p>}</p>
<p>}</p>
<h3 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a><strong>并行测试</strong></h3><p>func (b _B) RunParallel(body func(_PB))会以并行的方式执行给定的基准测试。</p>
<p>RunParallel会创建出多个goroutine，并将b.N分配给这些goroutine执行， 其中goroutine数量的默认值为GOMAXPROCS。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在RunParallel之前调用SetParallelism 。RunParallel通常会与-cpu标志一同使用。</p>
<p>func <strong>BenchmarkSplitParallel</strong> (b *testing.B) {</p>
<p><em>// b.SetParallelism(1) //</em> <em>设置使用的 <strong>CPU</strong> 数</em></p>
<p>b.RunParallel(func(pb *testing.PB) {</p>
<p><strong>for</strong> pb.Next() {</p>
<p>Split(&quot;枯藤老树昏鸦&quot;, &quot;老&quot;)</p>
<p>}</p>
<p>})</p>
<p>}</p>
<p>执行一下基准测试：</p>
<p><strong>split</strong> $ go test -bench=.</p>
<p>goos: darwin</p>
<p>goarch: amd64</p>
<p>pkg: github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong></p>
<p>BenchmarkSplit-810000000131 ns/op</p>
<p>BenchmarkSplitParallel-85000000036.1 ns/op</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 3.308 <strong>s</strong></p>
<p>还可以通过在测试命令后添加-cpu参数如go test -bench=. -cpu 1来指定使用的CPU数量。</p>
<h2 id="Setup-与-TearDown"><a href="#Setup-与-TearDown" class="headerlink" title="Setup** 与 **TearDown"></a><strong>Setup**</strong> 与 <strong>**TearDown</strong></h2><p>测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）。</p>
<h3 id="TestMain"><a href="#TestMain" class="headerlink" title="TestMain"></a><strong>TestMain</strong></h3><p>通过在*_test.go文件中定义TestMain函数来可以在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）操作。</p>
<p>如果测试文件包含函数:func TestMain(m *testing.M)那么生成的测试会先调用 TestMain(m)，然后再运行具体测试。TestMain运行在主goroutine中, 可以在调用 m.Run前后做任何设置（setup）和拆卸（teardown）。退出测试的时候应该使用m.Run的返回值作为参数调用os.Exit。</p>
<p>一个使用TestMain来设置Setup和TearDown的示例如下：</p>
<p>func <strong>TestMain</strong> (m *testing.M) {</p>
<p>fmt.Println(&quot;write setup code here…&quot;) <em>//</em> <em>测试之前的做一些设置</em></p>
<p><em>//</em> <em>如果</em> <em>TestMain</em> <em>使用了</em> <em>flags <strong>，这里应该加上</strong> flag.Parse()</em></p>
<p>retCode := m.Run() <em>//</em> <em>执行测试</em></p>
<p>fmt.Println(&quot;write teardown code here…&quot;) <em>//</em> <em>测试之后做一些拆卸工作</em></p>
<p>os.Exit(retCode) <em>//</em> <em>退出测试</em></p>
<p>}</p>
<p>需要注意的是：在调用TestMain时, flag.Parse并没有被调用。所以如果TestMain 依赖于command-line标志 (包括 testing 包的标记), 则应该显示的调用flag.Parse。</p>
<h3 id="子测试的-Setup-与-Teardown"><a href="#子测试的-Setup-与-Teardown" class="headerlink" title="子测试的** Setup 与 Teardown**"></a><strong>子测试的**</strong> Setup <strong><strong>与</strong></strong> Teardown**</h3><p>有时候我们可能需要为每个测试集设置Setup与Teardown，也有可能需要为每个子测试设置Setup与Teardown。下面我们定义两个函数工具函数如下：</p>
<p><em>//</em> <em>测试集的 <em>_Setup</em></em> 与__Teardown_func <strong>setupTestCase</strong> (t *testing.T) <strong>func</strong> (t *testing.T) {</p>
<p>t.Log(&quot;如有需要在此执行:测试之前的setup&quot;)</p>
<p><strong>return</strong> func(t *testing.T) {</p>
<p>t.Log(&quot;如有需要在此执行:测试之后的teardown&quot;)</p>
<p>}</p>
<p>}</p>
<p><em>//</em> <em>子测试的 <em>_Setup</em></em> 与__Teardown_func <strong>setupSubTest</strong> (t *testing.T) <strong>func</strong> (t *testing.T) {</p>
<p>t.Log(&quot;如有需要在此执行:子测试之前的setup&quot;)</p>
<p><strong>return</strong> func(t *testing.T) {</p>
<p>t.Log(&quot;如有需要在此执行:子测试之后的teardown&quot;)</p>
<p>}</p>
<p>}</p>
<p>使用方式如下：</p>
<p>func <strong>TestSplit</strong> (t *testing.T) {</p>
<p>type test <strong>struct</strong> { <em>//</em> <em>定义 <strong>test</strong> 结构体</em></p>
<p>input <strong>string</strong></p>
<p>sep <strong>string</strong></p>
<p>want [] <strong>string</strong></p>
<p>}</p>
<p>tests := map[<strong>string</strong>]test{ <em>//</em> <em>测试用例使用 <strong>map</strong> 存储</em></p>
<p>&quot;simple&quot;: {input: &quot;a:b:c&quot;, sep: &quot;:&quot;, want: [] <strong>string</strong> {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},</p>
<p>&quot;wrong sep&quot;: {input: &quot;a:b:c&quot;, sep: &quot;,&quot;, want: [] <strong>string</strong> {&quot;a:b:c&quot;}},</p>
<p>&quot;more sep&quot;: {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: [] <strong>string</strong> {&quot;a&quot;, &quot;d&quot;}},</p>
<p>&quot;leading sep&quot;: {input: &quot;枯藤老树昏鸦&quot;, sep: &quot;老&quot;, want: [] <strong>string</strong> {&quot;&quot;, &quot;枯藤&quot;, &quot;树昏鸦&quot;}},</p>
<p>}</p>
<p>teardownTestCase := setupTestCase(t) <em>//</em> <em>测试之前执行 <strong>setup</strong> 操作</em></p>
<p>defer <strong>teardownTestCase</strong> (t) <em>//</em> <em>测试之后执行 <strong>testdoen</strong> 操作</em></p>
<p><strong>for</strong> name, tc := range tests {</p>
<p>t.Run(name, func(t *testing.T) { <em>//</em> <em>使用<strong>t.Run()</strong>执行子测试</em></p>
<p>teardownSubTest := setupSubTest(t) <em>//</em> <em>子测试之前执行 <strong>setup</strong> 操作</em></p>
<p>defer <strong>teardownSubTest</strong> (t) <em>//</em> <em>测试之后执行 <strong>testdoen</strong> 操作</em></p>
<p>got := Split(tc.input, tc.sep)</p>
<p><strong>if</strong>!reflect.DeepEqual(got, tc.want) {</p>
<p>t.Errorf(&quot;excepted:%#v, got:%#v&quot;, tc.want, got)</p>
<p>}</p>
<p>})</p>
<p>}</p>
<p>}</p>
<p>测试结果如下：</p>
<p>split $ go test -v</p>
<p><em>=== RUN TestSplit</em></p>
<p><em>=== RUN TestSplit/simple</em></p>
<p><em>=== RUN TestSplit/wrong_sep</em></p>
<p><em>=== RUN TestSplit/more_sep</em></p>
<p><em>=== RUN TestSplit/leading_sep</em></p>
<p>— PASS: TestSplit (0.00s)</p>
<p>split_test.go:71: 如有需要在此执行:测试之前的setup</p>
<p>— PASS: TestSplit/simple (0.00s)</p>
<p>split_test.go:79: 如有需要在此执行:子测试之前的setup</p>
<p>split_test.go:81: 如有需要在此执行:子测试之后的teardown</p>
<p>— PASS: TestSplit/wrong_sep (0.00s)</p>
<p>split_test.go:79: 如有需要在此执行:子测试之前的setup</p>
<p>split_test.go:81: 如有需要在此执行:子测试之后的teardown</p>
<p>— PASS: TestSplit/more_sep (0.00s)</p>
<p>split_test.go:79: 如有需要在此执行:子测试之前的setup</p>
<p>split_test.go:81: 如有需要在此执行:子测试之后的teardown</p>
<p>— PASS: TestSplit/leading_sep (0.00s)</p>
<p>split_test.go:79: 如有需要在此执行:子测试之前的setup</p>
<p>split_test.go:81: 如有需要在此执行:子测试之后的teardown</p>
<p>split_test.go:73: 如有需要在此执行:测试之后的teardown</p>
<p><em>=== RUN ExampleSplit</em></p>
<p>— PASS: ExampleSplit (0.00s)</p>
<p>PASS</p>
<p>ok github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s</p>
<h2 id="示例函数"><a href="#示例函数" class="headerlink" title="示例函数"></a><strong>示例函数</strong></h2><p>###示例函数的格式</p>
<p>被go test特殊对待的第三种函数就是示例函数，它们的函数名以Example为前缀。它们既没有参数也没有返回值。标准格式如下：</p>
<p>func <strong>ExampleName</strong> () {</p>
<p><em>// …</em></p>
<p>}</p>
<h3 id="示例函数示例"><a href="#示例函数示例" class="headerlink" title="示例函数示例"></a><strong>示例函数示例</strong></h3><p>下面的代码是我们为Split函数编写的一个示例函数：</p>
<p>func <strong>ExampleSplit</strong> () {</p>
<p>fmt.Println(split.Split(&quot;a:b:c&quot;, &quot;:&quot;))</p>
<p>fmt.Println(split.Split(&quot;枯藤老树昏鸦&quot;, &quot;老&quot;))</p>
<p><em>// Output:</em></p>
<p><em>// [a b c]</em></p>
<p><em>// [</em> <em>枯藤 树昏鸦__]</em></p>
<p>}</p>
<p>为你的代码编写示例代码有如下三个用处：</p>
<p>示例函数能够作为文档直接使用，例如基于web的godoc中能把示例函数与对应的函数或包相关联。</p>
<p>示例函数只要包含了// Output:也是可以通过go test运行的可执行测试。</p>
<p>split $ go test -run Example</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/split 0.006s</p>
<p>示例函数提供了可以直接运行的示例代码，可以直接在golang.org的godoc文档服务器上使用Go Playground运行示例代码。下图为strings.ToUpper函数在Playground的示例函数效果。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>定时器</title>
    <url>/2021/02/19/%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h3 id="定时器-1"><a href="#定时器-1" class="headerlink" title="定时器"></a><strong>定时器</strong></h3><ul>
<li>Timer：时间到了，执行只执行1次</li>
</ul>
<p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;time&quot;</p>
<p>)</p>
<p>func <strong>main</strong> () {</p>
<p><em>// 1.timer__基本使用</em></p>
<p><em>//timer1 := time.NewTimer(2 * time.Second)</em></p>
<p><em>//t1 := time.Now()</em></p>
<p><em>//fmt.Printf(&quot;t1:%v\n&quot;, t1)</em></p>
<p><em>//t2 := &amp;lt;-timer1.C</em></p>
<p><em>//fmt.Printf(&quot;t2:%v\n&quot;, t2)</em></p>
<p><em>// 2. <strong>验证</strong> timer <strong>只能响应</strong> 1__次</em></p>
<p><em>//timer2 := time.NewTimer(time.Second)</em></p>
<p><em>//for {</em></p>
<p><em>// &amp;lt;-timer2.C</em></p>
<p><em>// fmt.Println(&quot; <strong>时间到</strong>&quot;)</em></p>
<p><em>//}</em></p>
<p><em>// 3.timer__实现延时的功能</em></p>
<p><em>//(1)</em></p>
<p><em>//time.Sleep(time.Second)</em></p>
<p><em>//(2)</em></p>
<p><em>//timer3 := time.NewTimer(2 * time.Second)</em></p>
<p><em>//&amp;lt;-timer3.C</em></p>
<p><em>//fmt.Println(&quot;2 <strong>秒到</strong>&quot;)</em></p>
<p><em>//(3)</em></p>
<p><em>//&amp;lt;-time.After(2*time.Second)</em></p>
<p><em>//fmt.Println(&quot;2 <strong>秒到</strong>&quot;)</em></p>
<p><em>// 4.__停止定时器</em></p>
<p><em>//timer4 := time.NewTimer(2 * time.Second)</em></p>
<p><em>//go func() {</em></p>
<p><em>// &amp;lt;-timer4.C</em></p>
<p><em>// fmt.Println(&quot; <strong>定时器执行了</strong>&quot;)</em></p>
<p><em>//}()</em></p>
<p><em>//b := timer4.Stop()</em></p>
<p><em>//if b {</em></p>
<p><em>// fmt.Println(&quot;timer4 <strong>已经关闭</strong>&quot;)</em></p>
<p><em>//}</em></p>
<p><em>// 5.__重置定时器</em></p>
<p>timer5 := time.NewTimer(3 * time.Second)</p>
<p>timer5.Reset(1 * time.Second)</p>
<p>fmt.Println(time.Now())</p>
<p>fmt.Println(&amp;lt;-timer5.C)</p>
<p><strong>for</strong> {</p>
<p>}</p>
<p>}</p>
<ul>
<li>Ticker：时间到了，多次执行</li>
</ul>
<p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;time&quot;</p>
<p>)</p>
<p>func <strong>main</strong> () {</p>
<p><em>// 1. <strong>获取</strong> ticker__对象</em></p>
<p>ticker := time.NewTicker(1 * time.Second)</p>
<p>i := 0</p>
<p><em>//</em> <em>子协程</em></p>
<p>go <strong>func</strong> () {</p>
<p><strong>for</strong> {</p>
<p><em>//&amp;lt;-ticker.C</em></p>
<p>i++</p>
<p>fmt.Println(&amp;lt;-ticker.C)</p>
<p><strong>if</strong> i == 5 {</p>
<p><em>//__停止</em></p>
<p>ticker.Stop()</p>
<p>}</p>
<p>}</p>
<p>}()</p>
<p><strong>for</strong> {</p>
<p>}</p>
<p>}</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2021/02/19/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射是指在程序运行期对程序本身进行访问和修改的能力</p>
<h3 id="变量的内在机制"><a href="#变量的内在机制" class="headerlink" title="变量的内在机制"></a><strong>变量的内在机制</strong></h3><ul>
<li>变量包含类型信息和值信息 var arr [10]int arr[0] = 10</li>
<li>类型信息：是静态的元信息，是预先定义好的</li>
<li>值信息：是程序运行过程中动态改变的</li>
</ul>
<h3 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a><strong>反射的使用</strong></h3><ul>
<li>reflect包封装了反射相关的方法</li>
<li>获取类型信息：reflect.TypeOf，是静态的</li>
<li>获取值信息：reflect.ValueOf，是动态的</li>
</ul>
<h3 id="空接口与反射"><a href="#空接口与反射" class="headerlink" title="空接口与反射"></a><strong>空接口与反射</strong></h3><ul>
<li>反射可以在运行时动态获取程序的各种详细信息</li>
<li>反射获取interface类型信息</li>
</ul>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;reflect&quot;)</p>
<p><em>// <strong>反射获取</strong> interface__类型信息</em></p>
<p>func <strong>reflect_type</strong> (a <strong>interface</strong> {}) {</p>
<p>t := reflect.TypeOf(a)</p>
<p>fmt.Println(&quot;类型是：&quot;, t)</p>
<p><em>// kind()__可以获取具体类型</em></p>
<p>k := t.Kind()</p>
<p>fmt.Println(k)</p>
<p><strong>switch</strong> k {</p>
<p><strong>case</strong> reflect.Float64:</p>
<p>fmt.Printf(&quot;a is float64\n&quot;)</p>
<p><strong>case</strong> reflect.String:</p>
<p>fmt.Println(&quot;string&quot;)</p>
<p>}</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> x float64 = 3.4</p>
<p>reflect_type(x)</p>
<p>}</p>
<ul>
<li>反射获取interface值信息</li>
</ul>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;reflect&quot;)</p>
<p><em>// <strong>反射获取</strong> interface__值信息</em></p>
<p>func <strong>reflect_value</strong> (a <strong>interface</strong> {}) {</p>
<p>v := reflect.ValueOf(a)</p>
<p>fmt.Println(v)</p>
<p>k := v.Kind()</p>
<p>fmt.Println(k)</p>
<p><strong>switch</strong> k {</p>
<p><strong>case</strong> reflect.Float64:</p>
<p>fmt.Println(&quot;a是：&quot;, v.Float())</p>
<p>}</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> x float64 = 3.4</p>
<p>reflect_value(x)</p>
<p>}</p>
<ul>
<li>反射修改值信息</li>
</ul>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;reflect&quot;)</p>
<p><em>//__反射修改值</em></p>
<p>func <strong>reflect_set_value</strong> (a <strong>interface</strong> {}) {</p>
<p>v := reflect.ValueOf(a)</p>
<p>k := v.Kind()</p>
<p><strong>switch</strong> k {</p>
<p><strong>case</strong> reflect.Float64:</p>
<p><em>//</em> <em>反射修改值</em></p>
<p>v.SetFloat(6.9)</p>
<p>fmt.Println(&quot;a is &quot;, v.Float())</p>
<p><strong>case</strong> reflect.Ptr:</p>
<p><em>// Elem()__获取地址指向的值</em></p>
<p>v.Elem().SetFloat(7.9)</p>
<p>fmt.Println(&quot;case:&quot;, v.Elem().Float())</p>
<p><em>//</em> <em>地址</em></p>
<p>fmt.Println(v.Pointer())</p>
<p>}</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> x float64 = 3.4</p>
<p><em>//</em> <em>反射认为下面是指针类型，不是 <strong>float</strong> 类型</em></p>
<p>reflect_set_value(&amp;x)</p>
<p>fmt.Println(&quot;main:&quot;, x)</p>
<p>}</p>
<h3 id="结构体与反射"><a href="#结构体与反射" class="headerlink" title="结构体与反射"></a><strong>结构体与反射</strong></h3><p>查看类型、字段和方法</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;reflect&quot;)</p>
<p><em>//</em> <em>定义结构体</em></p>
<p>type User <strong>struct</strong> {</p>
<p>Id <strong>int</strong></p>
<p>Name <strong>string</strong></p>
<p>Age <strong>int</strong></p>
<p>}</p>
<p><em>//</em> <em>绑方法</em></p>
<p>func (u User) Hello() {</p>
<p>fmt.Println(&quot;Hello&quot;)</p>
<p>}</p>
<p><em>//</em> _传入__interface{}_func <strong>Poni</strong> (o <strong>interface</strong> {}) {</p>
<p>t := reflect.TypeOf(o)</p>
<p>fmt.Println(&quot;类型：&quot;, t)</p>
<p>fmt.Println(&quot;字符串类型：&quot;, t.Name())</p>
<p><em>//</em> <em>获取值</em></p>
<p>v := reflect.ValueOf(o)</p>
<p>fmt.Println(v)</p>
<p><em>//</em> <em>可以获取所有属性</em></p>
<p><em>//</em> <em>获取结构体字段个数：__t.NumField()</em></p>
<p><strong>for</strong> i := 0; i &amp;lt; t.NumField(); i++ {</p>
<p><em>//</em> <em>取每个字段</em></p>
<p>f := t.Field(i)</p>
<p>fmt.Printf(&quot;%s : %v&quot;, f.Name, f.Type)</p>
<p><em>//</em> <em>获取字段的值信息</em></p>
<p><em>// Interface()__：获取字段对应的值</em></p>
<p>val := v.Field(i).Interface()</p>
<p>fmt.Println(&quot;val :&quot;, val)</p>
<p>}</p>
<p>fmt.Println(&quot;=================方法====================&quot;)</p>
<p><strong>for</strong> i := 0; i &amp;lt; t.NumMethod(); i++ {</p>
<p>m := t.Method(i)</p>
<p>fmt.Println(m.Name)</p>
<p>fmt.Println(m.Type)</p>
<p>}</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>u := User{1, &quot;zs&quot;, 20}</p>
<p>Poni(u)</p>
<p>}</p>
<p>查看匿名字段</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;reflect&quot;</p>
<p>)</p>
<p><em>//</em> <em>定义结构体</em></p>
<p>type User <strong>struct</strong> {</p>
<p>Id <strong>int</strong></p>
<p>Name string</p>
<p>Age <strong>int</strong></p>
<p>}</p>
<p><em>//</em> <em>匿名字段</em></p>
<p>type Boy <strong>struct</strong> {</p>
<p>User</p>
<p>Addr string</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>m := Boy{User{1, &quot;zs&quot;, 20}, &quot;bj&quot;}</p>
<p>t := reflect.TypeOf(m)</p>
<p>fmt.Println(t)</p>
<p><em>// Anonymous__：匿名</em></p>
<p>fmt.Printf(&quot;%#v\n&quot;, t.Field(0))</p>
<p><em>//</em> <em>值信息</em></p>
<p>fmt.Printf(&quot;%#v\n&quot;, reflect.ValueOf(m).Field(0))</p>
<p>}</p>
<p>修改结构体的值</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;reflect&quot;)</p>
<p><em>//</em> <em>定义结构体</em></p>
<p>type User <strong>struct</strong> {</p>
<p>Id <strong>int</strong></p>
<p>Name <strong>string</strong></p>
<p>Age <strong>int</strong></p>
<p>}</p>
<p><em>//</em> _修改结构体值_func <strong>SetValue</strong> (o <strong>interface</strong> {}) {</p>
<p>v := reflect.ValueOf(o)</p>
<p><em>//</em> <em>获取指针指向的元素</em></p>
<p>v = v.Elem()</p>
<p><em>//</em> <em>取字段</em></p>
<p>f := v.FieldByName(&quot;Name&quot;)</p>
<p><strong>if</strong> f.Kind() == reflect.String {</p>
<p>f.SetString(&quot;kuteng&quot;)</p>
<p>}</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>u := User{1, &quot;5lmh.com&quot;, 20}</p>
<p>SetValue(&amp;u)</p>
<p>fmt.Println(u)</p>
<p>}</p>
<p>调用方法</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;reflect&quot;</p>
<p>)</p>
<p><em>//</em> <em>定义结构体</em></p>
<p>type User <strong>struct</strong> {</p>
<p>Id <strong>int</strong></p>
<p>Name string</p>
<p>Age <strong>int</strong></p>
<p>}</p>
<p>func (u User) Hello(name string) {</p>
<p>fmt.Println(&quot;Hello：&quot;, name)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>u := User{1, &quot;5lmh.com&quot;, 20}</p>
<p>v := reflect.ValueOf(u)</p>
<p><em>//</em> <em>获取方法</em></p>
<p>m := v.MethodByName(&quot;Hello&quot;)</p>
<p><em>//</em> <em>构建一些参数</em></p>
<p>args := []reflect.Value{reflect.ValueOf(&quot;6666&quot;)}</p>
<p><em>//</em> <em>没参数的情况下：__var args2 []reflect.Value</em></p>
<p><em>//</em> <em>调用方法，需要传入方法的参数</em></p>
<p>m.Call(args)</p>
<p>}</p>
<p>获取字段的tag</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;reflect&quot;)</p>
<p>type Student <strong>struct</strong> {</p>
<p>Name <strong>string</strong> <code>json:&amp;quot;name1&amp;quot; db:&amp;quot;name2&amp;quot;</code></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> s Student</p>
<p>v := reflect.ValueOf(&amp;s)</p>
<p><em>//</em> <em>类型</em></p>
<p>t := v.Type()</p>
<p><em>//</em> <em>获取字段</em></p>
<p>f := t.Elem().Field(0)</p>
<p>fmt.Println(f.Tag.Get(&quot;json&quot;))</p>
<p>fmt.Println(f.Tag.Get(&quot;db&quot;))</p>
<p>}</p>
<h3 id="反射练习"><a href="#反射练习" class="headerlink" title="反射练习"></a><strong>反射练习</strong></h3><ul>
<li><p>任务：解析如下配置文件</p>
<ul>
<li>序列化：将结构体序列化为配置文件数据并保存到硬盘</li>
<li>反序列化：将配置文件内容反序列化到程序的结构体</li>
</ul>
</li>
<li><p>配置文件有server和mysql相关配置</p>
</li>
</ul>
<p><em>#this is comment;this a comment;[] <strong>表示一个</strong> section</em><strong>[server]</strong>ip = 10.238.2.2port = 8080</p>
<p><strong>[mysql]</strong>username = rootpasswd = admindatabase = testhost = 192.168.10.10port = 8000timeout = 1.2</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>方法定义</title>
    <url>/2021/02/19/%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h1><p>Golang 方法总是绑定对象实例，并隐式将实例作为第一实参 (receiver)。</p>
<p>• 只能为当前包内命名类型定义方法。</p>
<p>• 参数 receiver 可任意命名。如方法中未曾使用 ，可省略参数名。</p>
<p>• 参数 receiver 类型可以是 T 或 *T。基类型 T 不能是接口或指针。</p>
<p>• 不支持方法重载，receiver 只是参数签名的组成部分。</p>
<p>• 可用实例 <strong>value</strong> 或 pointer 调用全部方法，编译器自动转换。</p>
<p>一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。</p>
<p>所有给定类型的方法属于该类型的方法集。</p>
<h3 id="方法定义："><a href="#方法定义：" class="headerlink" title="方法定义："></a><strong>方法定义：</strong></h3><p>func (recevier type) methodName(参数列表)(返回值列表){}</p>
<p>参数和返回值可以省略</p>
<p>package main</p>
<p>type Test <strong>struct</strong> {}</p>
<p><em>//</em> <em>无参数、无返回值</em></p>
<p>func (t Test) method0() {</p>
<p>}</p>
<p><em>//</em> <em>单参数、无返回值</em></p>
<p>func (t Test) method1(i <strong>int</strong> ) {</p>
<p>}</p>
<p><em>//</em> <em>多参数、无返回值</em></p>
<p>func (t Test) method2(x, y <strong>int</strong> ) {</p>
<p>}</p>
<p><em>//</em> <em>无参数、单返回值</em></p>
<p>func (t Test) method3() (i <strong>int</strong> ) {</p>
<p><strong>return</strong></p>
<p>}</p>
<p><em>//</em> <em>多参数、多返回值</em></p>
<p>func (t Test) method4(x, y <strong>int</strong> ) (z <strong>int</strong> , err error) {</p>
<p><strong>return</strong></p>
<p>}</p>
<p><em>//</em> <em>无参数、无返回值</em></p>
<p>func (t *Test) method5() {</p>
<p>}</p>
<p><em>//</em> <em>单参数、无返回值</em></p>
<p>func (t *Test) method6(i <strong>int</strong> ) {</p>
<p>}</p>
<p><em>//</em> <em>多参数、无返回值</em></p>
<p>func (t *Test) method7(x, y <strong>int</strong> ) {</p>
<p>}</p>
<p><em>//</em> <em>无参数、单返回值</em></p>
<p>func (t *Test) method8() (i <strong>int</strong> ) {</p>
<p><strong>return</strong></p>
<p>}</p>
<p><em>//</em> <em>多参数、多返回值</em></p>
<p>func (t *Test) method9(x, y <strong>int</strong> ) (z <strong>int</strong> , err error) {</p>
<p><strong>return</strong></p>
<p>}</p>
<p>func <strong>main</strong> () {}</p>
<p>下面定义一个结构体类型和该类型的一个方法：</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p><em>//__结构体</em></p>
<p>type User <strong>struct</strong> {</p>
<p>Name string</p>
<p>Email string</p>
<p>}</p>
<p><em>//__方法</em></p>
<p>func (u User) Notify() {</p>
<p>fmt.Printf(&quot;%v : %v \n&quot;, u.Name, u.Email)</p>
<p>}func <strong>main</strong> () {</p>
<p><em>//</em> <em>值类型调用方法</em></p>
<p>u1 := User{&quot;golang&quot;, &quot;<a href="mailto:golang@golang.com">golang@golang.com</a>&quot;}</p>
<p>u1.Notify()</p>
<p><em>//</em> <em>指针类型调用方法</em></p>
<p>u2 := User{&quot;go&quot;, &quot;<a href="mailto:go@go.com">go@go.com</a>&quot;}</p>
<p>u3 := &amp;u2</p>
<p>u3.Notify()</p>
<p>}</p>
<p>输出结果：</p>
<p>golang : <a href="mailto:golang@golang.com">golang@golang.com</a></p>
<p>go : <a href="mailto:go@go.com">go@go.com</a></p>
<p>解释：<br>首先我们定义了一个叫做 User 的结构体类型，然后定义了一个该类型的方法叫做 Notify，该方法的接受者是一个 User 类型的值。要调用 Notify 方法我们需要一个 User 类型的值或者指针。</p>
<p>在这个例子中当我们使用指针时，Go 调整和解引用指针使得调用可以被执行。注意，当接受者不是一个指针时，该方法操作对应接受者的值的副本(意思就是即使你使用了指针调用函数，但是函数的接受者是值类型，所以函数内部操作还是对副本的操作，而不是指针操作。</p>
<p>我们修改 Notify 方法，让它的接受者使用指针类型：</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p><em>//__结构体</em></p>
<p>type User <strong>struct</strong> {</p>
<p>Name string</p>
<p>Email string</p>
<p>}</p>
<p><em>//__方法</em></p>
<p>func (u *User) Notify() {</p>
<p>fmt.Printf(&quot;%v : %v \n&quot;, u.Name, u.Email)</p>
<p>}func <strong>main</strong> () {</p>
<p><em>//</em> <em>值类型调用方法</em></p>
<p>u1 := User{&quot;golang&quot;, &quot;<a href="mailto:golang@golang.com">golang@golang.com</a>&quot;}</p>
<p>u1.Notify()</p>
<p><em>//</em> <em>指针类型调用方法</em></p>
<p>u2 := User{&quot;go&quot;, &quot;<a href="mailto:go@go.com">go@go.com</a>&quot;}</p>
<p>u3 := &amp;u2</p>
<p>u3.Notify()</p>
<p>}</p>
<p>输出结果：</p>
<p>golang : <a href="mailto:golang@golang.com">golang@golang.com</a></p>
<p>go : <a href="mailto:go@go.com">go@go.com</a></p>
<p>注意：当接受者是指针时，即使用值类型调用那么函数内部也是对指针的操作。</p>
<p>方法不过是一种特殊的函数，只需将其还原，就知道 receiver T 和 *T 的差别。</p>
<p>package main</p>
<p>import &quot;fmt&quot;</p>
<p>type Data <strong>struct</strong> {</p>
<p>x <strong>int</strong></p>
<p>}</p>
<p>func ( <strong>self</strong> Data) ValueTest() { <em>// func ValueTest(self Data);</em></p>
<p>fmt.Printf(&quot;Value: %p\n&quot;, &amp; <strong>self</strong> )</p>
<p>}</p>
<p>func ( <strong>self</strong> *Data) PointerTest() { <em>// func PointerTest(self *Data);</em></p>
<p>fmt.Printf(&quot;Pointer: %p\n&quot;, <strong>self</strong> )</p>
<p>}</p>
<p>func main() {</p>
<p>d := Data{}</p>
<p>p := &amp;d</p>
<p>fmt.Printf(&quot;Data: %p\n&quot;, p)</p>
<p>d.ValueTest() <em>// ValueTest(d)</em></p>
<p>d.PointerTest() <em>// PointerTest(&amp;d)</em></p>
<p>p.ValueTest() <em>// ValueTest(*p)</em></p>
<p>p.PointerTest() <em>// PointerTest(p)</em></p>
<p>}</p>
<p>输出:</p>
<p>Data: 0xc42007c008</p>
<p>Value: 0xc42007c018</p>
<p>Pointer: 0xc42007c008</p>
<p>Value: 0xc42007c020</p>
<p>Pointer: 0xc42007c008</p>
<h3 id="普通函数与方法的区别"><a href="#普通函数与方法的区别" class="headerlink" title="普通函数与方法的区别"></a><strong>普通函数与方法的区别</strong></h3><p>1.对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然。</p>
<p>2.对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以。</p>
<p>package main</p>
<p><em>//__普通函数与方法的区别（在接收者分别为值类型和指针类型的时候）</em></p>
<p>import (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p><em>//1. <em>_普通函数</em></em> //__接收值类型参数的函数_func <strong>valueIntTest</strong> (a <strong>int</strong> ) <strong>int</strong> {</p>
<p><strong>return</strong> a + 10</p>
<p>}</p>
<p>_//__接收指针类型参数的函数_func <strong>pointerIntTest</strong> (a \ <strong>*int</strong> ) <strong>int</strong> {</p>
<p><strong>return</strong> *a + 10</p>
<p>}</p>
<p>func <strong>structTestValue</strong> () {</p>
<p>a := 2</p>
<p>fmt.Println(&quot;valueIntTest:&quot;, valueIntTest(a))</p>
<p><em>//__函数的参数为值类型，则不能直接将指针作为参数传递</em></p>
<p><em>//fmt.Println(&quot;valueIntTest:&quot;, valueIntTest(&amp;a))</em></p>
<p><em>//compile error: cannot use &amp;a (type *int) as type int in function argument</em></p>
<p>b := 5</p>
<p>fmt.Println(&quot;pointerIntTest:&quot;, pointerIntTest(&amp;b))</p>
<p><em>//__同样，当函数的参数为指针类型时，也不能直接将值类型作为参数传递</em></p>
<p><em>//fmt.Println(&quot;pointerIntTest:&quot;, pointerIntTest(b))</em></p>
<p><em>//compile error:cannot use b (type int) as type *int in function argument</em></p>
<p>}</p>
<p><em>//2.__方法</em></p>
<p>type PersonD <strong>struct</strong> {</p>
<p>id <strong>int</strong></p>
<p>name <strong>string</strong></p>
<p>}</p>
<p><em>//__接收者为值类型</em></p>
<p>func (p PersonD) valueShowName() {</p>
<p>fmt.Println(p.name)</p>
<p>}</p>
<p><em>//__接收者为指针类型</em></p>
<p>func (p *PersonD) pointShowName() {</p>
<p>fmt.Println(p.name)</p>
<p>}</p>
<p>func <strong>structTestFunc</strong> () {</p>
<p><em>//__值类型调用方法</em></p>
<p>personValue := PersonD{101, &quot;hello world&quot;}</p>
<p>personValue.valueShowName()</p>
<p>personValue.pointShowName()</p>
<p><em>//__指针类型调用方法</em></p>
<p>personPointer := &amp;PersonD{102, &quot;hello golang&quot;}</p>
<p>personPointer.valueShowName()</p>
<p>personPointer.pointShowName()</p>
<p><em>//__与普通函数不同，接收者为指针类型和值类型的方法，指针类型和值类型的变量均可相互调用</em></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>structTestValue()</p>
<p>structTestFunc()</p>
<p>}</p>
<p>输出结果：</p>
<p>valueIntTest: 12</p>
<p>pointerIntTest: 15</p>
<p>hello world</p>
<p>hello world</p>
<p>hello golang</p>
<p>hello golang</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>函数参数</title>
    <url>/2021/02/19/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a><strong>函数参数</strong></h3><p>函数定义时指出，函数定义时有参数，该变量可称为函数的形参。形参就像定义在函数体内的局部变量。</p>
<p>但当调用函数，传递过来的变量就是函数的实参，函数可以通过两种方式来传递参数：</p>
<p>值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<p>func <strong>swap</strong> (x, y <strong>int</strong> ) <strong>int</strong> {</p>
<p>… …</p>
<p>}</p>
<p>引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;)</p>
<p><em>/*</em> <em>定义相互交换值的函数</em> <em>*/</em></p>
<p>func <strong>swap</strong> (x, y \ <strong>*int</strong> ) {</p>
<p><strong>var</strong> temp <strong>int</strong></p>
<p>temp = *x <em>/*</em> <em>保存</em> <em>x</em> <em>的值</em> <em>*/</em></p>
<p>*x = *y <em>/*</em> <em>将</em> <em>y</em> <em>值赋给</em> <em>x */</em></p>
<p>*y = temp <em>/*</em> <em>将</em> <em>temp</em> <em>值赋给</em> <em>y*/</em></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> a, b <strong>int</strong> = 1, 2</p>
<p><em>/*</em></p>
<p><em>调用</em> <em>swap()</em> <em>函数</em></p>
<p><em>&amp;a</em> <em>指向</em> <em>a</em> <em>指针，__a</em> <em>变量的地址</em></p>
<p><em>&amp;b</em> <em>指向</em> <em>b</em> <em>指针，__b</em> <em>变量的地址</em></p>
<p><em>*/</em></p>
<p>swap(&amp;a, &amp;b)</p>
<p>fmt.Println(a, b)</p>
<p>}</p>
<p>输出结果：</p>
<p>2 1</p>
<p>在默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p>
<p>注意1：无论是值传递，还是引用传递，传递给函数的都是变量的副本，不过，值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。</p>
<p>注意2：map、slice、chan、指针、interface默认以引用的方式传递。</p>
<p>不定参数传值<br>就是函数的参数不是固定的，后面的类型是固定的。（可变参数）</p>
<p>Golang 可变参数本质上就是 slice。只能有一个，且必须是最后一个。</p>
<p>在参数赋值时可以不用用一个一个的赋值，可以直接传递一个数组或者切片，特别注意的是在参数后加上&quot;…&quot;即可。</p>
<p>func <strong>myfunc</strong> (args … <strong>int</strong> ) { <em>//0__个或多个参数</em></p>
<p>}</p>
<p>func <strong>add</strong> (a <strong>int</strong> , args… <strong>int</strong> ) <strong>int</strong> { <em>//1__个或多个参数</em></p>
<p>}</p>
<p>func <strong>add</strong> (a <strong>int</strong> , b <strong>int</strong> , args… <strong>int</strong> ) <strong>int</strong> { <em>//2__个或多个参数</em></p>
<p>}</p>
<p>注意：其中args是一个slice，我们可以通过arg[index]依次访问所有参数,通过len(arg)来判断传递参数的个数.</p>
<p>任意类型的不定参数：<br>就是函数的参数和每个参数的类型都不是固定的。</p>
<p>用interface{}传递任意类型数据是Go语言的惯例用法，而且interface{}是类型安全的。</p>
<p><strong>func**</strong> myfunc<strong>(</strong>args**…interface{}) {</p>
<p>}</p>
<p>代码：</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;)</p>
<p>func <strong>test</strong> (s <strong>string</strong> , n … <strong>int</strong> ) <strong>string</strong> {</p>
<p><strong>var</strong> x <strong>int</strong></p>
<p><strong>for</strong> _, i := range n {</p>
<p>x += i</p>
<p>}</p>
<p><strong>return</strong> fmt.Sprintf(s, x)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>println(test(&quot;sum: %d&quot;, 1, 2, 3))</p>
<p>}</p>
<p>输出结果：</p>
<p>sum: 6</p>
<p>使用 slice 对象做变参时，必须展开。（slice…）</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;)</p>
<p>func <strong>test</strong> (s <strong>string</strong> , n … <strong>int</strong> ) <strong>string</strong> {</p>
<p><strong>var</strong> x <strong>int</strong></p>
<p><strong>for</strong> _, i := range n {</p>
<p>x += i</p>
<p>}</p>
<p><strong>return</strong> fmt.Sprintf(s, x)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>s := [] <strong>int</strong> {1, 2, 3}</p>
<p>res := test(&quot;sum: %d&quot;, s…) <em>// slice…</em> <em>展开__slice</em></p>
<p>println(res)</p>
<p>}</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>函数定义</title>
    <url>/2021/02/19/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><h3 id="golang-函数特点："><a href="#golang-函数特点：" class="headerlink" title="golang** 函数特点：**"></a><strong>golang**</strong> 函数特点：**</h3><p>• 无需声明原型。</p>
<p>• 支持不定 变参。</p>
<p>• 支持多返回值。</p>
<p>• 支持命名返回参数。</p>
<p>• 支持匿名函数和闭包。</p>
<p>• 函数也是一种类型，一个函数可以赋值给变量。</p>
<p>• 不支持 嵌套 (nested) 一个包不能有两个名字一样的函数。</p>
<p>• 不支持 重载 (overload)</p>
<p>• 不支持 默认参数 ( <strong>default</strong> parameter)。</p>
<h3 id="函数声明："><a href="#函数声明：" class="headerlink" title="函数声明："></a><strong>函数声明：</strong></h3><p>函数声明包含一个函数名，参数列表， 返回值列表和函数体。如果函数没有返回值，则返回列表可以省略。函数从第一条语句开始执行，直到执行return语句或者执行函数的最后一条语句。</p>
<p>函数可以没有参数或接受多个参数。</p>
<p>注意类型在变量名之后 。</p>
<p>当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。</p>
<p>函数可以返回任意数量的返回值。</p>
<p>使用关键字 func 定义函数，左大括号依旧不能另起一行。</p>
<p>func <strong>test</strong> (x, y <strong>int</strong> , s string) ( <strong>int</strong> , string) {</p>
<p><em>//</em> <em>类型相同的相邻参数，参数类型可合并。 多返回值必须用括号。</em></p>
<p>n := x + y</p>
<p><strong>return</strong> n, fmt.Sprintf(s, n)</p>
<p>}</p>
<p>函数是第一类对象，可作为参数传递。建议将复杂签名定义为函数类型，以便于阅读。</p>
<p>package main</p>
<p>import &quot;fmt&quot;</p>
<p>func <strong>test</strong> (fn func() <strong>int</strong> ) <strong>int</strong> {</p>
<p><strong>return</strong> fn()</p>
<p>}<em>//</em> _定义函数类型。_type FormatFunc <strong>func</strong> (s <strong>string</strong> , x, y <strong>int</strong> ) <strong>string</strong></p>
<p>func <strong>format</strong> (fn FormatFunc, s <strong>string</strong> , x, y <strong>int</strong> ) <strong>string</strong> {</p>
<p><strong>return</strong> fn(s, x, y)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>s1 := test(func() <strong>int</strong> { <strong>return</strong> 100 }) <em>//</em> <em>直接将匿名函数当参数。</em></p>
<p>s2 := format(func(s <strong>string</strong> , x, y <strong>int</strong> ) <strong>string</strong> {</p>
<p><strong>return</strong> fmt.Sprintf(s, x, y)</p>
<p>}, &quot;%d, %d&quot;, 10, 20)</p>
<p>println(s1, s2)</p>
<p>}</p>
<p>输出结果：</p>
<p>100 10, 20</p>
<p>有返回值的函数，必须有明确的终止语句，否则会引发编译错误。</p>
<p>你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符。</p>
<p>package math</p>
<p>func S <strong>in</strong> (x float64) float //implemented <strong>in</strong> assembly language</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>函数返回值</title>
    <url>/2021/02/19/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a><strong>函数返回值</strong></h3><p>&quot;_&quot;标识符，用来忽略函数的某个返回值</p>
<p>Go 的返回值可以被命名，并且就像在函数体开头声明的变量那样使用。</p>
<p>返回值的名称应当具有一定的意义，可以作为文档使用。</p>
<p>没有参数的 return 语句返回各个返回变量的当前值。这种用法被称作&quot;裸&quot;返回。</p>
<p>直接返回语句仅应当用在像下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;)</p>
<p>func <strong>add</strong> (a, b <strong>int</strong> ) (c <strong>int</strong> ) {</p>
<p>c = a + b</p>
<p><strong>return</strong></p>
<p>}</p>
<p>func <strong>calc</strong> (a, b <strong>int</strong> ) (sum <strong>int</strong> , avg <strong>int</strong> ) {</p>
<p>sum = a + b</p>
<p>avg = (a + b) / 2</p>
<p><strong>return</strong></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> a, b <strong>int</strong> = 1, 2</p>
<p>c := <strong>add</strong> (a, b)</p>
<p>sum, avg := calc(a, b)</p>
<p>fmt.Println(a, b, c, sum, avg)</p>
<p>}</p>
<p>输出结果：</p>
<p>1 2 3 3 1</p>
<p>Golang返回值不能用容器对象接收多返回值。只能用多个变量，或 &quot;_&quot; 忽略。</p>
<p><strong>package</strong> main</p>
<p>func <strong>test</strong> () ( <strong>int</strong> , <strong>int</strong> ) {</p>
<p><strong>return</strong> 1, 2</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><em>// s := make([]int, 2)</em></p>
<p><em>// s = test() // Error: multiple-value test() in single-value context</em></p>
<p>x, _ := test()</p>
<p>println(x)</p>
<p>}</p>
<p>输出结果：</p>
<p>1</p>
<p>多返回值可直接作为其他函数调用实参。</p>
<p>package main</p>
<p>func <strong>test</strong> () ( <strong>int</strong> , <strong>int</strong> ) {</p>
<p><strong>return</strong> 1, 2</p>
<p>}</p>
<p>func <strong>add</strong> (x, y <strong>int</strong> ) <strong>int</strong> {</p>
<p><strong>return</strong> x + y</p>
<p>}</p>
<p>func <strong>sum</strong> (n … <strong>int</strong> ) <strong>int</strong> {</p>
<p><strong>var</strong> x <strong>int</strong></p>
<p><strong>for</strong> _, i := range n {</p>
<p>x += i</p>
<p>}</p>
<p><strong>return</strong> x</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>println( <strong>add</strong> (test()))</p>
<p>println(sum(test()))</p>
<p>}</p>
<p>输出结果：</p>
<p>3</p>
<p>3</p>
<p>命名返回参数可看做与形参类似的局部变量，最后由 return 隐式返回。</p>
<p>package main</p>
<p>func <strong>add</strong> (x, y <strong>int</strong> ) (z <strong>int</strong> ) {</p>
<p>z = x + y</p>
<p><strong>return</strong></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>println( <strong>add</strong> (1, 2))</p>
<p>}</p>
<p>输出结果：</p>
<p>3</p>
<p>命名返回参数可被同名局部变量遮蔽，此时需要显式返回。</p>
<p>func <strong>add</strong> (x, y <strong>int</strong> ) (z <strong>int</strong> ) {</p>
<p>{ <em>//</em> <em>不能在一个级别，引发</em> <em>&quot;z redeclared in this block&quot;</em> <em>错误。</em></p>
<p><strong>var</strong> z = x + y</p>
<p><em>// return // Error: z is shadowed during return</em></p>
<p><strong>return</strong> z <em>//</em> <em>必须显式返回。</em></p>
<p>}</p>
<p>}</p>
<p>命名返回参数允许 defer 延迟调用通过闭包读取和修改。</p>
<p>package main</p>
<p>func <strong>add</strong> (x, y <strong>int</strong> ) (z <strong>int</strong> ) {</p>
<p>defer <strong>func</strong> () {</p>
<p>z += 100</p>
<p>}()</p>
<p>z = x + y</p>
<p><strong>return</strong></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>println( <strong>add</strong> (1, 2))</p>
<p>}</p>
<p>输出结果：</p>
<p>103</p>
<p>显式 return 返回前，会先修改命名返回参数。</p>
<p>package main</p>
<p>func <strong>add</strong> (x, y <strong>int</strong> ) (z <strong>int</strong> ) {</p>
<p>defer <strong>func</strong> () {</p>
<p>println(z) <em>//</em> <em>输出__: 203</em></p>
<p>}()</p>
<p>z = x + y</p>
<p><strong>return</strong> z + 200_//_ <em>执行顺序__: (z = z + 200) -&amp;gt; (call defer) -&amp;gt; (return)</em></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>println( <strong>add</strong> (1, 2)) <em>//</em> <em>输出__: 203</em></p>
<p>}</p>
<p>输出结果：</p>
<p>203</p>
<p>203</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>方法集</title>
    <url>/2021/02/19/%E6%96%B9%E6%B3%95%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h1><p>Golang方法集 ：每个类型都有与之关联的方法集，这会影响到接口实现规则。</p>
<p>• 类型 T 方法集包含全部 receiver T 方法。</p>
<p>• 类型 *T 方法集包含全部 receiver T + *T 方法。</p>
<p>• 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。</p>
<p>• 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法。</p>
<p>• 不管嵌入 T 或 *T，*S 方法集总是包含 T + *T 方法。</p>
<p>用实例 value 和 pointer 调用方法 (含匿名字段) 不受方法集约束，编译器总是查找全部方法，并自动转换 receiver 实参。</p>
<p>Go 语言中内部类型方法集提升的规则：</p>
<p>类型 T 方法集包含全部 receiver T 方法。</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>type T <strong>struct</strong> {</p>
<p><strong>int</strong></p>
<p>}</p>
<p>func (t T) test() {</p>
<p>fmt.Println(&quot;类型 T 方法集包含全部 receiver T 方法。&quot;)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>t1 := T{1}</p>
<p>fmt.Printf(&quot;t1 is : %v\n&quot;, t1)</p>
<p>t1.test()</p>
<p>}</p>
<p>输出结果：</p>
<p>t1 <strong>is</strong> : {1}</p>
<p>类型 T 方法集包含全部 receiver T 方法。</p>
<p>类型 *T 方法集包含全部 receiver T + *T 方法。</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>type T <strong>struct</strong> {</p>
<p><strong>int</strong></p>
<p>}</p>
<p>func (t T) testT() {</p>
<p>fmt.Println(&quot;类型 *T 方法集包含全部 receiver T 方法。&quot;)</p>
<p>}</p>
<p>func (t *T) testP() {</p>
<p>fmt.Println(&quot;类型 *T 方法集包含全部 receiver *T 方法。&quot;)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>t1 := T{1}</p>
<p>t2 := &amp;t1</p>
<p>fmt.Printf(&quot;t2 is : %v\n&quot;, t2)</p>
<p>t2.testT()</p>
<p>t2.testP()</p>
<p>}</p>
<p>输出结果：</p>
<p>t2 <strong>is</strong> : &amp;{1}</p>
<p>类型 *T 方法集包含全部 receiver T 方法。</p>
<p>类型 *T 方法集包含全部 receiver *T 方法。</p>
<p>给定一个结构体类型 S 和一个命名为 T 的类型，方法提升像下面规定的这样被包含在结构体方法集中：</p>
<p>如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。</p>
<p>这条规则说的是当我们嵌入一个类型，嵌入类型的接受者为值类型的方法将被提升，可以被外部类型的值和指针调用。</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>type S <strong>struct</strong> {</p>
<p>T</p>
<p>}</p>
<p>type T <strong>struct</strong> {</p>
<p><strong>int</strong></p>
<p>}</p>
<p>func (t T) testT() {</p>
<p>fmt.Println(&quot;如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。&quot;)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>s1 := S{T{1}}</p>
<p>s2 := &amp;s1</p>
<p>fmt.Printf(&quot;s1 is : %v\n&quot;, s1)</p>
<p>s1.testT()</p>
<p>fmt.Printf(&quot;s2 is : %v\n&quot;, s2)</p>
<p>s2.testT()</p>
<p>}</p>
<p>输出结果：</p>
<p>s1 <strong>is</strong> : 1</p>
<p>如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。</p>
<p>s2 <strong>is</strong> : &amp;1</p>
<p>如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。</p>
<p>如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法。</p>
<p>这条规则说的是当我们嵌入一个类型的指针，嵌入类型的接受者为值类型或指针类型的方法将被提升，可以被外部类型的值或者指针调用。</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>type S <strong>struct</strong> {</p>
<p>T</p>
<p>}</p>
<p>type T <strong>struct</strong> {</p>
<p><strong>int</strong></p>
<p>}</p>
<p>func (t T) testT() {</p>
<p>fmt.Println(&quot;如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法&quot;)</p>
<p>}</p>
<p>func (t *T) testP() {</p>
<p>fmt.Println(&quot;如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法&quot;)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>s1 := S{T{1}}</p>
<p>s2 := &amp;s1</p>
<p>fmt.Printf(&quot;s1 is : %v\n&quot;, s1)</p>
<p>s1.testT()</p>
<p>s1.testP()</p>
<p>fmt.Printf(&quot;s2 is : %v\n&quot;, s2)</p>
<p>s2.testT()</p>
<p>s2.testP()</p>
<p>}</p>
<p>输出结果：</p>
<p>s1 <strong>is</strong> : 1</p>
<p>如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法</p>
<p>如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法</p>
<p>s2 <strong>is</strong> : &amp;1</p>
<p>如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法</p>
<p>如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2021/02/19/%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p>
<h2 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a><strong>接口</strong></h2><h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a><strong>接口类型</strong></h3><p>在Go语言中接口（interface）是一种类型，一种抽象的类型。</p>
<p>interface是一组method的集合，是duck-type programming的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。</p>
<p>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型。</p>
<h3 id="为什么要使用接口"><a href="#为什么要使用接口" class="headerlink" title="为什么要使用接口"></a><strong>为什么要使用接口</strong></h3><p>type Cat <strong>struct</strong> {}</p>
<p>func (c Cat) Say() <strong>string</strong> { <strong>return</strong>&quot;喵喵喵&quot; }</p>
<p>type Dog <strong>struct</strong> {}</p>
<p>func (d Dog) Say() <strong>string</strong> { <strong>return</strong>&quot;汪汪汪&quot; }</p>
<p>func <strong>main</strong> () {</p>
<p>c := Cat{}</p>
<p>fmt.Println(&quot;猫:&quot;, c.Say())</p>
<p>d := Dog{}</p>
<p>fmt.Println(&quot;狗:&quot;, d.Say())</p>
<p>}</p>
<p>上面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成&quot;能叫的动物&quot;来处理呢？</p>
<p>像类似的例子在我们编程过程中会经常遇到：</p>
<p>比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成&quot;支付方式&quot;来处理呢？</p>
<p>比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成&quot;图形&quot;来处理呢？</p>
<p>比如销售、行政、程序员都能计算月薪，我们能不能把他们当成&quot;员工&quot;来处理呢？</p>
<p>Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。</p>
<h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a><strong>接口的定义</strong></h3><p>Go语言提倡面向接口编程。</p>
<p>接口是一个或多个方法签名的集合。</p>
<p>任何类型的方法集中只要拥有该接口&#39;对应的全部方法&#39;签名。</p>
<p>就表示它 &quot;实现&quot;了该接口，无须在该类型上显式声明实现了哪个接口。</p>
<p>这称为Structural Typing。</p>
<p>所谓对应方法，是指有相同名称、参数列表 (不包括参数名) 以及返回值。</p>
<p>当然，该类型还可以有其他方法。</p>
<p>接口只有方法声明，没有实现，没有数据字段。</p>
<p>接口可以匿名嵌入其他接口，或嵌入到结构中。</p>
<p>对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针。</p>
<p>只有当接口存储的类型和对象都为nil时，接口才等于nil。</p>
<p>接口调用不会做receiver的自动转换。</p>
<p>接口同样支持匿名字段方法。</p>
<p>接口也可实现类似OOP中的多态。</p>
<p>空接口可以作为任何类型数据的容器。</p>
<p>一个类型可实现多个接口。</p>
<p>接口命名习惯以 er 结尾。</p>
<p>每个接口由数个方法组成，接口的定义格式如下：</p>
<p>type 接口类型名 <strong>interface</strong> {</p>
<p>方法名1( 参数列表1 ) 返回值列表1</p>
<p>方法名2( 参数列表2 ) 返回值列表2</p>
<p>…</p>
<p>}</p>
<p>其中：</p>
<p>1.接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。</p>
<p>2.方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</p>
<p>3.参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</p>
<p>举个例子：</p>
<p>type writer <strong>interface</strong> {</p>
<p>Write([] <strong>byte</strong> ) error</p>
<p>}</p>
<p>当你看到这个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情。</p>
<h3 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a><strong>实现接口的条件</strong></h3><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表。</p>
<p>我们来定义一个Sayer接口：</p>
<p><em>// Sayer</em> <em>接口</em></p>
<p>type Sayer <strong>interface</strong> {</p>
<p>say()</p>
<p>}</p>
<p>定义dog和cat两个结构体：</p>
<p>type dog struct {}</p>
<p>type cat struct {}</p>
<p>因为Sayer接口里只有一个say方法，所以我们只需要给dog和cat 分别实现say方法就可以实现Sayer接口了。</p>
<p><em>// dog <strong>实现了</strong> Sayer__接口</em></p>
<p>func (d dog) say() {</p>
<p>fmt.Println(&quot;汪汪汪&quot;)</p>
<p>}</p>
<p><em>// cat <strong>实现了</strong> Sayer__接口</em></p>
<p>func (c cat) say() {</p>
<p>fmt.Println(&quot;喵喵喵&quot;)</p>
<p>}</p>
<p>接口的实现就是这么简单，只要实现了接口中的所有方法，就实现了这个接口。</p>
<h3 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a><strong>接口类型变量</strong></h3><p>那实现了接口有什么用呢？</p>
<p>接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，Sayer类型的变量能够存储dog和cat类型的变量。</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> x Sayer <em>//</em> <em>声明一个 <strong>Sayer</strong> 类型的变量__x</em></p>
<p>a := cat{} <em>//</em> <em>实例化一个__cat</em></p>
<p>b := dog{} <em>//</em> <em>实例化一个__dog</em></p>
<p>x = a <em>//</em> <em>可以把 <strong>cat</strong> 实例直接赋值给__x</em></p>
<p>x.say() <em>//</em> <em>喵喵喵</em></p>
<p>x = b <em>//</em> <em>可以把 <strong>dog</strong> 实例直接赋值给__x</em></p>
<p>x.say() <em>//</em> <em>汪汪汪</em></p>
<p>}</p>
<h3 id="值接收者和指针接收者实现接口的区别"><a href="#值接收者和指针接收者实现接口的区别" class="headerlink" title="值接收者和指针接收者实现接口的区别"></a><strong>值接收者和指针接收者实现接口的区别</strong></h3><p>使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？接下来我们通过一个例子看一下其中的区别。</p>
<p>我们有一个Mover接口和一个dog结构体。</p>
<p>type Mover <strong>interface</strong> {</p>
<p>move()</p>
<p>}</p>
<p>type dog <strong>struct</strong> {}</p>
<h3 id="值接收者实现接口"><a href="#值接收者实现接口" class="headerlink" title="值接收者实现接口"></a><strong>值接收者实现接口</strong></h3><p>func (d dog) <strong>move</strong> () {</p>
<p>fmt.Println(&quot;狗会动&quot;)</p>
<p>}</p>
<p>此时实现接口的是dog类型：</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> x Mover</p>
<p><strong>var</strong> wangcai = dog{} <em>//</em> <em>旺财是 <strong>dog</strong> 类型</em></p>
<p>x = wangcai <em>// x <strong>可以接收</strong> dog__类型</em></p>
<p><strong>var</strong> fugui = &amp;dog{} <em>//</em> <em>富贵是 <strong>*dog</strong> 类型</em></p>
<p>x = fugui <em>// x <strong>可以接收</strong> *dog__类型</em></p>
<p>x.move()</p>
<p>}</p>
<p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针*dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针fugui内部会自动求值*fugui。</p>
<h3 id="指针接收者实现接口"><a href="#指针接收者实现接口" class="headerlink" title="指针接收者实现接口"></a><strong>指针接收者实现接口</strong></h3><p>同样的代码我们再来测试一下使用指针接收者有什么区别：</p>
<p>func (d *dog) move() {</p>
<p>fmt.Println(&quot;狗会动&quot;)</p>
<p>}func <strong>main</strong> () {</p>
<p><strong>var</strong> x Mover</p>
<p><strong>var</strong> wangcai = dog{} <em>//</em> <em>旺财是 <strong>dog</strong> 类型</em></p>
<p>x = wangcai <em>// x <strong>不可以接收</strong> dog__类型</em></p>
<p><strong>var</strong> fugui = &amp;dog{} <em>//</em> <em>富贵是 <strong>*dog</strong> 类型</em></p>
<p>x = fugui <em>// x <strong>可以接收</strong> *dog__类型</em></p>
<p>}</p>
<p>此时实现Mover接口的是*dog类型，所以不能给x传入dog类型的wangcai，此时x只能存储*dog类型的值。</p>
<h3 id="下面的代码是一个比较好的面试题"><a href="#下面的代码是一个比较好的面试题" class="headerlink" title="下面的代码是一个比较好的面试题"></a><strong>下面的代码是一个比较好的面试题</strong></h3><p>请问下面的代码是否能通过编译？</p>
<p>type People <strong>interface</strong> {</p>
<p>Speak( <strong>string</strong> ) <strong>string</strong></p>
<p>}</p>
<p>type Student <strong>struct</strong> {}</p>
<p>func (stu *Student) Speak(think <strong>string</strong> ) (talk <strong>string</strong> ) {</p>
<p><strong>if</strong> think == &quot;sb&quot; {</p>
<p>talk = &quot;你是个大帅比&quot;</p>
<p>} <strong>else</strong> {</p>
<p>talk = &quot;您好&quot;</p>
<p>}</p>
<p><strong>return</strong></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> peo People = Student{}</p>
<p>think := &quot;bitch&quot;</p>
<p>fmt.Println(peo.Speak(think))</p>
<p>}</p>
<h2 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a><strong>类型与接口的关系</strong></h2><h3 id="一个类型实现多个接口"><a href="#一个类型实现多个接口" class="headerlink" title="一个类型实现多个接口"></a><strong>一个类型实现多个接口</strong></h3><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义Sayer接口和Mover接口，如下： Mover接口。</p>
<p><em>// Sayer</em> <em>接口</em></p>
<p>type Sayer <strong>interface</strong> {</p>
<p>say()</p>
<p>}</p>
<p><em>// Mover</em> <em>接口</em></p>
<p>type Mover <strong>interface</strong> {</p>
<p>move()</p>
<p>}</p>
<p>dog既可以实现Sayer接口，也可以实现Mover接口。</p>
<p>type dog <strong>struct</strong> {</p>
<p>name <strong>string</strong></p>
<p>}</p>
<p><em>//</em> <em>实现 <strong>Sayer</strong> 接口</em></p>
<p>func (d dog) say() {</p>
<p>fmt.Printf(&quot;%s会叫汪汪汪\n&quot;, d.name)</p>
<p>}</p>
<p><em>//</em> <em>实现 <strong>Mover</strong> 接口</em></p>
<p>func (d dog) move() {</p>
<p>fmt.Printf(&quot;%s会动\n&quot;, d.name)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> x Sayer</p>
<p><strong>var</strong> y Mover</p>
<p><strong>var</strong> a = dog{name: &quot;旺财&quot;}</p>
<p>x = a</p>
<p>y = a</p>
<p>x.say()</p>
<p>y.move()</p>
<p>}</p>
<h3 id="多个类型实现同一接口"><a href="#多个类型实现同一接口" class="headerlink" title="多个类型实现同一接口"></a><strong>多个类型实现同一接口</strong></h3><p>Go语言中不同的类型还可以实现同一接口 首先我们定义一个Mover接口，它要求必须由一个move方法。</p>
<p><em>// Mover</em> <em>接口</em></p>
<p>type Mover <strong>interface</strong> {</p>
<p>move()</p>
<p>}</p>
<p>例如狗可以动，汽车也可以动，可以使用如下代码实现这个关系：</p>
<p>type dog <strong>struct</strong> {</p>
<p>name string</p>
<p>}</p>
<p>type car <strong>struct</strong> {</p>
<p>brand string</p>
<p>}</p>
<p><em>// dog <strong>类型实现</strong> Mover__接口</em></p>
<p>func (d dog) move() {</p>
<p>fmt.Printf(&quot;%s会跑\n&quot;, d.name)</p>
<p>}</p>
<p><em>// car <strong>类型实现</strong> Mover__接口</em></p>
<p>func (c car) move() {</p>
<p>fmt.Printf(&quot;%s速度70迈\n&quot;, c.brand)</p>
<p>}</p>
<p>这个时候我们在代码中就可以把狗和汽车当成一个会动的物体来处理了，不再需要关注它们具体是什么，只需要调用它们的move方法就可以了。</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> x Mover</p>
<p><strong>var</strong> a = dog{name: &quot;旺财&quot;}</p>
<p><strong>var</strong> b = car{brand: &quot;保时捷&quot;}</p>
<p>x = a</p>
<p>x.move()</p>
<p>x = b</p>
<p>x.move()</p>
<p>}</p>
<p>上面的代码执行结果如下：</p>
<p>旺财会跑</p>
<p>保时捷速度70迈</p>
<p>并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p>
<p><em>// WashingMachine</em> <em>洗衣机</em></p>
<p>type WashingMachine <strong>interface</strong> {</p>
<p>wash()</p>
<p>dry()</p>
<p>}</p>
<p><em>//</em> <em>甩干器</em></p>
<p>type dryer <strong>struct</strong> {}</p>
<p><em>//</em> <em>实现 <strong>WashingMachine</strong> 接口的<strong>dry()</strong>方法</em></p>
<p>func (d dryer) dry() {</p>
<p>fmt.Println(&quot;甩一甩&quot;)</p>
<p>}</p>
<p><em>//</em> <em>海尔洗衣机</em></p>
<p>type haier <strong>struct</strong> {</p>
<p>dryer <em>//__嵌入甩干器</em></p>
<p>}</p>
<p><em>//</em> <em>实现 <strong>WashingMachine</strong> 接口的<strong>wash()</strong>方法</em></p>
<p>func (h haier) wash() {</p>
<p>fmt.Println(&quot;洗刷刷&quot;)</p>
<p>}</p>
<h3 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a><strong>接口嵌套</strong></h3><p>接口与接口间可以通过嵌套创造出新的接口。</p>
<p><em>// Sayer</em> <em>接口</em></p>
<p>type Sayer <strong>interface</strong> {</p>
<p>say()</p>
<p>}</p>
<p><em>// Mover</em> <em>接口</em></p>
<p>type Mover <strong>interface</strong> {</p>
<p>move()</p>
<p>}</p>
<p><em>//</em> <em>接口嵌套</em></p>
<p>type animal <strong>interface</strong> {</p>
<p>Sayer</p>
<p>Mover</p>
<p>}</p>
<p>嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口：</p>
<p>type cat <strong>struct</strong> {</p>
<p>name <strong>string</strong></p>
<p>}</p>
<p>func (c cat) say() {</p>
<p>fmt.Println(&quot;喵喵喵&quot;)</p>
<p>}</p>
<p>func (c cat) move() {</p>
<p>fmt.Println(&quot;猫会动&quot;)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> x animal</p>
<p>x = cat{name: &quot;花花&quot;}</p>
<p>x.move()</p>
<p>x.say()</p>
<p>}</p>
<h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a><strong>空接口</strong></h2><h3 id="空接口的定义"><a href="#空接口的定义" class="headerlink" title="空接口的定义"></a><strong>空接口的定义</strong></h3><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p>
<p>空接口类型的变量可以存储任意类型的变量。</p>
<p>func <strong>main</strong> () {</p>
<p><em>//</em> <em>定义一个空接口__x</em></p>
<p><strong>var</strong> x <strong>interface</strong> {}</p>
<p>s := &quot;pprof.cn&quot;</p>
<p>x = s</p>
<p>fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)</p>
<p>i := 100</p>
<p>x = i</p>
<p>fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)</p>
<p>b := true</p>
<p>x = b</p>
<p>fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)</p>
<p>}</p>
<h3 id="空接口的应用"><a href="#空接口的应用" class="headerlink" title="空接口的应用"></a><strong>空接口的应用</strong></h3><h4 id="空接口作为函数的参数"><a href="#空接口作为函数的参数" class="headerlink" title="空接口作为函数的参数"></a><strong>空接口作为函数的参数</strong></h4><p>使用空接口实现可以接收任意类型的函数参数。</p>
<p><em>//</em> _空接口作为函数参数_func <strong>show</strong> (a <strong>interface</strong> {}) {</p>
<p>fmt.Printf(&quot;type:%T value:%v\n&quot;, a, a)</p>
<p>}</p>
<h4 id="空接口作为-map-的值"><a href="#空接口作为-map-的值" class="headerlink" title="空接口作为** map **的值"></a><strong>空接口作为**</strong> map <strong>**的值</strong></h4><p>使用空接口实现可以保存任意值的字典。</p>
<p><em>//</em> <em>空接口作为 <strong>map</strong> 值</em></p>
<p><strong>var</strong> studentInfo = make(map[<strong>string</strong>] <strong>interface</strong> {})</p>
<p>studentInfo[&quot;name&quot;] = &quot;李白&quot;</p>
<p>studentInfo[&quot;age&quot;] = 18</p>
<p>studentInfo[&quot;married&quot;] = false</p>
<p>fmt.Println(studentInfo)</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a><strong>类型断言</strong></h3><p>空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢？</p>
<h4 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a><strong>接口值</strong></h4><p>一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。</p>
<p>我们来看一个具体的例子：</p>
<p>var w io.Writer</p>
<p>w = os.Stdout</p>
<p>w = new(bytes.Buffer)</p>
<p>w = nil</p>
<p>请看下图分解：</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-1gw7h2f_html_d57c929799588794.png"  alt=""></p>
<p>想要判断空接口中的值这个时候就可以使用类型断言，其语法格式：</p>
<p>x.(T)</p>
<p>其中：</p>
<p>x：表示类型为 <strong>interface</strong> {}的变量</p>
<p>T：表示断言x可能是的类型。</p>
<p>该语法返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败。</p>
<p>举个例子：</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> x <strong>interface</strong> {}</p>
<p>x = &quot;pprof.cn&quot;</p>
<p>v, ok := x.( <strong>string</strong> )</p>
<p><strong>if</strong> ok {</p>
<p>fmt.Println(v)</p>
<p>} <strong>else</strong> {</p>
<p>fmt.Println(&quot;类型断言失败&quot;)</p>
<p>}</p>
<p>}</p>
<p>上面的示例中如果要断言多次就需要写多个if判断，这个时候我们可以使用switch语句来实现：</p>
<p>func <strong>justifyType</strong> (x <strong>interface</strong> {}) {</p>
<p><strong>switch</strong> v := x.(type) {</p>
<p><strong>case**</strong> string**:</p>
<p>fmt.Printf(&quot;x is a string，value is %v\n&quot;, v)</p>
<p><strong>case**</strong> int**:</p>
<p>fmt.Printf(&quot;x is a int is %v\n&quot;, v)</p>
<p><strong>case**</strong> bool**:</p>
<p>fmt.Printf(&quot;x is a bool is %v\n&quot;, v)</p>
<p><strong>default</strong> :</p>
<p>fmt.Println(&quot;unsupport type！&quot;)</p>
<p>}</p>
<p>}</p>
<p>因为空接口可以存储任意类型值的特点，所以空接口在Go语言中的使用十分广泛。</p>
<p>关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>匿名函数</title>
    <url>/2021/02/19/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>匿名函数是指不需要定义函数名的一种函数实现方式。1958年LISP首先采用匿名函数。</p>
<p>在Go里面，函数可以像普通变量一样被传递或使用，Go语言支持随时在代码里定义匿名函数。</p>
<p>匿名函数由一个不带函数名的函数声明和函数体组成。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p>
<p><strong>package**</strong> main**</p>
<p><strong>import</strong> (</p>
<p>&quot; <strong>fmt</strong>&quot;</p>
<p>&quot; <strong>math</strong>&quot;</p>
<p>)</p>
<p><strong>func**</strong> main**() {</p>
<p>getSqrt := func(a float64) float64 {</p>
<p>return math.Sqrt(a)</p>
<p>}</p>
<p><strong>fmt</strong>.Println( <strong>getSqrt</strong> (4))</p>
<p>}</p>
<p>输出结果：</p>
<p>2</p>
<p>上面先定义了一个名为getSqrt 的变量，初始化该变量时和之前的变量初始化有些不同，使用了func，func是定义函数的，可是这个函数和上面说的函数最大不同就是没有函数名，也就是匿名函数。这里将一个函数当做一个变量一样的操作。</p>
<p>Golang匿名函数可赋值给变量，做为结构字段，或者在 channel 里传送。</p>
<p>package main</p>
<p>func <strong>main</strong> () {</p>
<p><em>// — function variable —</em></p>
<p>fn := func() { println(&quot;Hello, World!&quot;) }</p>
<p>fn()</p>
<p><em>// — function collection —</em></p>
<p>fns := [](func(x <strong>int</strong> ) <strong>int</strong> ){</p>
<p>func(x <strong>int</strong> ) <strong>int</strong> { <strong>return</strong> x + 1 },</p>
<p>func(x <strong>int</strong> ) <strong>int</strong> { <strong>return</strong> x + 2 },</p>
<p>}</p>
<p>println(fns<a href="100">0</a>)</p>
<p><em>// — function as field —</em></p>
<p>d := <strong>struct</strong> {</p>
<p>fn <strong>func</strong> () <strong>string</strong></p>
<p>}{</p>
<p>fn: func() <strong>string</strong> { <strong>return</strong>&quot;Hello, World!&quot; },</p>
<p>}</p>
<p>println(d.fn())</p>
<p><em>// — channel of function —</em></p>
<p>fc := make(chan <strong>func</strong> () <strong>string</strong> , 2)</p>
<p>fc &amp;lt;- <strong>func</strong> () <strong>string</strong> { <strong>return</strong>&quot;Hello, World!&quot; }</p>
<p>println((&amp;lt;-fc)())</p>
<p>}</p>
<p>输出结果：</p>
<p>Hello, World!</p>
<p>101</p>
<p>Hello, World!</p>
<p>Hello, World!</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>循环语句range</title>
    <url>/2021/02/19/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5range/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h1 id="range"><a href="#range" class="headerlink" title="range"></a>range</h1><p>Golang range类似迭代器操作，返回 (索引, 值) 或 (键, 值)。</p>
<p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p>
<p><strong>for</strong> key, <strong>value</strong> := range oldMap {</p>
<p>newMap[key] = <strong>value</strong></p>
<p>}</p>
<p>|<br> | 1st value | 2nd value |<br> |<br>| — | — | — | — |<br>| string | index | s[index] | unicode, rune |<br>| — | — | — | — |<br>| array/slice | index | s[index] |<br> |<br>| map | key | m[key] |<br> |<br>| channel | element |<br> |<br> |</p>
<p>可忽略不想要的返回值，或 &quot;_&quot; 这个特殊变量。</p>
<p>package main</p>
<p>func <strong>main</strong> () {</p>
<p>s := &quot;abc&quot;</p>
<p><em>//</em> <em>忽略</em> <em>2nd value __，支持</em> <em>string/array/slice/map__ 。</em></p>
<p><strong>for</strong> i := range s {</p>
<p>println(s[i])</p>
<p>}</p>
<p><em>//</em> <em>忽略</em> <em>index__。</em></p>
<p><strong>for</strong> _, c := range s {</p>
<p>println(c)</p>
<p>}</p>
<p><em>//</em> <em>忽略全部返回值，仅迭代。</em></p>
<p><strong>for</strong> range s {</p>
<p>}</p>
<p>m := map[string] <strong>int</strong> {&quot;a&quot;: 1, &quot;b&quot;: 2}</p>
<p><em>//</em> <em>返回</em> <em>(key, value)__。</em></p>
<p><strong>for</strong> k, v := range m {</p>
<p>println(k, v)</p>
<p>}</p>
<p>}</p>
<p>输出结果：</p>
<p>97</p>
<p>98</p>
<p>99</p>
<p>97</p>
<p>98</p>
<p>99</p>
<p>a 1</p>
<p>b 2</p>
<p>*注意，range 会复制对象。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p>a := [3] <strong>int</strong> {0, 1, 2}</p>
<p><strong>for</strong> i, v := range a { <em>// index <strong>、</strong> value</em> <em>都是从复制品中取出。</em></p>
<p><strong>if</strong> i == 0 { <em>//</em> <em>在修改前，我们先修改原数组。</em></p>
<p>a[1], a[2] = 999, 999</p>
<p>fmt.Println(a) <em>//</em> <em>确认修改有效，输出</em> <em>[0, 999, 999]__。</em></p>
<p>}</p>
<p>a[i] = v + 100_//_ <em>使用复制品中取出的</em> <em>value</em> <em>修改原数组。</em></p>
<p>}</p>
<p>fmt.Println(a) <em>//</em> <em>输出</em> <em>[100, 101, 102]__。</em></p>
<p>}</p>
<p>输出结果：</p>
<p>[0999999]</p>
<p>[100101102]</p>
<p>建议改用引用类型，其底层数据不会被复制。</p>
<p><strong>package</strong> main</p>
<p>func <strong>main</strong> () {</p>
<p>s := [] <strong>int</strong> {1, 2, 3, 4, 5}</p>
<p><strong>for</strong> i, v := range s { <em>//</em> <em>复制</em> <em>struct slice { pointer, len, cap }__。</em></p>
<p><strong>if</strong> i == 0 {</p>
<p>s = s[:3] <em>//</em> <em>对</em> <em>slice</em> <em>的修改，不会影响</em> <em>range__。</em></p>
<p>s[2] = 100_//_ <em>对底层数据的修改。</em></p>
<p>}</p>
<p>println(i, v)</p>
<p>}</p>
<p>}</p>
<p>输出结果:</p>
<p>0 1</p>
<p>1 2</p>
<p>2 100</p>
<p>3 4</p>
<p>4 5</p>
<p>另外两种引用类型 map、channel 是指针包装，而不像 slice 是 struct。</p>
<p>for 和 for range有什么区别?</p>
<p>主要是使用场景不同</p>
<p>for可以</p>
<p>遍历array和slice</p>
<p>遍历key为整型递增的map</p>
<p>遍历string</p>
<p>for range可以完成所有for可以做的事情，却能做到for不能做的，包括</p>
<p>遍历key为string类型的map并同时获取key和value</p>
<p>遍历channel</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>条件语句select</title>
    <url>/2021/02/19/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5select/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><h3 id="select-语句"><a href="#select-语句" class="headerlink" title="select  语句"></a><strong>select</strong>  <strong>语句</strong></h3><p>select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</p>
<p>select 是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。<br> select 随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h4><p>Go 编程语言中 select 语句的语法如下：</p>
<p><strong>select</strong> {</p>
<p><strong>case</strong> communication clause :</p>
<p>statement(s);</p>
<p><strong>case</strong> communication clause :</p>
<p>statement(s);</p>
<p><em>/*</em> <em>你可以定义任意数量的</em> <em>case */</em></p>
<p><strong>default</strong> : <em>/*</em> <em>可选</em> <em>*/</em></p>
<p>statement(s);</p>
<p>}</p>
<p>以下描述了 select 语句的语法：</p>
<p>每个 <strong>case</strong> 都必须是一个通信</p>
<p>所有channel表达式都会被求值</p>
<p>所有被发送的表达式都会被求值</p>
<p>如果任意某个通信可以进行，它就执行；其他被忽略。</p>
<p>如果有多个 <strong>case</strong> 都可以运行，Select会随机公平地选出一个执行。其他不会执行。</p>
<p>否则：</p>
<p>如果有 <strong>default</strong> 子句，则执行该语句。</p>
<p>如果没有 <strong>default</strong> 字句， <strong>select</strong> 将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</p>
<h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a><strong>实例：</strong></h4><p>package main</p>
<p>import &quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> c1, c2, c3 chan <strong>int</strong></p>
<p><strong>var</strong> i1, i2 <strong>int</strong></p>
<p><strong>select</strong> {</p>
<p><strong>case</strong> i1 = &amp;lt;-c1:</p>
<p>fmt.Printf(&quot;received &quot;, i1, &quot; from c1\n&quot;)</p>
<p><strong>case</strong> c2 &amp;lt;- i2:</p>
<p>fmt.Printf(&quot;sent &quot;, i2, &quot; to c2\n&quot;)</p>
<p><strong>case</strong> i3, ok := (&amp;lt;-c3): <em>// same as: i3, ok := &amp;lt;-c3</em></p>
<p><strong>if</strong> ok {</p>
<p>fmt.Printf(&quot;received &quot;, i3, &quot; from c3\n&quot;)</p>
<p>} <strong>else</strong> {</p>
<p>fmt.Printf(&quot;c3 is closed\n&quot;)</p>
<p>}</p>
<p><strong>default</strong> :</p>
<p>fmt.Printf(&quot;no communication\n&quot;)</p>
<p>}</p>
<p>}</p>
<p>以上代码执行结果为：</p>
<p>no communication</p>
<p>select可以监听channel的数据流动</p>
<p>select的用法与switch语法非常类似，由select开始的一个新的选择块，每个选择条件由case语句来描述</p>
<p>与switch语句可以选择任何使用相等比较的条件相比，select由比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作</p>
<p><strong>select</strong> { <em>//__不停的在这里检测</em></p>
<p><strong>case</strong> &amp;lt;-chanl : <em>//__检测有没有数据可以读</em></p>
<p><em>// <strong>如果</strong> chanl <strong>成功读取到数据，则进行该</strong> case__处理语句</em></p>
<p><strong>case</strong> chan2 &amp;lt;- 1 : <em>//__检测有没有可以写</em></p>
<p><em>// <strong>如果成功向</strong> chan2 <strong>写入数据，则进行该</strong> case__处理语句</em></p>
<p><em>// <strong>假如没有</strong> default <strong>，那么在以上两个条件都不成立的情况下，就会在此阻塞</strong> // <strong>一般</strong> default <strong>会不写在里面，</strong> select <strong>中的</strong> default <strong>子句总是可运行的，因为会很消耗</strong> CPU__资源</em></p>
<p><strong>default</strong> :</p>
<p><em>// <strong>如果以上都没有符合条件，那么则进行</strong> default__处理流程</em></p>
<p>}</p>
<p>在一个select语句中，Go会按顺序从头到尾评估每一个发送和接收的语句。</p>
<p>如果其中的任意一个语句可以继续执行（即没有被阻塞），那么就从那些可以执行的语句中任意选择一条来使用。<br>如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有两种可能的情况：<br> ①如果给出了default语句，那么就会执行default的流程，同时程序的执行会从select语句后的语句中恢复。<br> ②如果没有default语句，那么select语句将被阻塞，直到至少有一个case可以进行下去。</p>
<h3 id="Golang-select-的使用及典型用法"><a href="#Golang-select-的使用及典型用法" class="headerlink" title="Golang select** 的使用及典型用法**"></a><strong>Golang select**</strong> 的使用及典型用法**</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h4><p>select是Go中的一个控制结构，类似于switch语句，用于处理异步IO操作。select会监听case语句中channel的读写操作，当case中channel读写操作为非阻塞状态（即能读写）时，将会触发相应的动作。<br> select中的case语句必须是一个channel操作</p>
<p>select中的default子句总是可运行的。</p>
<p>如果有多个case都可以运行，select会随机公平地选出一个执行，其他不会执行。</p>
<p>如果没有可运行的case语句，且有default语句，那么就会执行default的动作。</p>
<p>如果没有可运行的case语句，且没有default语句，select将阻塞，直到某个case通信可以运行</p>
<p>例如：</p>
<p>package main</p>
<p>import &quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> c1, c2, c3 chan <strong>int</strong></p>
<p><strong>var</strong> i1, i2 <strong>int</strong></p>
<p><strong>select</strong> {</p>
<p><strong>case</strong> i1 = &amp;lt;-c1:</p>
<p>fmt.Printf(&quot;received &quot;, i1, &quot; from c1\n&quot;)</p>
<p><strong>case</strong> c2 &amp;lt;- i2:</p>
<p>fmt.Printf(&quot;sent &quot;, i2, &quot; to c2\n&quot;)</p>
<p><strong>case</strong> i3, ok := (&amp;lt;-c3): <em>// same as: i3, ok := &amp;lt;-c3</em></p>
<p><strong>if</strong> ok {</p>
<p>fmt.Printf(&quot;received &quot;, i3, &quot; from c3\n&quot;)</p>
<p>} <strong>else</strong> {</p>
<p>fmt.Printf(&quot;c3 is closed\n&quot;)</p>
<p>}</p>
<p><strong>default</strong> :</p>
<p>fmt.Printf(&quot;no communication\n&quot;)</p>
<p>}</p>
<p>}</p>
<p><em>// <strong>输出：</strong> no communication</em></p>
<h3 id="典型用法"><a href="#典型用法" class="headerlink" title="典型用法"></a><strong>典型用法</strong></h3><h4 id="1-超时判断"><a href="#1-超时判断" class="headerlink" title="1.** 超时判断**"></a><strong>1.**</strong> 超时判断**</h4><p><em>// <strong>比如在下面的场景中，使用全局</strong> resChan <strong>来接受</strong> response <strong>，如果时间超过</strong> 3S,resChan <strong>中还没有数据返回，则第二条</strong> case__将执行</em> <strong>var</strong> resChan = make(chan <strong>int</strong> )_// do request_func <strong>test</strong> () {</p>
<p><strong>select</strong> {</p>
<p><strong>case</strong> data := &amp;lt;-resChan:</p>
<p>doData(data)</p>
<p><strong>case</strong> &amp;lt;-time.After(time.Second * 3):</p>
<p>fmt.Println(&quot;request time out&quot;)</p>
<p>}</p>
<p>}</p>
<p>func <strong>doData</strong> (data <strong>int</strong> ) {</p>
<p><em>//…</em></p>
<p>}</p>
<h4 id="2-退出"><a href="#2-退出" class="headerlink" title="2.** 退出**"></a><strong>2.**</strong> 退出**</h4><p><em>//__主线程（协程）中如下：</em> <strong>var</strong> shouldQuit=make(chan <strong>struct</strong> {})fun <strong>main</strong> (){</p>
<p>{</p>
<p><em>//loop</em></p>
<p>}</p>
<p><em>//…out of the loop</em></p>
<p><strong>select</strong> {</p>
<p><strong>case</strong> &amp;lt;-c.shouldQuit:</p>
<p>cleanUp()</p>
<p><strong>return</strong></p>
<p><strong>default</strong> :</p>
<p>}</p>
<p><em>//…</em></p>
<p>}</p>
<p><em>// <strong>再另外一个协程中，如果运行遇到非法操作或不可处理的错误，就向</strong> shouldQuit__发送数据通知程序停止运行</em></p>
<p>close(shouldQuit)</p>
<h4 id="3-判断-channel-是否阻塞"><a href="#3-判断-channel-是否阻塞" class="headerlink" title="3.** 判断 channel 是否阻塞**"></a><strong>3.**</strong> 判断 <strong><strong>channel</strong></strong> 是否阻塞**</h4><p><em>// <strong>在某些情况下是存在不希望</strong> channel__缓存满了的需求的，可以用如下方法判断</em></p>
<p>ch := make (chan <strong>int</strong> , 5)<em>//…</em></p>
<p>data：=0 <strong>select</strong> { <strong>case</strong> ch &amp;lt;- data: <strong>default</strong> :</p>
<p><em>// <strong>做相应操作，比如丢弃</strong> data__。视需求而定</em></p>
<p>}</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>循环语句for</title>
    <url>/2021/02/19/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5for/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h1 id="for"><a href="#for" class="headerlink" title="for"></a>for</h1><h3 id="Golang-for-支持三种循环方式，包括类似-while-的语法。"><a href="#Golang-for-支持三种循环方式，包括类似-while-的语法。" class="headerlink" title="Golang for** 支持三种循环方式，包括类似 ** while ** 的语法。**"></a><strong>Golang for**</strong> 支持三种循环方式，包括类似 <strong>** while **</strong> 的语法。**</h3><p>for循环是一个循环控制结构，可以执行指定次数的循环。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h4><p>Go语言的For循环有3中形式，只有其中的一种使用分号。</p>
<p><strong>for</strong> init; condition; post { }</p>
<p><strong>for</strong> condition { }</p>
<p><strong>for</strong> { }</p>
<p>init： 一般为赋值表达式，给控制变量赋初值；</p>
<p>condition： 关系表达式或逻辑表达式，循环控制条件；</p>
<p>post： 一般为赋值表达式，给控制变量增量或减量。</p>
<p><strong>for</strong> 语句执行过程如下：</p>
<p>①先对表达式 init 赋初值；</p>
<p>②判别赋值表达式 init 是否满足给定 condition 条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止 <strong>for</strong> 循环，执行循环体外语句。</p>
<p>s := &quot;abc&quot;</p>
<p><strong>for</strong> i, n := 0, len(s); i &amp;lt; n; i++ { // 常见的 <strong>for</strong> 循环，支持初始化语句。</p>
<p>println(s[i])</p>
<p>}</p>
<p>n := len(s) <strong>for</strong> n &amp;gt; 0 { // 替代 <strong>while</strong> (n &amp;gt; 0) {}</p>
<p>n–</p>
<p>println(s[n]) // 替代 <strong>for</strong> (; n &amp;gt; 0;) {}</p>
<p>}</p>
<p><strong>for</strong> { // 替代 <strong>while</strong> (true) {}</p>
<p>println(s) // 替代 <strong>for</strong> (;;) {}</p>
<p>}</p>
<p>不要期望编译器能理解你的想法，在初始化语句中计算出全部结果是个好主意。</p>
<p>package main</p>
<p>func <strong>length</strong> (s <strong>string</strong> ) <strong>int</strong> {</p>
<p>println(&quot;call length.&quot;)</p>
<p><strong>return</strong> len(s)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>s := &quot;abcd&quot;</p>
<p><strong>for</strong> i, n := 0, length(s); i &amp;lt; n; i++ { <em>//</em> <em>避免多次调用</em> <em>length</em> <em>函数。</em></p>
<p>println(i, s[i])</p>
<p>}</p>
<p>}</p>
<p>输出:</p>
<p>call length.</p>
<p>097</p>
<p>198</p>
<p>299</p>
<p>3100</p>
<h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a><strong>实例：</strong></h4><p>package main</p>
<p>import &quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> b <strong>int</strong> = 15</p>
<p><strong>var</strong> a <strong>int</strong></p>
<p>numbers := [6] <strong>int</strong> {1, 2, 3, 5}</p>
<p><em>/* for</em> <em>循环</em> <em>*/</em></p>
<p><strong>for</strong> a := 0; a &amp;lt; 10; a++ {</p>
<p>fmt.Printf(&quot;a 的值为: %d\n&quot;, a)</p>
<p>}</p>
<p><strong>for</strong> a &amp;lt; b {</p>
<p>a++</p>
<p>fmt.Printf(&quot;a 的值为: %d\n&quot;, a)</p>
<p>}</p>
<p><strong>for</strong> i,x:= range numbers {</p>
<p>fmt.Printf(&quot;第 %d 位 x 的值 = %d\n&quot;, i,x)</p>
<p>}</p>
<p>}</p>
<p>以上实例运行输出结果为:</p>
<p>a的值为: 0</p>
<p>a 的值为: 1</p>
<p>a 的值为: 2</p>
<p>a 的值为: 3</p>
<p>a 的值为: 4</p>
<p>a 的值为: 5</p>
<p>a 的值为: 6</p>
<p>a 的值为: 7</p>
<p>a 的值为: 8</p>
<p>a 的值为: 9</p>
<p>a 的值为: 1</p>
<p>a 的值为: 2</p>
<p>a 的值为: 3</p>
<p>a 的值为: 4</p>
<p>a 的值为: 5</p>
<p>a 的值为: 6</p>
<p>a 的值为: 7</p>
<p>a 的值为: 8</p>
<p>a 的值为: 9</p>
<p>a 的值为: 10</p>
<p>a 的值为: 11</p>
<p>a 的值为: 12</p>
<p>a 的值为: 13</p>
<p>a 的值为: 14</p>
<p>a 的值为: 15</p>
<p>第 0位 x 的值 = 1</p>
<p>第 1位 x 的值 = 2</p>
<p>第 2位 x 的值 = 3</p>
<p>第 3位 x 的值 = 5</p>
<p>第 4位 x 的值 = 0</p>
<p>第 5位 x 的值 = 0</p>
<h3 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a><strong>循环嵌套</strong></h3><p>在 for 循环中嵌套一个或多个 for 循环</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a><strong>语法</strong></h4><p>以下为 Go 语言嵌套循环的格式：</p>
<p><strong>for</strong> [condition | ( init; condition; increment ) | Range]</p>
<p>{</p>
<p><strong>for</strong> [condition | ( init; condition; increment ) | Range]</p>
<p>{</p>
<p>statement(s)</p>
<p>}</p>
<p>statement(s)</p>
<p>}</p>
<h4 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a><strong>实例：</strong></h4><p>以下实例使用循环嵌套来输出 2 到 100 间的素数：</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p><em>/*</em> <em>定义局部变量</em> <em>*/</em></p>
<p>var i, j <strong>int</strong></p>
<p><strong>for</strong> i=2; i &amp;lt; 100; i++ {</p>
<p><strong>for</strong> j=2; j &amp;lt;= (i/j); j++ {</p>
<p><strong>if</strong> (i%j==0) {</p>
<p><strong>break</strong> <em>//</em> <em>如果发现因子，则不是素数</em></p>
<p>}</p>
<p>}</p>
<p><strong>if</strong> (j &amp;gt; (i/j)) {</p>
<p>fmt.Printf(&quot;%d 是素数\n&quot;, i)</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>以上实例运行输出结果为:</p>
<p>2 是素数</p>
<p>3 是素数</p>
<p>5 是素数</p>
<p>7 是素数</p>
<p>11 是素数</p>
<p>13 是素数</p>
<p>17 是素数</p>
<p>19 是素数</p>
<p>23 是素数</p>
<p>29 是素数</p>
<p>31 是素数</p>
<p>37 是素数</p>
<p>41 是素数</p>
<p>43 是素数</p>
<p>47 是素数</p>
<p>53 是素数</p>
<p>59 是素数</p>
<p>61 是素数</p>
<p>67 是素数</p>
<p>71 是素数</p>
<p>73 是素数</p>
<p>79 是素数</p>
<p>83 是素数</p>
<p>89 是素数</p>
<p>97 是素数</p>
<h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a><strong>无限循环</strong></h3><p>如过循环中条件语句永远不为 false 则会进行无限循环，我们可以通过 for 循环语句中只设置一个条件表达式来执行无限循环：</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p><strong>for**</strong> true** {</p>
<p>fmt.Printf(&quot;这是无限循环。\n&quot;);</p>
<p>}</p>
<p>}</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>文件操作</title>
    <url>/2021/02/19/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h3 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a><strong>打开和关闭文件</strong></h3><p>os.Open()函数能够打开一个文件，返回一个*File和一个err。对得到的文件实例调用close()方法能够关闭文件。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;os&quot;</p>
<p>)</p>
<p>func <strong>main</strong> () {</p>
<p><em>//</em> <em>只读方式打开当前目录下的 <strong>main.go</strong> 文件</em></p>
<p>file, err := os.Open(&quot;./main.go&quot;)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;open file failed!, err:&quot;, err)</p>
<p><strong>return</strong></p>
<p>}</p>
<p><em>//</em> <em>关闭文件</em></p>
<p>file.Close()</p>
<p>}</p>
<p>为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a><strong>读取文件</strong></h2><h3 id="file-Read"><a href="#file-Read" class="headerlink" title="file.Read()"></a><strong>file.Read()</strong></h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h4><p>Read方法定义如下：</p>
<p>func (f *File) Read(b [] <strong>byte</strong> ) (n <strong>int</strong> , err error)</p>
<p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回0和io.EOF。 举个例子：</p>
<p>func <strong>main</strong> () {</p>
<p><em>//</em> <em>只读方式打开当前目录下的 <strong>main.go</strong> 文件</em></p>
<p>file, err := os.Open(&quot;./main.go&quot;)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;open file failed!, err:&quot;, err)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>defer file.Close()</p>
<p><em>//</em> <em>使用 <strong>Read</strong> 方法读取数据</em></p>
<p><strong>var</strong> tmp = make([] <strong>byte</strong> , 128)</p>
<p>n, err := file.Read(tmp)</p>
<p><strong>if</strong> err == io.EOF {</p>
<p>fmt.Println(&quot;文件读完了&quot;)</p>
<p><strong>return</strong></p>
<p>}</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;read file failed, err:&quot;, err)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>fmt.Printf(&quot;读取了%d字节数据\n&quot;, n)</p>
<p>fmt.Println( <strong>string</strong> (tmp[:n]))</p>
<p>}</p>
<h4 id="循环读取"><a href="#循环读取" class="headerlink" title="循环读取"></a><strong>循环读取</strong></h4><p>使用for循环读取文件中的所有数据。</p>
<p>func <strong>main</strong> () {</p>
<p><em>//</em> <em>只读方式打开当前目录下的 <strong>main.go</strong> 文件</em></p>
<p>file, err := os.Open(&quot;./main.go&quot;)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;open file failed!, err:&quot;, err)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>defer file.Close()</p>
<p><em>//</em> <em>循环读取文件</em></p>
<p><strong>var</strong> content [] <strong>byte</strong></p>
<p><strong>var</strong> tmp = make([] <strong>byte</strong> , 128)</p>
<p><strong>for</strong> {</p>
<p>n, err := file.Read(tmp)</p>
<p><strong>if</strong> err == io.EOF {</p>
<p>fmt.Println(&quot;文件读完了&quot;)</p>
<p><strong>break</strong></p>
<p>}</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;read file failed, err:&quot;, err)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>content = append(content, tmp[:n]…)</p>
<p>}</p>
<p>fmt.Println( <strong>string</strong> (content))</p>
<p>}</p>
<h4 id="bufio-读取文件"><a href="#bufio-读取文件" class="headerlink" title="bufio** 读取文件**"></a><strong>bufio**</strong> 读取文件**</h4><p>bufio是在file的基础上封装了一层API，支持更多的功能。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;bufio&quot;</p>
<p>&quot;fmt&quot;</p>
<p>&quot;io&quot;</p>
<p>&quot;os&quot;</p>
<p>)</p>
<p><em>// bufio__按行读取示例</em></p>
<p>func <strong>main</strong> () {</p>
<p>file, err := os.Open(&quot;./main.go&quot;)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;open file failed, err:&quot;, err)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>defer file.Close()</p>
<p>reader := bufio.NewReader(file)</p>
<p><strong>for</strong> {</p>
<p>line, err := reader.ReadString(&#39;\n&#39;) <em>//__注意是字符</em></p>
<p><strong>if</strong> err == io.EOF {</p>
<p>fmt.Println(&quot;文件读完了&quot;)</p>
<p><strong>break</strong></p>
<p>}</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;read file failed, err:&quot;, err)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>fmt.Print(line)</p>
<p>}</p>
<p>}</p>
<h4 id="ioutil-读取整个文件"><a href="#ioutil-读取整个文件" class="headerlink" title="ioutil** 读取整个文件**"></a><strong>ioutil**</strong> 读取整个文件**</h4><p>io/ioutil包的ReadFile方法能够读取完整的文件，只需要将文件名作为参数传入。</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;io/ioutil&quot;</p>
<p>)</p>
<p><em>// ioutil.ReadFile__读取整个文件</em></p>
<p>func <strong>main</strong> () {</p>
<p>content, err := ioutil.ReadFile(&quot;./main.go&quot;)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;read file failed, err:&quot;, err)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>fmt.Println(string(content))</p>
<p>}</p>
<h2 id="文件写入操作"><a href="#文件写入操作" class="headerlink" title="文件写入操作"></a><strong>文件写入操作</strong></h2><p>os.OpenFile()函数能够以指定模式打开文件，从而实现文件写入相关功能。</p>
<p>func <strong>OpenFile</strong> (name string, flag <strong>int</strong> , perm FileMode) (*File, error) {</p>
<p>…</p>
<p>}</p>
<p>其中：</p>
<p>name：要打开的文件名 flag：打开文件的模式。 模式有以下几种：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>os.O_WRONLY</td>
<td>只写</td>
</tr>
<tr>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>os.O_CREATE</td>
<td>创建文件</td>
</tr>
<tr>
<td>os.O_RDONLY</td>
<td>只读</td>
</tr>
<tr>
<td>os.O_RDWR</td>
<td>读写</td>
</tr>
<tr>
<td>os.O_TRUNC</td>
<td>清空</td>
</tr>
<tr>
<td>os.O_APPEND</td>
<td>追加</td>
</tr>
</tbody></table>
<p>perm：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</p>
<h3 id="Write-和-WriteString"><a href="#Write-和-WriteString" class="headerlink" title="Write** 和 **WriteString"></a><strong>Write**</strong> 和 <strong>**WriteString</strong></h3><p>func <strong>main</strong> () {</p>
<p>file, err := os.OpenFile(&quot;xx.txt&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;open file failed, err:&quot;, err)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>defer file.Close()</p>
<p>str := &quot;hello go&quot;</p>
<p>file.Write([] <strong>byte</strong> (str)) <em>//__写入字节切片数据</em></p>
<p>file.WriteString(&quot;hello go&quot;) <em>//__直接写入字符串数据</em></p>
<p>}</p>
<h3 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a><strong>bufio.NewWriter</strong></h3><p>func <strong>main</strong> () {</p>
<p>file, err := os.OpenFile(&quot;xx.txt&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;open file failed, err:&quot;, err)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>defer file.Close()</p>
<p>writer := bufio.NewWriter(file)</p>
<p><strong>for</strong> i := 0; i &amp;lt; 10; i++ {</p>
<p>writer.WriteString(&quot;hello word\n&quot;) <em>//__将数据先写入缓存</em></p>
<p>}</p>
<p>writer.Flush() <em>//__将缓存中的内容写入文件</em></p>
<p>}</p>
<h3 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a><strong>ioutil.WriteFile</strong></h3><p><strong>func**</strong> main**() {</p>
<p>str := &quot;hello word&quot;</p>
<p>err := ioutil.WriteFile(&quot;./xx.txt&quot;, []byte(str), 0666)</p>
<p>if err != nil {</p>
<p>fmt.Println(&quot;write file failed, err:&quot;, err)</p>
<p>return</p>
<p>}</p>
<p>}</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h2><h3 id="copyFile"><a href="#copyFile" class="headerlink" title="copyFile"></a><strong>copyFile</strong></h3><p>借助io.Copy()实现一个拷贝文件函数。</p>
<p><em>// CopyFile</em> _拷贝文件函数_func <strong>CopyFile</strong> (dstName, srcName <strong>string</strong> ) (written int64, err error) {</p>
<p><em>//</em> <em>以读方式打开源文件</em></p>
<p>src, err := os.Open(srcName)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Printf(&quot;open %s failed, err:%v.\n&quot;, srcName, err)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>defer src.Close()</p>
<p><em>//</em> <em>以写 <strong>|</strong> 创建的方式打开目标文件</em></p>
<p>dst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Printf(&quot;open %s failed, err:%v.\n&quot;, dstName, err)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>defer dst.Close()</p>
<p><strong>return</strong> io.Copy(dst, src) <em>// <strong>调用</strong> io.Copy()__拷贝内容</em></p>
<p>}func <strong>main</strong> () {</p>
<p>_, err := CopyFile(&quot;dst.txt&quot;, &quot;src.txt&quot;)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;copy file failed, err:&quot;, err)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>fmt.Println(&quot;copy done!&quot;)</p>
<p>}</p>
<h3 id="实现一个-cat-命令"><a href="#实现一个-cat-命令" class="headerlink" title="实现一个** cat **命令"></a><strong>实现一个**</strong> cat <strong>**命令</strong></h3><p>使用文件操作相关知识，模拟实现linux平台cat命令的功能。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;bufio&quot;</p>
<p>&quot;flag&quot;</p>
<p>&quot;fmt&quot;</p>
<p>&quot;io&quot;</p>
<p>&quot;os&quot;</p>
<p>)</p>
<p><em>// cat__命令实现</em></p>
<p>func <strong>cat</strong> (r *bufio.Reader) {</p>
<p><strong>for</strong> {</p>
<p>buf, err := r.ReadBytes(&#39;\n&#39;) <em>//__注意是字符</em></p>
<p><strong>if</strong> err == io.EOF {</p>
<p><strong>break</strong></p>
<p>}</p>
<p>fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)</p>
<p>}</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>flag.Parse() <em>//</em> <em>解析命令行参数</em></p>
<p><strong>if</strong> flag.NArg() == 0 {</p>
<p><em>//</em> <em>如果没有参数默认从标准输入读取内容</em></p>
<p>cat(bufio.NewReader(os.Stdin))</p>
<p>}</p>
<p><em>//</em> <em>依次读取每个指定文件的内容并打印到终端</em></p>
<p><strong>for</strong> i := 0; i &amp;lt; flag.NArg(); i++ {</p>
<p>f, err := os.Open(flag.Arg(i))</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Fprintf(os.Stdout, &quot;reading from %s failed, err:%v\n&quot;, flag.Arg(i), err)</p>
<p><strong>continue</strong></p>
<p>}</p>
<p>cat(bufio.NewReader(f))</p>
<p>}</p>
<p>}</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>循环控制Goto、Break、Continue</title>
    <url>/2021/02/19/%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6Goto%E3%80%81Break%E3%80%81Continue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h1><h1 id="Goto"><a href="#Goto" class="headerlink" title="Goto"></a>Goto</h1><h1 id="、"><a href="#、" class="headerlink" title="、"></a>、</h1><h1 id="Break"><a href="#Break" class="headerlink" title="Break"></a>Break</h1><h1 id="、-1"><a href="#、-1" class="headerlink" title="、"></a>、</h1><h1 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h1><p>循环控制语句</p>
<p>循环控制语句可以控制循环体内语句的执行过程。</p>
<p>GO 语言支持以下几种循环控制语句：</p>
<h3 id="Goto-、-Break-、-Continue"><a href="#Goto-、-Break-、-Continue" class="headerlink" title="Goto** 、 Break 、 **Continue"></a><strong>Goto**</strong> 、 <strong><strong>Break</strong></strong> 、 <strong>**Continue</strong></h3><p>1.三个语句都可以配合标签(label)使用</p>
<p>2.标签名区分大小写，定以后若不使用会造成编译错误</p>
<ol start="3">
<li><p><strong>continue</strong> 、 <strong>break</strong> 配合标签(label)可用于多层循环跳出</p>
</li>
<li><p><strong>goto</strong> 是调整执行位置，与 <strong>continue</strong> 、 <strong>break</strong> 配合标签(label)的结果并不相同</p>
</li>
</ol>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>压力测试</title>
    <url>/2021/02/19/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h1><h3 id="Go-怎么写测试用例"><a href="#Go-怎么写测试用例" class="headerlink" title="Go** 怎么写测试用例**"></a><strong>Go**</strong> 怎么写测试用例**</h3><p>开发程序其中很重要的一点是测试，我们如何保证代码的质量，如何保证每个函数是可运行，运行结果是正确的，又如何保证写出来的代码性能是好的，我们知道单元测试的重点在于发现程序设计或实现的逻辑错误，使问题及早暴露，便于问题的定位解决，而性能测试的重点在于发现程序设计上的一些问题，让线上的程序能够在高并发的情况下还能保持稳定。本小节将带着这一连串的问题来讲解Go语言中如何来实现单元测试和性能测试。</p>
<p>Go语言中自带有一个轻量级的测试框架testing和自带的go test命令来实现单元测试和性能测试，testing框架和其他语言中的测试框架类似，你可以基于这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例，那么接下来让我们一一来看一下怎么写。</p>
<p>另外建议安装gotests插件自动生成测试代码:</p>
<p>go get -u -v github.com/cweill/gotests/…</p>
<h3 id="如何编写测试用例"><a href="#如何编写测试用例" class="headerlink" title="如何编写测试用例"></a><strong>如何编写测试用例</strong></h3><p>由于go test命令只能在一个相应的目录下执行所有文件，所以我们接下来新建一个项目目录gotest,这样我们所有的代码和测试代码都在这个目录下。</p>
<p>接下来我们在该目录下面创建两个文件：gotest.go和gotest_test.go</p>
<p>gotest.go:这个文件里面我们是创建了一个包，里面有一个函数实现了除法运算:</p>
<p>package gotest</p>
<p>import (</p>
<p>&quot;errors&quot;</p>
<p>)</p>
<p>func Division(a, b float64) (float64, error) {</p>
<p><strong>if</strong> b == 0 {</p>
<p>return 0, errors.New(&quot;除数不能为0&quot;)</p>
<p>}</p>
<p>return a / b, nil</p>
<p>}</p>
<p>gotest_test.go:这是我们的单元测试文件，但是记住下面的这些原则：</p>
<p>文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码</p>
<p>你必须import testing这个包</p>
<p>所有的测试用例函数必须是Test开头</p>
<p>测试用例会按照源代码中写的顺序依次执行</p>
<p>测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态</p>
<p>测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如Testintdiv是错误的函数名。</p>
<p>函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息。</p>
<p>下面是我们的测试用例的代码：</p>
<p><strong>package</strong> gotest</p>
<p><strong>import</strong> (</p>
<p>&quot;testing&quot;</p>
<p>)</p>
<p>func <strong>Test_Division_1</strong> (t *testing.T) {</p>
<p><strong>if</strong> i, e := Division(6, 2); i != 3 || e != nil { <em>//try a unit test on function</em></p>
<p>t.Error(&quot;除法函数测试没通过&quot;) <em>//</em> <em>如果不是如预期的那么就报错</em></p>
<p>} <strong>else</strong> {</p>
<p>t.Log(&quot;第一个测试通过了&quot;) <em>//__记录一些你期望记录的信息</em></p>
<p>}</p>
<p>}</p>
<p>func <strong>Test_Division_2</strong> (t *testing.T) {</p>
<p>t.Error(&quot;就是不通过&quot;)</p>
<p>}</p>
<p>我们在项目目录下面执行go test,就会显示如下信息：</p>
<p><strong>—**</strong> FAIL <strong>:</strong> Test_Division_2<strong>(0.00</strong>seconds**)</p>
<p><strong>gotest_test</strong>.go:16: 就是不通过</p>
<p><strong>FAIL</strong></p>
<p><strong>exit**</strong> status** 1</p>
<p><strong>FAIL**</strong> gotest** 0.013s</p>
<p>从这个结果显示测试没有通过，因为在第二个测试函数中我们写死了测试不通过的代码t.Error，那么我们的第一个函数执行的情况怎么样呢？默认情况下执行go test是不会显示测试通过的信息的，我们需要带上参数go test -v，这样就会显示如下信息：</p>
<p><em>=== RUN Test_Division_1</em></p>
<p>— PASS: Test_Division_1 (0.00 seconds)</p>
<p>gotest_test.go:11: 第一个测试通过了</p>
<p><em>=== RUN Test_Division_2</em></p>
<p>— FAIL: Test_Division_2 (0.00 seconds)</p>
<p>gotest_test.go:16: 就是不通过</p>
<p>FAIL</p>
<p>exit status 1</p>
<p>FAIL gotest 0.012s</p>
<p>上面的输出详细的展示了这个测试的过程，我们看到测试函数1Test_Division_1测试通过，而测试函数2Test_Division_2测试失败了，最后得出结论测试不通过。接下来我们把测试函数2修改成如下代码：</p>
<p>func <strong>Test_Division_2</strong> (t *testing.T) {</p>
<p><strong>if</strong> _, e := Division(6, 0); e == nil { <em>//try a unit test on function</em></p>
<p>t.Error(&quot;Division did not work as expected.&quot;) <em>//</em> <em>如果不是如预期的那么就报错</em></p>
<p>} <strong>else</strong> {</p>
<p>t.Log(&quot;one test passed.&quot;, e) <em>//__记录一些你期望记录的信息</em></p>
<p>}</p>
<p>}</p>
<p>然后我们执行go test -v，就显示如下信息，测试通过了：</p>
<p><em>=== RUN Test_Division_1</em></p>
<p>— PASS: Test_Division_1 (0.00 seconds)</p>
<p>gotest_test.go:11: 第一个测试通过了</p>
<p><em>=== RUN Test_Division_2</em></p>
<p>— PASS: Test_Division_2 (0.00 seconds)</p>
<p>gotest_test.go:20: one test passed. 除数不能为0</p>
<p>PASS</p>
<p>ok gotest 0.013s</p>
<h3 id="如何编写压力测试"><a href="#如何编写压力测试" class="headerlink" title="如何编写压力测试"></a><strong>如何编写压力测试</strong></h3><p>压力测试用来检测函数(方法）的性能，和编写单元功能测试的方法类似,此处不再赘述，但需要注意以下几点：</p>
<p>压力测试用例必须遵循如下格式，其中XXX可以是任意字母数字的组合，但是首字母不能是小写字母</p>
<p>func <strong>BenchmarkXXX</strong> (b *testing.B) { … }</p>
<p>go test不会默认执行压力测试的函数，如果要执行压力测试需要带上参数-test.bench，语法:-test.bench=&quot;test_name_regex&quot;,例如go test -test.bench=&quot;.*&quot;表示测试全部的压力测试函数</p>
<p>在压力测试用例中,请记得在循环体内使用testing.B.N,以使测试可以正常的运行<br>文件名也必须以_test.go结尾</p>
<p>下面我们新建一个压力测试文件webbench_test.go，代码如下所示：</p>
<p><strong>package</strong> gotest</p>
<p><strong>import</strong> (</p>
<p>&quot;testing&quot;</p>
<p>)</p>
<p>func <strong>Benchmark_Division</strong> (b *testing.B) {</p>
<p><strong>for</strong> i := 0; i &amp;lt; b.N; i++ { <em>//use b.N for looping</em></p>
<p>Division(4, 5)</p>
<p>}</p>
<p>}</p>
<p>func <strong>Benchmark_TimeConsumingFunction</strong> (b *testing.B) {</p>
<p>b.StopTimer() <em>//__调用该函数停止压力测试的时间计数</em></p>
<p><em>// <strong>做一些初始化的工作</strong> , <strong>例如读取文件数据</strong> , <strong>数据库连接之类的</strong> ,</em></p>
<p><em>//__这样这些时间不影响我们测试函数本身的性能</em></p>
<p>b.StartTimer() <em>//__重新开始时间</em></p>
<p><strong>for</strong> i := 0; i &amp;lt; b.N; i++ {</p>
<p>Division(4, 5)</p>
<p>}</p>
<p>}</p>
<p>我们执行命令go test webbench_test.go -test.bench=&quot;.*&quot;，可以看到如下结果：</p>
<p>Benchmark_Division-4 500000000 7.76 ns/op 456 B/op 14 allocs/op</p>
<p>Benchmark_TimeConsumingFunction-4 500000000 7.80 ns/op 224 B/op 4 allocs/op</p>
<p>PASS</p>
<p>ok gotest 9.364s</p>
<p>上面的结果显示我们没有执行任何TestXXX的单元测试函数，显示的结果只执行了压力测试函数，第一条显示了Benchmark_Division执行了500000000次，每次的执行平均时间是7.76纳秒，第二条显示了Benchmark_TimeConsumingFunction执行了500000000，每次的平均执行时间是7.80纳秒。最后一条显示总共的执行时间。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>通过上面对单元测试和压力测试的学习，我们可以看到testing包很轻量，编写单元测试和压力测试用例非常简单，配合内置的go test命令就可以非常方便的进行测试，这样在我们每次修改完代码,执行一下go test就可以简单的完成回归测试了。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/2021/02/19/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误。</p>
<p>异常的使用场景简单描述：Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。</p>
<p>panic：</p>
<p>1、内置函数</p>
<p>2、假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行</p>
<p>3、返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行</p>
<p>4、直到goroutine整个退出，并报告错误</p>
<p>recover：</p>
<p>1、内置函数</p>
<p>2、用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为</p>
<p>3、一般的调用建议</p>
<p>a). 在defer函数中，通过recever来终止一个goroutine的panicking过程，从而恢复正常代码的执行</p>
<p>b). 可以获取通过panic传递的error</p>
<p>注意:</p>
<p>1.利用 <strong>recover</strong> 处理 <strong>panic</strong> 指令， <strong>defer</strong> 必须放在 <strong>panic</strong> 之前定义，另外 <strong>recover</strong> 只有在 <strong>defer</strong> 调用的函数中才有效。否则当 <strong>panic</strong> 时， <strong>recover</strong> 无法捕获到 <strong>panic</strong> ，无法防止 <strong>panic</strong> 扩散。</p>
<p>2.recover处理异常后，逻辑并不会恢复到 <strong>panic</strong> 那个点去，函数跑到 <strong>defer</strong> 之后的那个点。</p>
<p>3.多个 <strong>defer</strong> 会形成 <strong>defer</strong> 栈，后定义的 <strong>defer</strong> 语句会被最先调用。</p>
<p>package main</p>
<p>func <strong>main</strong> () {</p>
<p>test()</p>
<p>}</p>
<p>func <strong>test</strong> () {</p>
<p>defer <strong>func</strong> () {</p>
<p><strong>if</strong> err := recover(); err != nil {</p>
<p>println(err.(string)) <em>//</em> <em>将</em> <em>interface{}</em> <em>转型为具体类型。</em></p>
<p>}</p>
<p>}()</p>
<p>panic(&quot;panic error!&quot;)</p>
<p>}</p>
<p>输出结果：</p>
<p>panicerror!</p>
<p>由于 panic、recover 参数类型为 interface{}，因此可抛出任何类型对象。</p>
<p>func panic(v <strong>interface</strong> {})</p>
<p>func recover() <strong>interface</strong> {}</p>
<p>向已关闭的通道发送数据会引发panic</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;)</p>
<p>func <strong>main</strong> () {</p>
<p>defer <strong>func</strong> () {</p>
<p><strong>if</strong> err := recover(); err != nil {</p>
<p>fmt.Println(err)</p>
<p>}</p>
<p>}()</p>
<p><strong>var</strong> ch chan <strong>int</strong> = make(chan <strong>int</strong> , 10)</p>
<p>close(ch)</p>
<p>ch &amp;lt;- 1</p>
<p>}</p>
<p>输出结果：</p>
<p>sendon closed channel</p>
<p>延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>func <strong>test</strong> () {</p>
<p>defer <strong>func</strong> () {</p>
<p>fmt.Println(recover())</p>
<p>}()</p>
<p>defer <strong>func</strong> () {</p>
<p>panic(&quot;defer panic&quot;)</p>
<p>}()</p>
<p>panic(&quot;test panic&quot;)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>test()</p>
<p>}</p>
<p>输出:</p>
<p>defer panic</p>
<p>捕获函数 recover 只有在延迟调用内直接调用才会终止错误，否则总是返回 nil。任何未捕获的错误都会沿调用堆栈向外传递。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>func <strong>test</strong> () {</p>
<p>defer <strong>func</strong> () {</p>
<p>fmt.Println(recover()) <em>//__有效</em></p>
<p>}()</p>
<p>defer <strong>recover</strong> () <em>//__无效！</em></p>
<p>defer fmt. <strong>Println</strong> (recover()) <em>//__无效！</em></p>
<p>defer <strong>func</strong> () {</p>
<p>func() {</p>
<p>println(&quot;defer inner&quot;)</p>
<p>recover() <em>//__无效！</em></p>
<p>}()</p>
<p>}()</p>
<p>panic(&quot;test panic&quot;)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>test()</p>
<p>}</p>
<p>输出:</p>
<p>defer inner</p>
<p><strong>&amp;lt;nil&amp;gt;</strong></p>
<p>test panic</p>
<p>使用延迟匿名函数或下面这样都是有效的。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func <strong>except</strong> () {</p>
<p>fmt.Println(recover())</p>
<p>}</p>
<p>func <strong>test</strong> () {</p>
<p>defer <strong>except</strong> ()</p>
<p><strong>panic</strong> (&quot;test panic&quot;)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>test()</p>
<p>}</p>
<p>输出结果：</p>
<p>test panic</p>
<p>如果需要保护代码 段，可将代码块重构成匿名函数，如此可确保后续代码被执 。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>func <strong>test</strong> (x, y <strong>int</strong> ) {</p>
<p>var z <strong>int</strong></p>
<p><strong>func</strong> () {</p>
<p>defer <strong>func</strong> () {</p>
<p><strong>if**</strong> recover**() != nil {</p>
<p>z = 0</p>
<p>}</p>
<p>}()</p>
<p>panic(&quot;test panic&quot;)</p>
<p>z = x / y</p>
<p><strong>return</strong></p>
<p>}()</p>
<p>fmt.Printf(&quot;x / y = %d\n&quot;, z)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>test(2, 1)</p>
<p>}</p>
<p>输出结果：</p>
<p>x / y = 0</p>
<p>除用 panic 引发中断性错误外，还可返回 error 类型错误对象来表示函数调用状态。</p>
<p>type error <strong>interface</strong> {</p>
<p>Error() <strong>string</strong></p>
<p>}</p>
<p>标准库 errors.New 和 fmt.Errorf 函数用于创建实现 error 接口的错误对象。通过判断错误对象实例来确定具体错误类型。</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;errors&quot;</p>
<p>&quot;fmt&quot;)</p>
<p><strong>var</strong> ErrDivByZero = errors.New(&quot;division by zero&quot;)</p>
<p>func <strong>div</strong> (x, y <strong>int</strong> ) ( <strong>int</strong> , error) {</p>
<p><strong>if</strong> y == 0 {</p>
<p><strong>return</strong> 0, ErrDivByZero</p>
<p>}</p>
<p><strong>return</strong> x / y, nil</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>defer <strong>func</strong> () {</p>
<p>fmt.Println(recover())</p>
<p>}()</p>
<p><strong>switch</strong> z, err := div(10, 0); err {</p>
<p><strong>case</strong> nil:</p>
<p>println(z)</p>
<p><strong>case</strong> ErrDivByZero:</p>
<p>panic(err)</p>
<p>}</p>
<p>}</p>
<p>输出结果：</p>
<p>division <strong>by</strong> zero</p>
<p>Go实现类似 try catch 的异常处理</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>func <strong>Try</strong> (fun func(), handler <strong>func</strong> (interface{})) {</p>
<p>defer <strong>func</strong> () {</p>
<p><strong>if</strong> err := recover(); err != nil {</p>
<p>handler(err)</p>
<p>}</p>
<p>}()</p>
<p>fun()</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>Try(func() {</p>
<p>panic(&quot;test panic&quot;)</p>
<p>}, func(err <strong>interface</strong> {}) {</p>
<p>fmt.Println(err)</p>
<p>})</p>
<p>}</p>
<p>输出结果：</p>
<p>test panic</p>
<p>如何区别使用 panic 和 error 两种方式?</p>
<p>惯例是:导致关键流程出现不可修复性错误的使用 panic，其他使用 error。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>原子操作atomic包</title>
    <url>/2021/02/19/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic%E5%8C%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><h1 id="atomic"><a href="#atomic" class="headerlink" title="(atomic"></a>(atomic</h1><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h1 id=""><a href="#" class="headerlink" title=")"></a>)</h1><h3 id="原子操作-1"><a href="#原子操作-1" class="headerlink" title="原子操作"></a><strong>原子操作</strong></h3><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic提供。</p>
<h3 id="atomic-包"><a href="#atomic-包" class="headerlink" title="atomic** 包**"></a><strong>atomic**</strong> 包**</h3><table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>func LoadInt32(addr _int32) (val int32)</td>
<td></td>
</tr>
<tr>
<td>func LoadInt64(addr <code>_ int64) (val int64)\&amp;lt;br\&amp;gt;func LoadUint32(addr_uint32_) (val uint32)\&amp;lt;br\&amp;gt;func LoadUint64(addruint64) (val uint64)\&amp;lt;br\&amp;gt;func LoadUintptr(addr_uintptr_) (val uintptr)\&amp;lt;br\&amp;gt;func LoadPointer(addrunsafe.Pointer</code>) (val unsafe.Pointer)</td>
<td>读取操作</td>
</tr>
<tr>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>func StoreInt32(addr *int32, val int32)</td>
<td></td>
</tr>
<tr>
<td>func StoreInt64(addr *int64, val int64)</td>
<td></td>
</tr>
<tr>
<td>func StoreUint32(addr *uint32, val uint32)</td>
<td></td>
</tr>
<tr>
<td>func StoreUint64(addr *uint64, val uint64)</td>
<td></td>
</tr>
<tr>
<td>func StoreUintptr(addr *uintptr, val uintptr)</td>
<td></td>
</tr>
<tr>
<td>func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td>
<td>写入操作</td>
</tr>
<tr>
<td>func AddInt32(addr *int32, delta int32) (new int32)</td>
<td></td>
</tr>
<tr>
<td>func AddInt64(addr *int64, delta int64) (new int64)</td>
<td></td>
</tr>
<tr>
<td>func AddUint32(addr *uint32, delta uint32) (new uint32)</td>
<td></td>
</tr>
<tr>
<td>func AddUint64(addr *uint64, delta uint64) (new uint64)</td>
<td></td>
</tr>
<tr>
<td>func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td>
<td>修改操作</td>
</tr>
<tr>
<td>func SwapInt32(addr *int32, new int32) (old int32)</td>
<td></td>
</tr>
<tr>
<td>func SwapInt64(addr *int64, new int64) (old int64)</td>
<td></td>
</tr>
<tr>
<td>func SwapUint32(addr *uint32, new uint32) (old uint32)</td>
<td></td>
</tr>
<tr>
<td>func SwapUint64(addr *uint64, new uint64) (old uint64)</td>
<td></td>
</tr>
<tr>
<td>func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</td>
<td></td>
</tr>
<tr>
<td>func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td>
<td>交换操作</td>
</tr>
<tr>
<td>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</td>
<td></td>
</tr>
<tr>
<td>func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</td>
<td></td>
</tr>
<tr>
<td>func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</td>
<td></td>
</tr>
<tr>
<td>func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</td>
<td></td>
</tr>
<tr>
<td>func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</td>
<td></td>
</tr>
<tr>
<td>func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td>
<td>比较并交换操作</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p>
<p><strong>var</strong> x int64 <strong>var</strong> l sync.Mutex <strong>var</strong> wg sync.WaitGroup</p>
<p><em>//</em> _普通版加函数_func <strong>add</strong> () {</p>
<p><em>// x = x + 1</em></p>
<p>x++ <em>//</em> <em>等价于上面的操作</em></p>
<p>wg.Done()</p>
<p>}</p>
<p><em>//</em> _互斥锁版加函数_func <strong>mutexAdd</strong> () {</p>
<p>l.Lock()</p>
<p>x++</p>
<p>l.Unlock()</p>
<p>wg.Done()</p>
<p>}</p>
<p><em>//</em> _原子操作版加函数_func <strong>atomicAdd</strong> () {</p>
<p>atomic.AddInt64(&amp;x, 1)</p>
<p>wg.Done()</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>start := time.Now()</p>
<p><strong>for</strong> i := 0; i &amp;lt; 10000; i++ {</p>
<p>wg.Add(1)</p>
<p><em>// go add() //</em> <em>普通版 <strong>add</strong> 函数 不是并发安全的</em></p>
<p><em>// go mutexAdd() //</em> <em>加锁版 <strong>add</strong> 函数 是并发安全的，但是加锁性能开销大</em></p>
<p>go <strong>atomicAdd</strong> () <em>//</em> <em>原子操作版 <strong>add</strong> 函数 是并发安全，性能优于加锁版</em></p>
<p>}</p>
<p>wg. <strong>Wait</strong> ()</p>
<p>end := time.Now()</p>
<p>fmt.Println(x)</p>
<p>fmt.Println(end.Sub(start))</p>
<p>}</p>
<p>atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义error</title>
    <url>/2021/02/19/%E8%87%AA%E5%AE%9A%E4%B9%89error/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h1><h1 id="error"><a href="#error" class="headerlink" title="error"></a>error</h1><h2 id="抛异常和处理异常"><a href="#抛异常和处理异常" class="headerlink" title="抛异常和处理异常"></a><strong>抛异常和处理异常</strong></h2><p>###系统抛</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p><em>//</em> _系统抛_func <strong>test01</strong> () {</p>
<p>a := [5] <strong>int</strong> {0, 1, 2, 3, 4}</p>
<p>a[1] = 123</p>
<p>fmt.Println(a)</p>
<p><em>//a[10] = 11</em></p>
<p>index := 10</p>
<p>a[index] = 10</p>
<p>fmt.Println(a)</p>
<p>}</p>
<p>func <strong>getCircleArea</strong> (radius float32) (area float32) {</p>
<p><strong>if</strong> radius &amp;lt; 0 {</p>
<p><em>//</em> <em>自己抛</em></p>
<p>panic(&quot;半径不能为负&quot;)</p>
<p>}</p>
<p><strong>return</strong> 3.14 * radius * radius</p>
<p>}</p>
<p>func <strong>test02</strong> () {</p>
<p>getCircleArea(-5)</p>
<p>}</p>
<p>_//_func <strong>test03</strong> () {</p>
<p><em>//</em> <em>延时执行匿名函数</em></p>
<p><em>//</em> <em>延时到何时？（ <strong>1</strong> ）程序正常结束 （ <strong>2</strong> ）发生异常时</em></p>
<p>defer <strong>func</strong> () {</p>
<p><em>// recover()</em> <em>复活 恢复</em></p>
<p><em>//</em> <em>会返回程序为什么挂了</em></p>
<p><strong>if</strong> err := recover(); err != nil {</p>
<p>fmt.Println(err)</p>
<p>}</p>
<p>}()</p>
<p>getCircleArea(-5)</p>
<p>fmt.Println(&quot;这里有没有执行&quot;)</p>
<p>}</p>
<p>func <strong>test04</strong> () {</p>
<p>test03()</p>
<p>fmt.Println(&quot;test04&quot;)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>test04()</p>
<p>}</p>
<h3 id="返回异常"><a href="#返回异常" class="headerlink" title="返回异常"></a><strong>返回异常</strong></h3><p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;errors&quot;</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func <strong>getCircleArea</strong> (radius float32) (area float32, err error) {</p>
<p><strong>if</strong> radius &amp;lt; 0 {</p>
<p><em>//</em> <em>构建个异常对象</em></p>
<p>err = errors.New(&quot;半径不能为负&quot;)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>area = 3.14 * radius * radius</p>
<p><strong>return</strong></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>area, err := getCircleArea(-5)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(err)</p>
<p>} <strong>else</strong> {</p>
<p>fmt.Println(area)</p>
<p>}</p>
<p>}</p>
<h3 id="自定义-error-："><a href="#自定义-error-：" class="headerlink" title="自定义** error **："></a><strong>自定义**</strong> error <strong>**：</strong></h3><p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>&quot;os&quot;</p>
<p>&quot;time&quot;)</p>
<p>type PathError <strong>struct</strong> {</p>
<p>path <strong>string</strong></p>
<p>op <strong>string</strong></p>
<p>createTime <strong>string</strong></p>
<p>message <strong>string</strong></p>
<p>}</p>
<p>func (p *PathError) Error() <strong>string</strong> {</p>
<p><strong>return</strong> fmt.Sprintf(&quot;path=%s \nop=%s \ncreateTime=%s \nmessage=%s&quot;, p.path,</p>
<p>p.op, p.createTime, p.message)</p>
<p>}</p>
<p>func <strong>Open</strong> (filename <strong>string</strong> ) error {</p>
<p>file, err := os.Open(filename)</p>
<p><strong>if</strong> err != nil {</p>
<p><strong>return</strong> &amp;PathError{</p>
<p>path: filename,</p>
<p>op: &quot;read&quot;,</p>
<p>message: err.Error(),</p>
<p>createTime: fmt.Sprintf(&quot;%v&quot;, time.Now()),</p>
<p>}</p>
<p>}</p>
<p>defer file.Close()</p>
<p><strong>return</strong> nil</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>err := Open(&quot;/Users/5lmh/Desktop/go/src/test.txt&quot;)</p>
<p><strong>switch</strong> v := err.(type) {</p>
<p><strong>case</strong> *PathError:</p>
<p>fmt.Println(&quot;get path error,&quot;, v)</p>
<p><strong>default</strong> :</p>
<p>}</p>
<p>}</p>
<p>输出结果：</p>
<p>get path error, path=/Users/pprof/Desktop/go/src/test.txt</p>
<p>op= <strong>read</strong></p>
<p>createTime=2018-04-0511:25:17.331915 +0800 CST <strong>m</strong> =+0.000441790</p>
<p>message= <strong>open</strong> /Users/pprof/Desktop/go/src/test.txt: <strong>no</strong> such file <strong>or</strong> directory</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>条件语句switch</title>
    <url>/2021/01/09/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5switch/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h1 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h1><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch  语句"></a><strong>switch</strong>  <strong>语句</strong></h3><p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止。<br> Golang switch 分支表达式可以是任意类型，不限于常量。可省略 break，默认自动终止。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h4><p>Go 编程语言中 switch 语句的语法如下：</p>
<p><strong>switch</strong> var1 {</p>
<p><strong>case</strong> val1:</p>
<p>…</p>
<p><strong>case</strong> val2:</p>
<p>…</p>
<p><strong>default</strong> :</p>
<p>…</p>
<p>}</p>
<p>变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。<br>您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例** :**"></a><strong>实例**</strong> :**</h4><p>package main</p>
<p>import &quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p><em>/*</em> <em>定义局部变量</em> <em>*/</em></p>
<p><strong>var</strong> grade <strong>string</strong> = &quot;B&quot;</p>
<p><strong>var</strong> marks <strong>int</strong> = 90</p>
<p><strong>switch</strong> marks {</p>
<p><strong>case</strong> 90: grade = &quot;A&quot;</p>
<p><strong>case</strong> 80: grade = &quot;B&quot;</p>
<p><strong>case</strong> 50,60,70 : grade = &quot;C&quot;</p>
<p><strong>default</strong> : grade = &quot;D&quot;</p>
<p>}</p>
<p><strong>switch</strong> {</p>
<p><strong>case</strong> grade == &quot;A&quot; :</p>
<p>fmt.Printf(&quot;优秀!\n&quot; )</p>
<p><strong>case</strong> grade == &quot;B&quot;, grade == &quot;C&quot; :</p>
<p>fmt.Printf(&quot;良好\n&quot; )</p>
<p><strong>case</strong> grade == &quot;D&quot; :</p>
<p>fmt.Printf(&quot;及格\n&quot; )</p>
<p><strong>case</strong> grade == &quot;F&quot;:</p>
<p>fmt.Printf(&quot;不及格\n&quot; )</p>
<p><strong>default</strong> :</p>
<p>fmt.Printf(&quot;差\n&quot; )</p>
<p>}</p>
<p>fmt.Printf(&quot;你的等级是 %s\n&quot;, grade )</p>
<p>}</p>
<p>以上代码执行结果为：</p>
<p>优秀!</p>
<p>你的等级是 A</p>
<h3 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a><strong>Type Switch</strong></h3><p>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</p>
<h4 id="Type-Switch-语法格式如下："><a href="#Type-Switch-语法格式如下：" class="headerlink" title="Type Switch  语法格式如下："></a><strong>Type Switch</strong>  <strong>语法格式如下：</strong></h4><p>switch x.(type){</p>
<p><strong>case</strong> type:</p>
<p>statement(s)</p>
<p><strong>case</strong> type:</p>
<p>statement(s)</p>
<p>/* 你可以定义任意个数的 <strong>case</strong> */</p>
<p>default: /* 可选 */</p>
<p>statement(s)</p>
<p>}</p>
<h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a><strong>实例：</strong></h4><p>package main</p>
<p>import &quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> x <strong>interface</strong> {}</p>
<p><em>//__写法一：</em></p>
<p><strong>switch</strong> i := x.(type) { <em>//</em> <em>带初始化语句</em></p>
<p><strong>case</strong> nil:</p>
<p>fmt.Printf(&quot; x 的类型 :%T\r\n&quot;, i)</p>
<p><strong>case**</strong> int**:</p>
<p>fmt.Printf(&quot;x 是 int 型&quot;)</p>
<p><strong>case</strong> float64:</p>
<p>fmt.Printf(&quot;x 是 float64 型&quot;)</p>
<p><strong>case**</strong> func<strong>(</strong>int**) float64:</p>
<p>fmt. <strong>Printf</strong> (&quot;x 是 func(int) 型&quot;)</p>
<p><strong>case**</strong> bool <strong>,</strong> string**:</p>
<p>fmt. <strong>Printf</strong> (&quot;x 是 bool 或 string 型&quot;)</p>
<p><strong>default</strong> :</p>
<p>fmt. <strong>Printf</strong> (&quot;未知型&quot;)</p>
<p>}</p>
<p><em>//__写法二</em></p>
<p><strong>var</strong> j = 0</p>
<p><strong>switch</strong> j {</p>
<p><strong>case</strong> 0:</p>
<p><strong>case</strong> 1:</p>
<p>fmt.Println(&quot;1&quot;)</p>
<p><strong>case</strong> 2:</p>
<p>fmt.Println(&quot;2&quot;)</p>
<p><strong>default</strong> :</p>
<p>fmt.Println(&quot;def&quot;)</p>
<p>}</p>
<p><em>//__写法三</em></p>
<p><strong>var</strong> k = 0</p>
<p><strong>switch</strong> k {</p>
<p><strong>case</strong> 0:</p>
<p>println(&quot;fallthrough&quot;)</p>
<p>fallthrough</p>
<p><em>/*</em></p>
<p><em>Go <strong>的</strong> switch__非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；</em></p>
<p><em>而如果 <strong>switch</strong> 没有表达式，它会匹配 <strong>true</strong> 。</em></p>
<p><em>Go <strong>里面</strong> switch <strong>默认相当于每个</strong> case <strong>最后带有</strong> break__，</em></p>
<p><em>匹配成功后不会自动向下执行其他 <strong>case</strong> ，而是跳出整个__switch,</em></p>
<p><em>但是可以使用 <strong>fallthrough</strong> 强制执行后面的 <strong>case</strong> 代码。</em></p>
<p><em>*/</em></p>
<p><strong>case</strong> 1:</p>
<p>fmt.Println(&quot;1&quot;)</p>
<p><strong>case</strong> 2:</p>
<p>fmt.Println(&quot;2&quot;)</p>
<p><strong>default</strong> :</p>
<p>fmt.Println(&quot;def&quot;)</p>
<p>}</p>
<p><em>//__写法三</em></p>
<p><strong>var</strong> m = 0</p>
<p><strong>switch</strong> m {</p>
<p><strong>case</strong> 0, 1:</p>
<p>fmt.Println(&quot;1&quot;)</p>
<p><strong>case</strong> 2:</p>
<p>fmt.Println(&quot;2&quot;)</p>
<p><strong>default</strong> :</p>
<p>fmt.Println(&quot;def&quot;)</p>
<p>}</p>
<p><em>//__写法四</em></p>
<p><strong>var</strong> n = 0</p>
<p><strong>switch</strong> { <em>//__省略条件表达式，可当</em> <em>if…else if…else</em></p>
<p><strong>case</strong> n &amp;gt; 0 &amp;&amp; n &amp;lt; 10:</p>
<p>fmt.Println(&quot;i &amp;gt; 0 and i &amp;lt; 10&quot;)</p>
<p><strong>case</strong> n &amp;gt; 10 &amp;&amp; n &amp;lt; 20:</p>
<p>fmt.Println(&quot;i &amp;gt; 10 and i &amp;lt; 20&quot;)</p>
<p><strong>default</strong> :</p>
<p>fmt.Println(&quot;def&quot;)</p>
<p>}</p>
<p>}</p>
<p>以上代码执行结果为：</p>
<p>x 的类型 :&amp;lt;nil&amp;gt;</p>
<p>fallthrough</p>
<p>1</p>
<p>1</p>
<p><strong>def</strong></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体</title>
    <url>/2021/01/09/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go语言中没有&quot;类&quot;的概念，也不支持&quot;类&quot;的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p>
<h2 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a><strong>类型别名和自定义类型</strong></h2><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a><strong>自定义类型</strong></h3><p>在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型，Go语言中可以使用type关键字来定义自定义类型。</p>
<p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p>
<p><em>// <strong>将</strong> MyInt <strong>定义为</strong> int__类型</em></p>
<p>type MyInt <strong>int</strong></p>
<p>通过Type关键字的定义，MyInt就是一种新的类型，它具有int的特性。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a><strong>类型别名</strong></h3><p>类型别名是Go1.9版本添加的新功能。</p>
<p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p>
<p>type TypeAlias = Type</p>
<p>我们之前见过的rune和byte就是类型别名，他们的定义如下：</p>
<p>type byte = uint8</p>
<p>type rune = int32</p>
<h3 id="类型定义和类型别名的区别"><a href="#类型定义和类型别名的区别" class="headerlink" title="类型定义和类型别名的区别"></a><strong>类型定义和类型别名的区别</strong></h3><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p>
<p><em>//__类型定义</em></p>
<p>type NewInt <strong>int</strong></p>
<p><em>//__类型别名</em></p>
<p>type MyInt = <strong>int</strong></p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> a NewInt</p>
<p><strong>var</strong> b MyInt</p>
<p>fmt.Printf(&quot;type of a:%T\n&quot;, a) <em>//type of a:main.NewInt</em></p>
<p>fmt.Printf(&quot;type of b:%T\n&quot;, b) <em>//type of b:int</em></p>
<p>}</p>
<p>结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。b的类型是int。MyInt类型只会在代码中存在，编译完成时并不会有MyInt类型。</p>
<h2 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a><strong>结构体</strong></h2><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。</p>
<p>Go语言中通过struct来实现面向对象。</p>
<h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a><strong>结构体的定义</strong></h3><p>使用type和struct关键字来定义结构体，具体代码格式如下：</p>
<p>type类型名 struct {</p>
<p>字段名 字段类型</p>
<p>字段名 字段类型</p>
<p>…</p>
<p>}</p>
<p>其中：</p>
<p>1.类型名：标识自定义结构体的名称，在同一个包内不能重复。</p>
<p>2.字段名：表示结构体字段名。结构体中的字段名必须唯一。</p>
<p>3.字段类型：表示结构体字段的具体类型。</p>
<p>举个例子，我们定义一个Person（人）结构体，代码如下：</p>
<p>type person <strong>struct</strong> {</p>
<p>name string</p>
<p>city string</p>
<p>age int8</p>
<p>}</p>
<p>同样类型的字段也可以写在一行，</p>
<p>type person1 <strong>struct</strong> {</p>
<p>name, city string</p>
<p>age int8</p>
<p>}</p>
<p>这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了。</p>
<p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p>
<h3 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a><strong>结构体实例化</strong></h3><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p>
<p>结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。</p>
<p><strong>var</strong> 结构体实例 结构体类型</p>
<h3 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a><strong>基本实例化</strong></h3><p>type person <strong>struct</strong> {</p>
<p>name <strong>string</strong></p>
<p>city <strong>string</strong></p>
<p>age int8</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> p1 person</p>
<p>p1.name = &quot;pprof.cn&quot;</p>
<p>p1.city = &quot;北京&quot;</p>
<p>p1.age = 18</p>
<p>fmt.Printf(&quot;p1=%v\n&quot;, p1) <em>//p1={pprof.cn</em> <em>北京</em> <em>18}</em></p>
<p>fmt.Printf(&quot;p1=%#v\n&quot;, p1) <em>//p1=main.person{name:&quot;pprof.cn&quot;, city:&quot; <strong>北京</strong>&quot;, age:18}</em></p>
<p>}</p>
<p>我们通过.来访问结构体的字段（成员变量）,例如p1.name和p1.age等。</p>
<h2 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a><strong>匿名结构体</strong></h2><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;)</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> user <strong>struct</strong> {Name <strong>string</strong> ; Age <strong>int</strong> }</p>
<p>user.Name = &quot;pprof.cn&quot;</p>
<p>user.Age = 18</p>
<p>fmt.Printf(&quot;%#v\n&quot;, user)</p>
<p>}</p>
<h3 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a><strong>创建指针类型结构体</strong></h3><p>我们还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p>
<p><strong>var</strong> p2 = <strong>new</strong> (person)</p>
<p>fmt.Printf(&quot;%T\n&quot;, p2) <em>//*main.person</em></p>
<p>fmt.Printf(&quot;p2=%#v\n&quot;, p2) <em>//p2=&amp;main.person{name:&quot;&quot;, city:&quot;&quot;, age:0}</em></p>
<p>从打印的结果中我们可以看出p2是一个结构体指针。</p>
<p>需要注意的是在Go语言中支持对结构体指针直接使用.来访问结构体的成员。</p>
<p>var p2 = <strong>new</strong> (person)</p>
<p>p2.name = &quot;测试&quot;</p>
<p>p2.age = 18</p>
<p>p2.city = &quot;北京&quot;</p>
<p>fmt.Printf(&quot;p2=%#v\n&quot;, p2) //p2=&amp;main.person{name:&quot;测试&quot;, city:&quot;北京&quot;, age:18}</p>
<h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a><strong>取结构体的地址实例化</strong></h3><p>使用&amp;对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。</p>
<p>p3 := &amp;person{}</p>
<p>fmt.Printf(&quot;%T\n&quot;, p3) //*main.person</p>
<p>fmt.Printf(&quot;p3=%#v\n&quot;, p3) //p3=&amp;main.person{name:&quot;&quot;, city:&quot;&quot;, age:0}</p>
<p>p3.name = &quot;博客&quot;</p>
<p>p3.age = 30</p>
<p>p3.city = &quot;成都&quot;</p>
<p>fmt.Printf(&quot;p3=%#v\n&quot;, p3) //p3=&amp;main.person{name:&quot;博客&quot;, city:&quot;成都&quot;, age:30}</p>
<p>p3.name = &quot;博客&quot;其实在底层是(*p3).name = &quot;博客&quot;，这是Go语言帮我们实现的语法糖。</p>
<h3 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a><strong>结构体初始化</strong></h3><p>type person <strong>struct</strong> {</p>
<p>name <strong>string</strong></p>
<p>city <strong>string</strong></p>
<p>age int8</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> p4 person</p>
<p>fmt.Printf(&quot;p4=%#v\n&quot;, p4) <em>//p4=main.person{name:&quot;&quot;, city:&quot;&quot;, age:0}</em></p>
<p>}</p>
<h3 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a><strong>使用键值对初始化</strong></h3><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p>
<p>p5 := person{</p>
<p>name: &quot;pprof.cn&quot;,</p>
<p>city: &quot;北京&quot;,</p>
<p>age: 18,</p>
<p>}</p>
<p>fmt.Printf(&quot;p5=%#v\n&quot;, p5) //p5=main.person{name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18}</p>
<p>也可以对结构体指针进行键值对初始化，例如：</p>
<p>p6 := &amp;person{</p>
<p>name: &quot;pprof.cn&quot;,</p>
<p>city: &quot;北京&quot;,</p>
<p>age: 18,</p>
<p>}</p>
<p>fmt.Printf(&quot;p6=%#v\n&quot;, p6) //p6=&amp;main.person{name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18}</p>
<p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p>
<p>p7 := &amp;person{</p>
<p>city: &quot;北京&quot;,</p>
<p>}</p>
<p>fmt.Printf(&quot;p7=%#v\n&quot;, p7) //p7=&amp;main.person{name:&quot;&quot;, city:&quot;北京&quot;, age:0}</p>
<h3 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a><strong>使用值的列表初始化</strong></h3><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p>
<p>p8 := &amp;person{</p>
<p>&quot;pprof.cn&quot;,</p>
<p>&quot;北京&quot;,</p>
<p>18,</p>
<p>}</p>
<p>fmt.Printf(&quot;p8=%#v\n&quot;, p8) //p8=&amp;main.person{name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18}</p>
<p>使用这种格式初始化时，需要注意：</p>
<p>1.必须初始化结构体的所有字段。</p>
<p>2.初始值的填充顺序必须与字段在结构体中的声明顺序一致。</p>
<p>3.该方式不能和键值初始化方式混用。</p>
<h3 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a><strong>结构体内存布局</strong></h3><p>type test struct {</p>
<p>a int8</p>
<p>b int8</p>
<p>c int8</p>
<p>d int8</p>
<p>}</p>
<p>n := test{</p>
<p>1, 2, 3, 4,</p>
<p>}</p>
<p>fmt.Printf(&quot;n.a %p\n&quot;, &amp;n.a)</p>
<p>fmt.Printf(&quot;n.b %p\n&quot;, &amp;n.b)</p>
<p>fmt.Printf(&quot;n.c %p\n&quot;, &amp;n.c)</p>
<p>fmt.Printf(&quot;n.d %p\n&quot;, &amp;n.d)</p>
<p>输出：</p>
<p><strong>n</strong>.a 0 <strong>xc0000a0060</strong></p>
<p><strong>n</strong>.b 0 <strong>xc0000a0061</strong></p>
<p><strong>n</strong>.c 0 <strong>xc0000a0062</strong></p>
<p><strong>n</strong>.d 0 <strong>xc0000a0063</strong></p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a><strong>面试题</strong></h3><p>type student <strong>struct</strong> {</p>
<p>name string</p>
<p>age <strong>int</strong></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>m := make(map[string]*student)</p>
<p>stus := []student{</p>
<p>{name: &quot;pprof.cn&quot;, age: 18},</p>
<p>{name: &quot;测试&quot;, age: 23},</p>
<p>{name: &quot;博客&quot;, age: 28},</p>
<p>}</p>
<p><strong>for</strong> _, stu := range stus {</p>
<p>m[stu.name] = &amp;stu</p>
<p>}</p>
<p><strong>for</strong> k, v := range m {</p>
<p>fmt.Println(k, &quot;=&amp;gt;&quot;, v.name)</p>
<p>}</p>
<p>}</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h3><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p>
<p>func <strong>newPerson</strong> (name, city string, age int8) *person {</p>
<p><strong>return</strong> &amp;person{</p>
<p>name: name,</p>
<p>city: city,</p>
<p>age: age,</p>
<p>}</p>
<p>}</p>
<p>调用构造函数</p>
<p>p9 := newPerson(&quot;pprof.cn&quot;, &quot;测试&quot;, 90)</p>
<p>fmt.Printf(&quot;%#v\n&quot;, p9)</p>
<h3 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a><strong>方法和接收者</strong></h3><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。</p>
<p>方法的定义格式如下：</p>
<p>func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {</p>
<p>函数体</p>
<p>}</p>
<p>其中，</p>
<p>1.接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是 <strong>self</strong> 、 <strong>this</strong> 之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。</p>
<p>2.接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</p>
<p>3.方法名、参数列表、返回参数：具体格式与函数定义相同。</p>
<p>举个例子：</p>
<p><em>//Person</em> <em>结构体</em></p>
<p>type Person <strong>struct</strong> {</p>
<p>name <strong>string</strong></p>
<p>age int8</p>
<p>}</p>
<p><em>//NewPerson</em> _构造函数_func <strong>NewPerson</strong> (name <strong>string</strong> , age int8) *Person {</p>
<p><strong>return</strong> &amp;Person{</p>
<p>name: name,</p>
<p>age: age,</p>
<p>}</p>
<p>}</p>
<p><em>//Dream Person__做梦的方法</em></p>
<p>func (p Person) Dream() {</p>
<p>fmt.Printf(&quot;%s的梦想是学好Go语言！\n&quot;, p.name)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>p1 := NewPerson(&quot;测试&quot;, 25)</p>
<p>p1.Dream()</p>
<p>}</p>
<p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p>
<h3 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a><strong>指针类型的接收者</strong></h3><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如我们为Person添加一个SetAge方法，来修改实例变量的年龄。</p>
<p><em>// SetAge</em> <em>设置 <strong>p</strong> 的年龄</em></p>
<p><em>//</em> <em>使用指针接收者</em></p>
<p>func (p *Person) SetAge(newAge int8) {</p>
<p>p.age = newAge</p>
<p>}</p>
<p>调用该方法：</p>
<p>func <strong>main</strong> () {</p>
<p>p1 := NewPerson(&quot;测试&quot;, 25)</p>
<p>fmt.Println(p1.age) <em>// 25</em></p>
<p>p1.SetAge(30)</p>
<p>fmt.Println(p1.age) <em>// 30</em></p>
<p>}</p>
<h3 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a><strong>值类型的接收者</strong></h3><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p>
<p><em>// SetAge2</em> <em>设置 <strong>p</strong> 的年龄__//</em> <em>使用值接收者</em></p>
<p>func (p Person) SetAge2(newAge int8) {</p>
<p>p.age = newAge</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>p1 := NewPerson(&quot;测试&quot;, 25)</p>
<p>p1.Dream()</p>
<p>fmt.Println(p1.age) <em>// 25</em></p>
<p>p1.SetAge2(30) <em>// (*p1).SetAge2(30)</em></p>
<p>fmt.Println(p1.age) <em>// 25</em></p>
<p>}</p>
<h3 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a><strong>什么时候应该使用指针类型接收者</strong></h3><p>1.需要修改接收者中的值</p>
<p>2.接收者是拷贝代价比较大的大对象</p>
<p>3.保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</p>
<h3 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a><strong>任意类型添加方法</strong></h3><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p>
<p><em>//MyInt</em> <em>将 <strong>int</strong> 定义为自定义 <strong>MyInt</strong> 类型</em></p>
<p>type MyInt <strong>int</strong></p>
<p><em>//SayHello</em> <em>为 <strong>MyInt</strong> 添加一个 <strong>SayHello</strong> 的方法</em></p>
<p>func (m MyInt) SayHello() {</p>
<p>fmt.Println(&quot;Hello, 我是一个int。&quot;)</p>
<p>}func <strong>main</strong> () {</p>
<p><strong>var</strong> m1 MyInt</p>
<p>m1.SayHello() <em>//Hello,</em> <em>我是一个 <strong>int</strong> 。</em></p>
<p>m1 = 100</p>
<p>fmt.Printf(&quot;%#v %T\n&quot;, m1, m1) <em>//100 main.MyInt</em></p>
<p>}</p>
<p>注意事项： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p>
<h3 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a><strong>结构体的匿名字段</strong></h3><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p>
<p><em>//Person</em> <em>结构体 <strong>Person</strong> 类型</em></p>
<p>type Person <strong>struct</strong> {</p>
<p>string</p>
<p><strong>int</strong></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>p1 := Person{</p>
<p>&quot;pprof.cn&quot;,</p>
<p>18,</p>
<p>}</p>
<p>fmt.Printf(&quot;%#v\n&quot;, p1) <em>//main.Person{string:&quot;pprof.cn&quot;, int:18}</em></p>
<p>fmt.Println(p1.string, p1. <strong>int</strong> ) <em>//pprof.cn 18</em></p>
<p>}</p>
<p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p>
<h3 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a><strong>嵌套结构体</strong></h3><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p>
<p><em>//Address</em> <em>地址结构体</em></p>
<p>type Address <strong>struct</strong> {</p>
<p>Province string</p>
<p>City string</p>
<p>}</p>
<p><em>//User</em> <em>用户结构体</em></p>
<p>type User <strong>struct</strong> {</p>
<p>Name string</p>
<p>Gender string</p>
<p>Address Address</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>user1 := User{</p>
<p>Name: &quot;pprof&quot;,</p>
<p>Gender: &quot;女&quot;,</p>
<p>Address: Address{</p>
<p>Province: &quot;黑龙江&quot;,</p>
<p>City: &quot;哈尔滨&quot;,</p>
<p>},</p>
<p>}</p>
<p>fmt.Printf(&quot;user1=%#v\n&quot;, user1)<em>//user1=main.User{Name:&quot;pprof&quot;, Gender:&quot; <strong>女</strong>&quot;, Address:main.Address{Province:&quot; <strong>黑龙江</strong>&quot;, City:&quot; <strong>哈尔滨</strong>&quot;}}</em></p>
<p>}</p>
<h3 id="嵌套匿名结构体"><a href="#嵌套匿名结构体" class="headerlink" title="嵌套匿名结构体"></a><strong>嵌套匿名结构体</strong></h3><p><em>//Address</em> <em>地址结构体</em></p>
<p>type Address <strong>struct</strong> {</p>
<p>Province <strong>string</strong></p>
<p>City <strong>string</strong></p>
<p>}</p>
<p><em>//User</em> <em>用户结构体</em></p>
<p>type User <strong>struct</strong> {</p>
<p>Name <strong>string</strong></p>
<p>Gender <strong>string</strong></p>
<p>Address <em>//__匿名结构体</em></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> user2 User</p>
<p>user2.Name = &quot;pprof&quot;</p>
<p>user2.Gender = &quot;女&quot;</p>
<p>user2.Address.Province = &quot;黑龙江&quot;<em>// <strong>通过匿名结构体</strong>.__字段名访问</em></p>
<p>user2.City = &quot;哈尔滨&quot;<em>//__直接访问匿名结构体的字段名</em></p>
<p>fmt.Printf(&quot;user2=%#v\n&quot;, user2) <em>//user2=main.User{Name:&quot;pprof&quot;, Gender:&quot; <strong>女</strong>&quot;, Address:main.Address{Province:&quot; <strong>黑龙江</strong>&quot;, City:&quot; <strong>哈尔滨</strong>&quot;}}</em></p>
<p>}</p>
<p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</p>
<h3 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a><strong>嵌套结构体的字段名冲突</strong></h3><p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p>
<p><em>//Address</em> <em>地址结构体</em></p>
<p>type Address <strong>struct</strong> {</p>
<p>Province <strong>string</strong></p>
<p>City <strong>string</strong></p>
<p>CreateTime <strong>string</strong></p>
<p>}</p>
<p><em>//Email</em> <em>邮箱结构体</em></p>
<p>type Email <strong>struct</strong> {</p>
<p>Account <strong>string</strong></p>
<p>CreateTime <strong>string</strong></p>
<p>}</p>
<p><em>//User</em> <em>用户结构体</em></p>
<p>type User <strong>struct</strong> {</p>
<p>Name <strong>string</strong></p>
<p>Gender <strong>string</strong></p>
<p>Address</p>
<p>Email</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> user3 User</p>
<p>user3.Name = &quot;pprof&quot;</p>
<p>user3.Gender = &quot;女&quot;</p>
<p><em>// user3.CreateTime = &quot;2019&quot; //ambiguous selector user3.CreateTime</em></p>
<p>user3.Address.CreateTime = &quot;2000&quot;<em>// <strong>指定</strong> Address <strong>结构体中的</strong> CreateTime</em></p>
<p>user3.Email.CreateTime = &quot;2000&quot;<em>// <strong>指定</strong> Email <strong>结构体中的</strong> CreateTime</em></p>
<p>}</p>
<h3 id="结构体的-quot-继承-quot"><a href="#结构体的-quot-继承-quot" class="headerlink" title="结构体的&quot;继承&quot;"></a><strong>结构体的&quot;继承&quot;</strong></h3><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p>
<p><em>//Animal</em> <em>动物</em></p>
<p>type Animal <strong>struct</strong> {</p>
<p>name string</p>
<p>}</p>
<p>func (a *Animal) move() {</p>
<p>fmt.Printf(&quot;%s会动！\n&quot;, a.name)</p>
<p>}</p>
<p><em>//Dog</em> <em>狗</em></p>
<p>type Dog <strong>struct</strong> {</p>
<p>Feet int8</p>
<p>*Animal <em>//__通过嵌套匿名结构体实现继承</em></p>
<p>}</p>
<p>func (d *Dog) wang() {</p>
<p>fmt.Printf(&quot;%s会汪汪汪~\n&quot;, d.name)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>d1 := &amp;Dog{</p>
<p>Feet: 4,</p>
<p>Animal: &amp;Animal{ <em>//__注意嵌套的是结构体指针</em></p>
<p>name: &quot;乐乐&quot;,</p>
<p>},</p>
<p>}</p>
<p>d1.wang() <em>// <strong>乐乐会汪汪汪</strong> ~</em></p>
<p>d1.move() <em>//__乐乐会动！</em></p>
<p>}</p>
<h3 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a><strong>结构体字段的可见性</strong></h3><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p>
<h3 id="结构体与-JSON-序列化"><a href="#结构体与-JSON-序列化" class="headerlink" title="结构体与** JSON **序列化"></a><strong>结构体与**</strong> JSON <strong>**序列化</strong></h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号&quot;&quot;包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。</p>
<p><em>//Student</em> <em>学生</em></p>
<p>type Student <strong>struct</strong> {</p>
<p>ID <strong>int</strong></p>
<p>Gender <strong>string</strong></p>
<p>Name <strong>string</strong></p>
<p>}</p>
<p><em>//Class</em> <em>班级</em></p>
<p>type Class <strong>struct</strong> {</p>
<p>Title <strong>string</strong></p>
<p>Students []*Student</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>c := &amp;Class{</p>
<p>Title: &quot;101&quot;,</p>
<p>Students: make([]*Student, 0, 200),</p>
<p>}</p>
<p><strong>for</strong> i := 0; i &amp;lt; 10; i++ {</p>
<p>stu := &amp;Student{</p>
<p>Name: fmt.Sprintf(&quot;stu%02d&quot;, i),</p>
<p>Gender: &quot;男&quot;,</p>
<p>ID: i,</p>
<p>}</p>
<p>c.Students = append(c.Students, stu)</p>
<p>}</p>
<p><em>//JSON <strong>序列化：结构体</strong> –&amp;gt;JSON__格式的字符串</em></p>
<p>data, err := json.Marshal(c)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;json marshal failed&quot;)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>fmt.Printf(&quot;json:%s\n&quot;, data)</p>
<p><em>//JSON <strong>反序列化：</strong> JSON <strong>格式的字符串</strong> –&amp;gt;__结构体</em></p>
<p>str := <code>{&amp;quot;Title&amp;quot;:&amp;quot;101&amp;quot;,&amp;quot;Students&amp;quot;:[{&amp;quot;ID&amp;quot;:0,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu00&amp;quot;},{&amp;quot;ID&amp;quot;:1,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu01&amp;quot;},{&amp;quot;ID&amp;quot;:2,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu02&amp;quot;},{&amp;quot;ID&amp;quot;:3,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu03&amp;quot;},{&amp;quot;ID&amp;quot;:4,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu04&amp;quot;},{&amp;quot;ID&amp;quot;:5,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu05&amp;quot;},{&amp;quot;ID&amp;quot;:6,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu06&amp;quot;},{&amp;quot;ID&amp;quot;:7,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu07&amp;quot;},{&amp;quot;ID&amp;quot;:8,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu08&amp;quot;},{&amp;quot;ID&amp;quot;:9,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu09&amp;quot;}]}</code></p>
<p>c1 := &amp;Class{}</p>
<p>err = json.Unmarshal([] <strong>byte</strong> (str), c1)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;json unmarshal failed!&quot;)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>fmt.Printf(&quot;%#v\n&quot;, c1)</p>
<p>}</p>
<h3 id="结构体标签（-Tag-）"><a href="#结构体标签（-Tag-）" class="headerlink" title="结构体标签（** Tag **）"></a><strong>结构体标签（**</strong> Tag <strong>**）</strong></h3><p>Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。</p>
<p>Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p>
<p><code>key1:&amp;quot;value1&amp;quot; key2:&amp;quot;value2&amp;quot;</code></p>
<p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 注意事项： 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p>
<p>例如我们为Student结构体的每个字段定义json序列化时使用的Tag：</p>
<p><em>//Student</em> <em>学生</em></p>
<p>type Student <strong>struct</strong> {</p>
<p>ID <strong>int</strong> <code>json:&amp;quot;id&amp;quot;</code> <em>// <strong>通过指定</strong> tag <strong>实现</strong> json <strong>序列化该字段时的</strong> key</em></p>
<p>Gender string_//json <strong>序列化是默认使用字段名作为</strong> key_</p>
<p>name string_// <strong>私有不能被</strong> json__包访问_</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>s1 := Student{</p>
<p>ID: 1,</p>
<p>Gender: &quot;女&quot;,</p>
<p>name: &quot;pprof&quot;,</p>
<p>}</p>
<p>data, err := json.Marshal(s1)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;json marshal failed!&quot;)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>fmt.Printf(&quot;json str:%s\n&quot;, data) <em>//json str:{&quot;id&quot;:1,&quot;Gender&quot;:&quot; <strong>女</strong>&quot;}</em></p>
<p>}</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>map底层</title>
    <url>/2021/01/09/map%E5%BA%95%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h3 id="什么是-Map"><a href="#什么是-Map" class="headerlink" title="什么是** Map**"></a><strong>什么是**</strong> Map**</h3><h4 id="key-，-value-存储"><a href="#key-，-value-存储" class="headerlink" title="key** ， value 存储**"></a><strong>key**</strong> ， <strong><strong>value</strong></strong> 存储**</h4><p>最通俗的话说Map是一种通过key来获取value的一个数据结构，其底层存储方式为数组，在存储时key不能重复，当key重复时，value进行覆盖，我们通过key进行hash运算（可以简单理解为把key转化为一个整形数字）然后对数组的长度取余，得到key存储在数组的哪个下标位置，最后将key和value组装为一个结构体，放入数组下标处，看下图：</p>
<p><strong>length</strong> = len(array) = 4</p>
<p>hashkey1 = hash(xiaoming) = 4</p>
<p>index1 = hashkey1% <strong>length</strong> = 0</p>
<p>hashkey2 = hash(xiaoli) = 6</p>
<p>index2 = hashkey2% <strong>length</strong> = 2</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-10ba63a_html_3212b13f256df8c3.png"  alt=""></p>
<h4 id="hash-冲突"><a href="#hash-冲突" class="headerlink" title="hash** 冲突**"></a><strong>hash**</strong> 冲突**</h4><p>如上图所示，数组一个下标处只能存储一个元素，也就是说一个数组下标只能存储一对key，value, hashkey(xiaoming)=4占用了下标0的位置，假设我们遇到另一个key，hashkey(xiaowang)也是4，这就是hash冲突（不同的key经过hash之后得到的值一样），那么key=xiaowang的怎么存储？<br> hash冲突的常见解决方法</p>
<p>开放定址法：也就是说当我们存储一个key，value时，发现hashkey(key)的下标已经被别key占用，那我们在这个数组中空间中重新找一个没被占用的存储这个冲突的key，那么没被占用的有很多，找哪个好呢？常见的有线性探测法，线性补偿探测法，随机探测法，这里我们主要说一下线性探测法</p>
<p>线性探测，字面意思就是按照顺序来，从冲突的下标处开始往后探测，到达数组末尾时，从数组开始处探测，直到找到一个空位置存储这个key，当数组都找不到的情况下回扩容（事实上当数组容量快满的时候就会扩容了）；查找某一个key的时候，找到key对应的下标，比较key是否相等，如果相等直接取出来，否则按照顺寻探测直到碰到一个空位置，说明key不存在。如下图：首先存储key=xiaoming在下标0处，当存储key=xiaowang时，hash冲突了，按照线性探测，存储在下标1处，（红色的线是冲突或者下标已经被占用了） 再者key=xiaozhao存储在下标4处，当存储key=xiaoliu是，hash冲突了，按照线性探测，从头开始，存储在下标2处 （黄色的是冲突或者下标已经被占用了）</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-10ba63a_html_4b339be74eba8213.png"  alt=""></p>
<p>拉链法：何为拉链，简单理解为链表，当key的hash冲突时，我们在冲突位置的元素上形成一个链表，通过指针互连接，当查找时，发现key冲突，顺着链表一直往下找，直到链表的尾节点，找不到则返回空，如下图：</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-10ba63a_html_e11ce40122d342b4.png"  alt=""></p>
<p>开放定址（线性探测）和拉链的优缺点</p>
<p>-</p>
<p>由上面可以看出拉链法比线性探测处理简单</p>
<h2 id=""><a href="#" class="headerlink" title="-"></a>-</h2><p>线性探测查找是会被拉链法会更消耗时间</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="-"></a>-</h2><p>线性探测会更加容易导致扩容，而拉链不会</p>
<h2 id="-2"><a href="#-2" class="headerlink" title="-"></a>-</h2><p>拉链存储了指针，所以空间上会比线性探测占用多一点</p>
<h2 id="-3"><a href="#-3" class="headerlink" title="-"></a>-</h2><p>拉链是动态申请存储空间的，所以更适合链长不确定的</p>
<p>-</p>
<h3 id="Go-中-Map-的使用"><a href="#Go-中-Map-的使用" class="headerlink" title="Go** 中 Map 的使用**"></a><strong>Go**</strong> 中 <strong><strong>Map</strong></strong> 的使用**</h3><p>直接用代码描述，直观，简单，易理解</p>
<p><em>// <strong>直接创建初始化一个</strong> mao</em></p>
<p>var mapInit = map[string]string {&quot;xiaoli&quot;:&quot;湖南&quot;, &quot;xiaoliu&quot;:&quot;天津&quot;}<em>// <strong>声明一个</strong> map <strong>类型变量</strong> ,//map <strong>的</strong> key <strong>的类型是</strong> string <strong>，</strong> value <strong>的类型是</strong> string</em></p>
<p>var mapTemp map[string]string_// <strong>使用</strong> make <strong>函数初始化这个变量</strong> , <strong>并指定大小</strong> ( <strong>也可以不指定</strong> )_</p>
<p>mapTemp = make(map[string]string,10)<em>// <strong>存储</strong> key</em> <em>，__value</em></p>
<p>mapTemp[&quot;xiaoming&quot;] = &quot;北京&quot;</p>
<p>mapTemp[&quot;xiaowang&quot;]= &quot;河北&quot;<em>// <strong>根据</strong> key <strong>获取</strong> value,// <strong>如果</strong> key <strong>存在，则</strong> ok <strong>是</strong> true <strong>，否则是</strong> flase//v1 <strong>用来接收</strong> key <strong>对应的</strong> value, <strong>当</strong> ok <strong>是</strong> false <strong>时，</strong> v1 <strong>是</strong> nil</em></p>
<p>v1,ok := mapTemp[&quot;xiaoming&quot;]</p>
<p>fmt.Println(ok,v1)<em>// <strong>当</strong> key=xiaowang <strong>存在时打印</strong> value</em> <strong>if</strong> v2,ok := mapTemp[&quot;xiaowang&quot;]; ok{</p>
<p>fmt.Println(v2)</p>
<p>}<em>// <strong>遍历</strong> map, <strong>打印</strong> key <strong>和</strong> value</em> <strong>for</strong> k,v := range mapTemp{</p>
<p>fmt.Println(k,v)</p>
<p>}<em>// <strong>删除</strong> map <strong>中的</strong> key</em> <strong>delete</strong> (mapTemp,&quot;xiaoming&quot;)<em>// <strong>获取</strong> map__的大小</em></p>
<p>l := len(mapTemp)</p>
<p>fmt.Println(l)</p>
<p>看了上面的map创建，初始化，增删改查等操作，我们发现go的api其实挺简单易学的</p>
<h3 id="Go-中-Map-的实现原理"><a href="#Go-中-Map-的实现原理" class="headerlink" title="Go** 中 Map 的实现原理**"></a><strong>Go**</strong> 中 <strong><strong>Map</strong></strong> 的实现原理**</h3><p>知其然，更得知其所以然，会使用map了，多问问为什么，go底层map到底怎么存储呢?接下来我们一探究竟。map的源码位于 src/runtime/map.go中 笔者go的版本是1.12在go中，map同样也是数组存储的的，每个数组下标处存储的是一个bucket,这个bucket的类型见下面代码，每个bucket中可以存储8个kv键值对，当每个bucket存储的kv对到达8个之后，会通过overflow指针指向一个新的bucket，从而形成一个链表,看bmap的结构，我想大家应该很纳闷，没看见kv的结构和overflow指针啊，事实上，这两个结构体并没有显示定义，是通过指针运算进行访问的。</p>
<p><em>//bucket __结构体定义</em> <em>b__ 就是__bucket</em></p>
<p>type bmap{</p>
<p><em>// tophash generally contains the top byte of the hash value</em></p>
<p><em>// for each key in this bucket. If tophash[0] &amp;lt; minTopHash,</em></p>
<p><em>// tophash[0] is a bucket evacuation state instead.</em></p>
<p><em>// <strong>翻译：</strong> top hash <strong>通常包含该</strong> bucket <strong>中每个键的</strong> hash__值的高八位。</em></p>
<p>如果tophash[0]小于mintophash，则tophash[0]为桶疏散状态 <em>//bucketCnt</em> <em>的初始值是__8</em></p>
<p>tophash [bucketCnt]uint8</p>
<p><em>// Followed by bucketCnt keys and then bucketCnt values.</em></p>
<p><em>//</em> <em>NOTE:</em> <em>packing all the keys together and then all the values together makes the // code a bit more complicated than alternating key/value/key/value/… but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8.// Followed by an overflow pointer. // <strong>翻译：接下来是</strong> bucketcnt <strong>键，然后是</strong> bucketcnt__值。</em></p>
<p>注意：将所有键打包在一起，然后将所有值打包在一起， 使得代码比交替键/值/键/值/更复杂。但它允许<em>// <strong>我们消除可能需要的填充， 例如</strong> map[int64]int8./ <strong>后面跟一个溢出指针</strong> }</em></p>
<p>看上面代码以及注释，我们能得到bucket中存储的kv是这样的，tophash用来快速查找key值是否在该bucket中，而不同每次都通过真值进行比较；还有kv的存放，为什么不是k1v1，k2v2….. 而是k1k2…v1v2…，我们看上面的注释说的 map[int64]int8,key是int64（8个字节），value是int8（一个字节），kv的长度不同，如果按照kv格式存放，则考虑内存对齐v也会占用int64，而按照后者存储时，8个v刚好占用一个int64,从这个就可以看出go的map设计之巧妙。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-10ba63a_html_a66f3ee5f8c5cb5b.png"  alt=""></p>
<p>最后我们分析一下go的整体内存结构，阅读一下map存储的源码，如下图所示，当往map中存储一个kv对时，通过k获取hash值，hash值的低八位和bucket数组长度取余，定位到在数组中的那个下标，hash值的高八位存储在bucket中的tophash中，用来快速判断key是否存在，key和value的具体值则通过指针运算存储，当一个bucket满时，通过overfolw指针链接到下一个bucket。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-10ba63a_html_b21f4a64a365f021.png"  alt=""></p>
<p>go的map存储源码如下，省略了一些无关紧要的代码</p>
<p>func <strong>mapassign</strong> (t *maptype, h *hmap, key <strong>unsafe</strong>.Pointer) <strong>unsafe</strong>.Pointer {</p>
<p><em>// <strong>获取</strong> hash__算法</em></p>
<p>alg := t.key.alg</p>
<p><em>// <strong>计算</strong> hash__值</em></p>
<p>hash := alg.hash(key, uintptr(h.hash0))</p>
<p><em>// <strong>如果</strong> bucket__数组一开始为空，则初始化</em></p>
<p><strong>if</strong> h.buckets == nil {</p>
<p>h.buckets = newobject(t.bucket) <em>// newarray(t.bucket, 1)</em></p>
<p>}</p>
<p>again:</p>
<p><em>//</em> <em>定位存储在哪一个 <strong>bucket</strong> 中</em></p>
<p>bucket := hash &amp; bucketMask(h.B)</p>
<p><em>// <strong>得到</strong> bucket__的结构体</em></p>
<p>b := (*bmap)( <strong>unsafe</strong>.Pointer(uintptr(h.buckets) +bucket*uintptr(t.bucketsize)))</p>
<p><em>// <strong>获取高八位</strong> hash__值</em></p>
<p>top := tophash(hash)</p>
<p><strong>var</strong> inserti *uint8</p>
<p><strong>var</strong> insertk <strong>unsafe</strong>.Pointer</p>
<p><strong>var</strong> val <strong>unsafe</strong>.Pointer</p>
<p>bucketloop:</p>
<p><em>//__死循环</em></p>
<p><strong>for</strong> {</p>
<p><em>// <strong>循环</strong> bucket <strong>中的</strong> tophash__数组</em></p>
<p><strong>for</strong> i := uintptr(0); i &amp;lt; bucketCnt; i++ {</p>
<p><em>// <strong>如果</strong> hash__不相等</em></p>
<p><strong>if</strong> b.tophash[i] != top {</p>
<p><em>//__判断是否为空，为空则插入</em></p>
<p><strong>if**</strong> isEmpty**(b.tophash[i]) &amp;&amp; inserti == nil {</p>
<p>inserti = &amp;b.tophash[i]</p>
<p>insertk = <strong>add</strong> ( <strong>unsafe</strong>.Pointer(b), dataOffset+i*uintptr(t.keysize))</p>
<p>val = <strong>add</strong> ( <strong>unsafe</strong>.Pointer(b),</p>
<p>dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize) )</p>
<p>}</p>
<p><em>//__插入成功，终止最外层循环</em></p>
<p><strong>if</strong> b.tophash[i] == emptyRest {</p>
<p><strong>break</strong> bucketloop</p>
<p>}</p>
<p><strong>continue</strong></p>
<p>}</p>
<p><em>// <strong>到这里说明高八位</strong> hash <strong>一样，获取已存在的</strong> key</em></p>
<p>k := <strong>add</strong> ( <strong>unsafe</strong>.Pointer(b), dataOffset+i*uintptr(t.keysize))</p>
<p><strong>if</strong> t.indirectkey() {</p>
<p>k = *((\ <strong>*unsafe</strong>.Pointer)(k))</p>
<p>}</p>
<p><em>// <strong>判断两个</strong> key__是否相等，不相等就循环下一个</em></p>
<p><strong>if</strong>!alg.equal(key, k) {</p>
<p><strong>continue</strong></p>
<p>}</p>
<p><em>//</em> <em>如果相等则更新</em></p>
<p><strong>if</strong> t.needkeyupdate() {</p>
<p>typedmemmove(t.key, k, key)</p>
<p>}</p>
<p><em>// <strong>获取已存在的</strong> value</em></p>
<p>val = <strong>add</strong> ( <strong>unsafe</strong>.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))</p>
<p><strong>goto</strong> done</p>
<p>}</p>
<p><em>// <strong>如果上一个</strong> bucket <strong>没能插入，则通过</strong> overflow <strong>获取链表上的下一个</strong> bucket</em></p>
<p>ovf := b.overflow(t)</p>
<p><strong>if</strong> ovf == nil {</p>
<p><strong>break</strong></p>
<p>}</p>
<p>b = ovf</p>
<p>}</p>
<p><strong>if</strong> inserti == nil {</p>
<p><em>// all current buckets are full, allocate a new one.</em></p>
<p>newb := h.newoverflow(t, b)</p>
<p>inserti = &amp;newb.tophash[0]</p>
<p>insertk = <strong>add</strong> ( <strong>unsafe</strong>.Pointer(newb), dataOffset)</p>
<p>val = <strong>add</strong> (insertk, bucketCnt*uintptr(t.keysize))</p>
<p>}</p>
<p><em>// store new key/value at insert position</em></p>
<p><strong>if</strong> t.indirectkey() {</p>
<p>kmem := newobject(t.key)</p>
<p>*(\ <strong>*unsafe</strong>.Pointer)(insertk) = kmem</p>
<p>insertk = kmem</p>
<p>}</p>
<p><strong>if</strong> t.indirectvalue() {</p>
<p>vmem := newobject(t.elem)</p>
<p>*(\ <strong>*unsafe</strong>.Pointer)(val) = vmem</p>
<p>}</p>
<p>typedmemmove(t.key, insertk, key)</p>
<p><em>// <strong>将高八位</strong> hash__值存储</em></p>
<p>*inserti = top</p>
<p>h.count++</p>
<p><strong>return</strong> val</p>
<p>}</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>map</title>
    <url>/2021/01/09/map/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p>
<h3 id="map-定义"><a href="#map-定义" class="headerlink" title="map** 定义**"></a><strong>map**</strong> 定义**</h3><p>Go语言中 map的定义语法如下</p>
<p>map[KeyType]ValueType</p>
<p>其中，</p>
<p>KeyType:表示键的类型。</p>
<p>ValueType:表示键对应的值的类型。</p>
<p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p>
<p><strong>make</strong> ( <strong>map</strong> [KeyType] <strong>ValueType</strong> , [cap])</p>
<p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p>
<h3 id="map-基本使用"><a href="#map-基本使用" class="headerlink" title="map** 基本使用**"></a><strong>map**</strong> 基本使用**</h3><p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p>
<p><strong>func**</strong> main**() {</p>
<p>scoreMap := make(map[string]int, 8)</p>
<p>scoreMap[&quot;张三&quot;] = 90</p>
<p>scoreMap[&quot;小明&quot;] = 100</p>
<p>fmt.Println(scoreMap)</p>
<p>fmt.Println(scoreMap[&quot;小明&quot;])</p>
<p>fmt.Printf(&quot;type of a:%T\n&quot;, scoreMap)</p>
<p>}</p>
<p>输出：</p>
<p>map[小明:100张三:90]</p>
<p>100</p>
<p>type of a:map[string] <strong>int</strong></p>
<p>map也支持在声明的时候填充元素，例如：</p>
<p>func <strong>main</strong> () {</p>
<p>userInfo := map[string]string{</p>
<p>&quot;username&quot;: &quot;pprof.cn&quot;,</p>
<p>&quot;password&quot;: &quot;123456&quot;,</p>
<p>}</p>
<p>fmt.Println(userInfo) <em>//</em></p>
<p>}</p>
<h3 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a><strong>判断某个键是否存在</strong></h3><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p>
<p>value, ok := map[key]</p>
<p>举个例子：</p>
<p>func <strong>main</strong> () {</p>
<p>scoreMap := make(map[string] <strong>int</strong> )</p>
<p>scoreMap[&quot;张三&quot;] = 90</p>
<p>scoreMap[&quot;小明&quot;] = 100</p>
<p><em>//</em> <em>如果 <strong>key</strong> 存在 <strong>ok</strong> 为 <strong>true,v</strong> 为对应的值；不存在 <strong>ok</strong> 为 <strong>false,v</strong> 为值类型的零值</em></p>
<p>v, ok := scoreMap[&quot;张三&quot;]</p>
<p><strong>if</strong> ok {</p>
<p>fmt.Println(v)</p>
<p>} <strong>else</strong> {</p>
<p>fmt.Println(&quot;查无此人&quot;)</p>
<p>}</p>
<p>}</p>
<h3 id="map-的遍历"><a href="#map-的遍历" class="headerlink" title="map** 的遍历**"></a><strong>map**</strong> 的遍历**</h3><p>Go语言中使用for range遍历map。</p>
<p><strong>func**</strong> main**() {</p>
<p>scoreMap := make(map[string]int)</p>
<p>scoreMap[&quot;张三&quot;] = 90</p>
<p>scoreMap[&quot;小明&quot;] = 100</p>
<p>scoreMap[&quot;王五&quot;] = 60</p>
<p>for k, v := range scoreMap {</p>
<p>fmt.Println(k, v)</p>
<p>}</p>
<p>}</p>
<p>但我们只想遍历key的时候，可以按下面的写法：</p>
<p><strong>func**</strong> main**() {</p>
<p>scoreMap := make(map[string]int)</p>
<p>scoreMap[&quot;张三&quot;] = 90</p>
<p>scoreMap[&quot;小明&quot;] = 100</p>
<p>scoreMap[&quot;王五&quot;] = 60</p>
<p>for k := range scoreMap {</p>
<p>fmt.Println(k)</p>
<p>}</p>
<p>}</p>
<p>注意： 遍历map时的元素顺序与添加键值对的顺序无关。</p>
<h3 id="使用-delete-函数删除键值对"><a href="#使用-delete-函数删除键值对" class="headerlink" title="使用** delete() **函数删除键值对"></a><strong>使用**</strong> delete() <strong>**函数删除键值对</strong></h3><p>使用delete()内建函数从map中删除一组键值对，delete()函数的格式如下：</p>
<p><strong>delete</strong> ( <strong>map</strong> , <strong>key</strong> )</p>
<p>其中，</p>
<p>map:表示要删除键值对的map</p>
<p>key:表示要删除的键值对的键</p>
<p>示例代码如下：</p>
<p><strong>func**</strong> main**(){</p>
<p>scoreMap := make(map[string]int)</p>
<p>scoreMap[&quot;张三&quot;] = 90</p>
<p>scoreMap[&quot;小明&quot;] = 100</p>
<p>scoreMap[&quot;王五&quot;] = 60</p>
<p>delete(scoreMap, &quot;小明&quot;)//将小明:100从map中删除</p>
<p>for k,v := range scoreMap{</p>
<p>fmt.Println(k, v)</p>
<p>}</p>
<p>}</p>
<h3 id="按照指定顺序遍历-map"><a href="#按照指定顺序遍历-map" class="headerlink" title="按照指定顺序遍历** map**"></a><strong>按照指定顺序遍历**</strong> map**</h3><p>func <strong>main</strong> () {</p>
<p>rand.Seed(time.Now().UnixNano()) <em>//__初始化随机数种子</em></p>
<p><strong>var</strong> scoreMap = make(map[<strong>string</strong>] <strong>int</strong> , 200)</p>
<p><strong>for</strong> i := 0; i &amp;lt; 100; i++ {</p>
<p>key := fmt.Sprintf(&quot;stu%02d&quot;, i) <em>// <strong>生成</strong> stu__开头的字符串</em></p>
<p><strong>value</strong> := rand.Intn(100) <em>// <strong>生成</strong> 0~99__的随机整数</em></p>
<p>scoreMap[key] = <strong>value</strong></p>
<p>}</p>
<p><em>// <strong>取出</strong> map <strong>中的所有</strong> key <strong>存入切片</strong> keys</em></p>
<p><strong>var</strong> keys = make([] <strong>string</strong> , 0, 200)</p>
<p><strong>for</strong> key := range scoreMap {</p>
<p>keys = append(keys, key)</p>
<p>}</p>
<p><em>//__对切片进行排序</em></p>
<p>sort.Strings(keys)</p>
<p><em>// <strong>按照排序后的</strong> key <strong>遍历</strong> map</em></p>
<p><strong>for</strong> _, key := range keys {</p>
<p>fmt.Println(key, scoreMap[key])</p>
<p>}</p>
<p>}</p>
<h3 id="元素为-map-类型的切片"><a href="#元素为-map-类型的切片" class="headerlink" title="元素为** map **类型的切片"></a><strong>元素为**</strong> map <strong>**类型的切片</strong></h3><p>下面的代码演示了切片中的元素为map类型时的操作：</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> mapSlice = make([]map[<strong>string</strong>] <strong>string</strong> , 3)</p>
<p><strong>for</strong> index, <strong>value</strong> := range mapSlice {</p>
<p>fmt.Printf(&quot;index:%d value:%v\n&quot;, index, <strong>value</strong> )</p>
<p>}</p>
<p>fmt.Println(&quot;after init&quot;)</p>
<p><em>//</em> <em>对切片中的 <strong>map</strong> 元素进行初始化</em></p>
<p>mapSlice[0] = make(map[<strong>string</strong>] <strong>string</strong> , 10)</p>
<p>mapSlice[0][&quot;name&quot;] = &quot;王五&quot;</p>
<p>mapSlice[0][&quot;password&quot;] = &quot;123456&quot;</p>
<p>mapSlice[0][&quot;address&quot;] = &quot;红旗大街&quot;</p>
<p><strong>for</strong> index, <strong>value</strong> := range mapSlice {</p>
<p>fmt.Printf(&quot;index:%d value:%v\n&quot;, index, <strong>value</strong> )</p>
<p>}</p>
<p>}</p>
<h3 id="值为切片类型的-map"><a href="#值为切片类型的-map" class="headerlink" title="值为切片类型的** map**"></a><strong>值为切片类型的**</strong> map**</h3><p>下面的代码演示了map中值为切片类型的操作：</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> sliceMap = make(map[<strong>string</strong>][] <strong>string</strong> , 3)</p>
<p>fmt.Println(sliceMap)</p>
<p>fmt.Println(&quot;after init&quot;)</p>
<p>key := &quot;中国&quot;</p>
<p><strong>value</strong> , ok := sliceMap[key]</p>
<p><strong>if</strong>!ok {</p>
<p><strong>value</strong> = make([] <strong>string</strong> , 0, 2)</p>
<p>}</p>
<p><strong>value</strong> = append( <strong>value</strong> , &quot;北京&quot;, &quot;上海&quot;)</p>
<p>sliceMap[key] = <strong>value</strong></p>
<p>fmt.Println(sliceMap)</p>
<p>}</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>指针</title>
    <url>/2021/01/09/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。</p>
<p>要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。</p>
<h2 id="Go-语言中的指针"><a href="#Go-语言中的指针" class="headerlink" title="Go** 语言中的指针**"></a><strong>Go**</strong> 语言中的指针**</h2><p>Go语言中的函数传参都是值拷贝，当我们想要修改某个变量的时候，我们可以创建一个指向该变量地址的指针变量。传递数据使用指针，而无须拷贝数据。类型指针不能进行偏移和运算。Go语言中的指针操作非常简单，只需要记住两个符号：&amp;（取地址）和*（根据地址取值）。</p>
<h3 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a><strong>指针地址和指针类型</strong></h3><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用&amp;字符放在变量前面对变量进行&quot;取地址&quot;操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：*int、*int64、*string等。</p>
<p>取变量指针的语法如下：</p>
<p>ptr := &amp;v <em>// v <strong>的类型为</strong> T</em></p>
<p>其中：</p>
<p>v:代表被取地址的变量，类型为T</p>
<p>ptr:用于接收地址的变量，ptr的类型就为*T，称做T的指针类型。*代表指针。</p>
<p>举个例子：</p>
<p><strong>func**</strong> main**() {</p>
<p>a := 10</p>
<p>b := &amp;a</p>
<p>fmt.Printf(&quot;a:%d ptr:%p\n&quot;, a, &amp;a) // a:10 ptr:0xc00001a078</p>
<p>fmt.Printf(&quot;b:%p type:%T\n&quot;, b, b) // b:0xc00001a078 type:*int</p>
<p>fmt.Println(&amp;b) // 0xc00000e018</p>
<p>}</p>
<p>我们来看一下b := &amp;a的图示：</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-ojet7m_html_5dae221a603f722b.png"  alt=""></p>
<h3 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a><strong>指针取值</strong></h3><p>在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。</p>
<p>func <strong>main</strong> () {</p>
<p><em>//__指针取值</em></p>
<p>a := 10</p>
<p>b := &amp;a <em>//</em> <em>取变量 <strong>a</strong> 的地址，将指针保存到 <strong>b</strong> 中</em></p>
<p>fmt.Printf(&quot;type of b:%T\n&quot;, b)</p>
<p>c := *b <em>//</em> <em>指针取值（根据指针去内存取值）</em></p>
<p>fmt.Printf(&quot;type of c:%T\n&quot;, c)</p>
<p>fmt.Printf(&quot;value of c:%v\n&quot;, c)</p>
<p>}</p>
<p>输出如下：</p>
<p>type <strong>of</strong> b:*int</p>
<p>type <strong>of</strong> c:int</p>
<p>value <strong>of</strong> c:10</p>
<p>总结： 取地址操作符&amp;和取值操作符*是一对互补操作符，&amp;取出地址，*根据地址取出地址指向的值。</p>
<p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：\</p>
<p>1.对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</p>
<p>2.指针变量的值是指针地址。</p>
<p>3.对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</p>
<p>指针传值示例：</p>
<p>func <strong>modify1</strong> (x <strong>int</strong> ) {</p>
<p>x = 100</p>
<p>}</p>
<p>func <strong>modify2</strong> (x \ <strong>*int</strong> ) {</p>
<p>*x = 100</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>a := 10</p>
<p>modify1(a)</p>
<p>fmt.Println(a) <em>// 10</em></p>
<p>modify2(&amp;a)</p>
<p>fmt.Println(a) <em>// 100</em></p>
<p>}</p>
<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a><strong>空指针</strong></h3><ul>
<li>当一个指针被定义后没有分配到任何变量时，它的值为 nil</li>
<li>空指针的判断</li>
</ul>
<p>package main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p>var p *string</p>
<p>fmt.Println(p)</p>
<p>fmt.Printf(&quot;p的值是%v\n&quot;, p)</p>
<p><strong>if</strong> p != nil {</p>
<p>fmt.Println(&quot;非空&quot;)</p>
<p>} <strong>else</strong> {</p>
<p>fmt.Println(&quot;空值&quot;)</p>
<p>}</p>
<p>}</p>
<h3 id="new-和-make"><a href="#new-和-make" class="headerlink" title="new** 和 **make"></a><strong>new**</strong> 和 <strong>**make</strong></h3><p>我们先来看一个例子：</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> a \ <strong>*int</strong></p>
<p>*a = 100</p>
<p>fmt.Println(*a)</p>
<p><strong>var</strong> b map[<strong>string</strong>] <strong>int</strong></p>
<p>b[&quot;测试&quot;] = 100</p>
<p>fmt.Println(b)</p>
<p>}</p>
<p>执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a><strong>new</strong></h3><p>new是一个内置的函数，它的函数签名如下：</p>
<p>func <strong>new</strong> (Type) *Type</p>
<p>其中，</p>
<p>1.Type表示类型， <strong>new</strong> 函数只接受一个参数，这个参数是一个类型</p>
<p>2.*Type表示类型指针， <strong>new</strong> 函数返回一个指向该类型内存地址的指针。</p>
<p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p>
<p><strong>func**</strong> main**() {</p>
<p>a := new(int)</p>
<p>b := new(bool)</p>
<p>fmt.Printf(&quot;%T\n&quot;, a) // *int</p>
<p>fmt.Printf(&quot;%T\n&quot;, b) // *bool</p>
<p>fmt.Println(*a) // 0</p>
<p>fmt.Println(*b) // false</p>
<p>}</p>
<p>本节开始的示例代码中var a *int只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> a \ <strong>*int</strong></p>
<p>a = <strong>new</strong> ( <strong>int</strong> )</p>
<p>*a = 10</p>
<p>fmt.Println(*a)</p>
<p>}</p>
<h3 id="make"><a href="#make" class="headerlink" title="make"></a><strong>make</strong></h3><p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</p>
<p><strong>func**</strong> make<strong>(</strong>t <strong>**Type</strong> , <strong>size</strong>…IntegerType) <strong>Type</strong></p>
<p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。</p>
<p>本节开始的示例中var b map[string]int只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：</p>
<p>func <strong>main</strong> () {</p>
<p>var b map[string] <strong>int</strong></p>
<p>b = make(map[string] <strong>int</strong> , 10)</p>
<p>b[&quot;测试&quot;] = 100</p>
<p>fmt.Println(b)</p>
<p>}</p>
<h3 id="new-与-make-的区别"><a href="#new-与-make-的区别" class="headerlink" title="new** 与 make 的区别**"></a><strong>new**</strong> 与 <strong><strong>make</strong></strong> 的区别**</h3><p>1.二者都是用来做内存分配的。</p>
<p>2.make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</p>
<p>3.而 <strong>new</strong> 用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</p>
<h3 id="指针小练习"><a href="#指针小练习" class="headerlink" title="指针小练习"></a><strong>指针小练习</strong></h3><ul>
<li>程序定义一个int变量num的地址并打印</li>
<li>将num的地址赋给指针ptr，并通过ptr去修改num的值</li>
</ul>
<p>package main</p>
<p>import &quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> a <strong>int</strong></p>
<p>fmt.Println(&amp;a)</p>
<p><strong>var</strong> p \ <strong>*int</strong></p>
<p>p = &amp;a</p>
<p>*p = 20</p>
<p>fmt.Println(a)</p>
<p>}</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>slice底层实现</title>
    <url>/2021/01/09/slice%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h1><h1 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h1><p><strong>本章不属于基础部分但是面试经常会问到建议学学</strong></p>
<p>切片是 Go 中的一种基本的数据结构，使用这种结构可以用来管理数据集合。切片的设计想法是由动态数组概念而来，为了开发者可以更加方便的使一个数据结构可以自动增加和减少。但是切片本身并不是动态数据或者数组指针。切片常见的操作有 reslice、append、copy。与此同时，切片还具有可索引，可迭代的优秀特性。</p>
<h3 id="切片和数组"><a href="#切片和数组" class="headerlink" title="切片和数组"></a><strong>切片和数组</strong></h3><p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_e352b7e670418019.gif"  alt=""></p>
<p>关于切片和数组怎么选择？接下来好好讨论讨论这个问题。</p>
<p>在 Go 中，与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和函数传参操作都会复制整个数组数据。</p>
<p>func main() {</p>
<p>arrayA := [2] <strong>int</strong> {100, 200}</p>
<p>var arrayB [2] <strong>int</strong></p>
<p>arrayB = arrayA</p>
<p>fmt.Printf(&quot;arrayA : %p , %v\n&quot;, &amp;arrayA, arrayA)</p>
<p>fmt.Printf(&quot;arrayB : %p , %v\n&quot;, &amp;arrayB, arrayB)</p>
<p>testArray(arrayA)</p>
<p>}</p>
<p>func testArray( <strong>x</strong> [2] <strong>int</strong> ) {</p>
<p>fmt.Printf(&quot;func Array : %p , %v\n&quot;, &amp; <strong>x</strong> , <strong>x</strong> )</p>
<p>}</p>
<p>打印结果：</p>
<p>arrayA : 0xc4200bebf0 , <strong>[100 200]</strong></p>
<p>arrayB : 0xc4200bec00 , <strong>[100 200]</strong></p>
<p>func Array : 0xc4200bec30 , <strong>[100 200]</strong></p>
<p>可以看到，三个内存地址都不同，这也就验证了 Go 中数组赋值和函数传参都是值复制的。那这会导致什么问题呢？</p>
<p>假想每次传参都用数组，那么每次数组都要被复制一遍。如果数组大小有 100万，在64位机器上就需要花费大约 800W 字节，即 8MB 内存。这样会消耗掉大量的内存。于是乎有人想到，函数传参用数组的指针。</p>
<p>func <strong>main</strong> () {</p>
<p>arrayA := [2] <strong>int</strong> {100, 200}</p>
<p>testArrayPoint(&amp;arrayA) <em>// 1.__传数组指针</em></p>
<p>arrayB := arrayA[:]</p>
<p>testArrayPoint(&amp;arrayB) <em>// 2.__传切片</em></p>
<p>fmt.Printf(&quot;arrayA : %p , %v\n&quot;, &amp;arrayA, arrayA)</p>
<p>}</p>
<p>func <strong>testArrayPoint</strong> (x *[] <strong>int</strong> ) {</p>
<p>fmt.Printf(&quot;func Array : %p , %v\n&quot;, x, *x)</p>
<p>(*x)[1] += 100</p>
<p>}</p>
<p>打印结果：</p>
<p>func Array : 0xc4200b0140 , <strong>[100 200]</strong></p>
<p>func Array : 0xc4200b0180 , <strong>[100 300]</strong></p>
<p>arrayA : 0xc4200b0140 , <strong>[100 400]</strong></p>
<p>这也就证明了数组指针确实到达了我们想要的效果。现在就算是传入10亿的数组，也只需要再栈上分配一个8个字节的内存给指针就可以了。这样更加高效的利用内存，性能也比之前的好。</p>
<p>不过传指针会有一个弊端，从打印结果可以看到，第一行和第三行指针地址都是同一个，万一原数组的指针指向更改了，那么函数里面的指针指向都会跟着更改。</p>
<p>切片的优势也就表现出来了。用切片传数组参数，既可以达到节约内存的目的，也可以达到合理处理好共享内存的问题。打印结果第二行就是切片，切片的指针和原来数组的指针是不同的。</p>
<p>由此我们可以得出结论：</p>
<p>把第一个大数组传递给函数会消耗很多内存，采用切片的方式传参可以避免上述问题。切片是引用传递，所以它们不需要使用额外的内存并且比使用数组更有效率。</p>
<p>但是，依旧有反例。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;testing&quot;</p>
<p>func <strong>array</strong> () [1024] <strong>int</strong> {</p>
<p>var x [1024] <strong>int</strong></p>
<p><strong>for</strong> i := 0; i &amp;lt; len(x); i++ {</p>
<p>x[i] = i</p>
<p>}</p>
<p><strong>return</strong> x</p>
<p>}</p>
<p>func <strong>slice</strong> () [] <strong>int</strong> {</p>
<p>x := make([] <strong>int</strong> , 1024)</p>
<p><strong>for</strong> i := 0; i &amp;lt; len(x); i++ {</p>
<p>x[i] = i</p>
<p>}</p>
<p><strong>return</strong> x</p>
<p>}</p>
<p>func <strong>BenchmarkArray</strong> (b *testing.B) {</p>
<p><strong>for</strong> i := 0; i &amp;lt; b.N; i++ {</p>
<p>array()</p>
<p>}</p>
<p>}</p>
<p>func <strong>BenchmarkSlice</strong> (b *testing.B) {</p>
<p><strong>for</strong> i := 0; i &amp;lt; b.N; i++ {</p>
<p>slice()</p>
<p>}</p>
<p>}</p>
<p>我们做一次性能测试，并且禁用内联和优化，来观察切片的堆上内存分配的情况。</p>
<p>go test -bench . -benchmem -gcflags &quot;-N -l&quot;</p>
<p>输出结果比较&quot;令人意外&quot;：</p>
<p>BenchmarkArray-4 500000 3637 ns/op 0 B/op 0 alloc s/op</p>
<p>BenchmarkSlice-4 300000 4055 ns/op 8192 B/op 1 alloc s/op</p>
<p>解释一下上述结果，在测试 Array 的时候，用的是4核，循环次数是500000，平均每次执行时间是3637 ns，每次执行堆上分配内存总量是0，分配次数也是0 。</p>
<p>而切片的结果就&quot;差&quot;一点，同样也是用的是4核，循环次数是300000，平均每次执行时间是4055 ns，但是每次执行一次，堆上分配内存总量是8192，分配次数也是1 。</p>
<p>这样对比看来，并非所有时候都适合用切片代替数组，因为切片底层数组可能会在堆上分配内存，而且小数组在栈上拷贝的消耗也未必比<br> make 消耗大。</p>
<h3 id="切片的数据结构"><a href="#切片的数据结构" class="headerlink" title="切片的数据结构"></a><strong>切片的数据结构</strong></h3><p>切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。</p>
<p>切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个与指向数组的动态窗口。</p>
<p>给定项的切片索引可能比相关数组的相同元素的索引小。和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个长度可变的数组。</p>
<p>Slice 的数据结构定义如下:</p>
<p>type slice <strong>struct</strong> {</p>
<p>array unsafe.Pointer</p>
<p>len <strong>int</strong></p>
<p>cap <strong>int</strong></p>
<p>}</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_c686a3c163ab625e.gif"  alt=""></p>
<p>切片的结构体由3部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_402755e53a58b0fd.gif"  alt=""></p>
<p>如果想从 slice 中得到一块内存地址，可以这样做：</p>
<p>s := make([] <strong>byte</strong> , 200)</p>
<p>ptr := <strong>unsafe</strong>.Pointer(&amp;s[0])</p>
<p>如果反过来呢？从 Go 的内存地址中构造一个 slice。</p>
<p><strong>var</strong> ptr <strong>unsafe</strong>.Pointer <strong>var</strong> s1 = <strong>struct</strong> {</p>
<p>addr uintptr</p>
<p>len <strong>int</strong></p>
<p>cap <strong>int</strong></p>
<p>}{ptr, length, length}</p>
<p>s := *(*[] <strong>byte</strong> )( <strong>unsafe</strong>.Pointer(&amp;s1))</p>
<p>构造一个虚拟的结构体，把 slice 的数据结构拼出来。</p>
<p>当然还有更加直接的方法，在 Go 的反射中就存在一个与之对应的数据结构 SliceHeader，我们可以用它来构造一个 slice</p>
<p><strong>var</strong> o [] <strong>byte</strong></p>
<p>sliceHeader := (*reflect.SliceHeader)(( <strong>unsafe</strong>.Pointer(&amp;o)))</p>
<p>sliceHeader.Cap = length</p>
<p>sliceHeader.Len = length</p>
<p>sliceHeader.Data = uintptr(ptr)</p>
<h3 id="创建切片"><a href="#创建切片" class="headerlink" title="创建切片"></a><strong>创建切片</strong></h3><p>make 函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。</p>
<p>创建切片有两种形式，make 创建切片，空切片。</p>
<h4 id="make-和切片字面量"><a href="#make-和切片字面量" class="headerlink" title="make  和切片字面量"></a><strong>make</strong>  <strong>和切片字面量</strong></h4><p>func <strong>makeslice</strong> (et *_type, len, cap <strong>int</strong> ) slice {</p>
<p><em>//</em> <em>根据切片的数据类型，获取切片的最大容量</em></p>
<p>maxElements := maxSliceCap(et.size)</p>
<p><em>//</em> <em>比较切片的长度，长度值域应该在<strong>[0,maxElements]</strong>之间</em></p>
<p><strong>if</strong> len &amp;lt; 0 || uintptr(len) &amp;gt; maxElements {</p>
<p>panic(errorString(&quot;makeslice: len out of range&quot;))</p>
<p>}</p>
<p><em>//</em> <em>比较切片的容量，容量值域应该在<strong>[len,maxElements]</strong>之间</em></p>
<p><strong>if</strong> cap &amp;lt; len || uintptr(cap) &amp;gt; maxElements {</p>
<p>panic(errorString(&quot;makeslice: cap out of range&quot;))</p>
<p>}</p>
<p><em>//</em> <em>根据切片的容量申请内存</em></p>
<p>p := mallocgc(et.size*uintptr(cap), et, true)</p>
<p><em>//</em> <em>返回申请好内存的切片的首地址</em></p>
<p><strong>return</strong> slice{p, len, cap}</p>
<p>}</p>
<p>还有一个 int64 的版本：</p>
<p>func makeslice64(et *_type, len64, cap64 int64) slice {</p>
<p>len := int(len64)</p>
<p><strong>if</strong> int64(len) != len64 {</p>
<p>panic(errorString(&quot;makeslice: len out of range&quot;))</p>
<p>}</p>
<p>cap := int(cap64)</p>
<p><strong>if</strong> int64(cap) != cap64 {</p>
<p>panic(errorString(&quot;makeslice: cap out of range&quot;))</p>
<p>}</p>
<p>return makeslice(et, len, cap)</p>
<p>}</p>
<p>实现原理和上面的是一样的，只不过多了把 int64 转换成 int 这一步罢了。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_126c0648a5821967.gif"  alt=""></p>
<p>上图是用 make 函数创建的一个 len = 4， cap = 6 的切片。内存空间申请了6个 int 类型的内存大小。由于 len = 4，所以后面2个暂时访问不到，但是容量还是在的。这时候数组里面每个变量都是0 。</p>
<p>除了 make 函数可以创建切片以外，字面量也可以创建切片。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_ea9899f0204721f2.gif"  alt=""></p>
<p>这里是用字面量创建的一个 len = 6，cap = 6 的切片，这时候数组里面每个元素的值都初始化完成了。需要注意的是 [] 里面不要写数组的容量，因为如果写了个数以后就是数组了，而不是切片了。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_e7bfbfb11184a935.gif"  alt=""></p>
<p>还有一种简单的字面量创建切片的方法。如上图。上图就 Slice A 创建出了一个 len = 3，cap = 3 的切片。从原数组的第二位元素(0是第一位)开始切，一直切到第四位为止(不包括第五位)。同理，Slice B 创建出了一个 len = 2，cap = 4 的切片。</p>
<h4 id="nil-和空切片"><a href="#nil-和空切片" class="headerlink" title="nil  和空切片"></a><strong>nil</strong>  <strong>和空切片</strong></h4><p>nil 切片和空切片也是常用的。</p>
<p><strong>var</strong> slice [] <strong>int</strong></p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_f0a0d73823735804.gif"  alt=""></p>
<p>nil 切片被用在很多标准库和内置函数中，描述一个不存在的切片的时候，就需要用到 nil 切片。比如函数在发生异常的时候，返回的切片就是 nil 切片。nil 切片的指针指向 nil。</p>
<p>空切片一般会用来表示一个空的集合。比如数据库查询，一条结果也没有查到，那么就可以返回一个空切片。</p>
<p>silce := make( [] <strong>int</strong> , 0 )</p>
<p>slice := [] <strong>int</strong> { }</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_c207da75ab2a4e00.gif"  alt=""></p>
<p>空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。</p>
<p>最后需要说明的一点是。不管是使用 nil 切片还是空切片，对其调用内置函数 append，len 和 cap 的效果都是一样的。</p>
<h3 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a><strong>切片扩容</strong></h3><p>当一个切片的容量满了，就需要扩容了。怎么扩，策略是什么？</p>
<p>func <strong>growslice</strong> (et *_type, old slice, cap <strong>int</strong> ) slice {</p>
<p><strong>if</strong> raceenabled {</p>
<p>callerpc := getcallerpc( <strong>unsafe</strong>.Pointer(&amp;et))</p>
<p>racereadrangepc(old.array, uintptr(old.len\ <strong>*int</strong> (et.size)), callerpc, funcPC(growslice))</p>
<p>}</p>
<p><strong>if</strong> msanenabled {</p>
<p>msanread(old.array, uintptr(old.len\ <strong>*int</strong> (et.size)))</p>
<p>}</p>
<p><strong>if</strong> et.size == 0 {</p>
<p><em>//</em> <em>如果新要扩容的容量比原来的容量还要小，这代表要缩容了，那么可以直接报 <strong>panic</strong> 了。</em></p>
<p><strong>if</strong> cap &amp;lt; old.cap {</p>
<p>panic(errorString(&quot;growslice: cap out of range&quot;))</p>
<p>}</p>
<p><em>//</em> <em>如果当前切片的大小为 <strong>0</strong> ，还调用了扩容方法，那么就新生成一个新的容量的切片返回。</em></p>
<p><strong>return</strong> slice{ <strong>unsafe</strong>.Pointer(&amp;zerobase), old.len, cap}</p>
<p>}</p>
<p><em>//</em> <em>这里就是扩容的策略</em></p>
<p>newcap := old.cap</p>
<p>doublecap := newcap + newcap</p>
<p><strong>if</strong> cap &amp;gt; doublecap {</p>
<p>newcap = cap</p>
<p>} <strong>else</strong> {</p>
<p><strong>if</strong> old.len &amp;lt; 1024 {</p>
<p>newcap = doublecap</p>
<p>} <strong>else</strong> {</p>
<p><strong>for</strong> newcap &amp;lt; cap {</p>
<p>newcap += newcap / 4</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><em>//</em> <em>计算新的切片的容量，长度。</em></p>
<p><strong>var</strong> lenmem, newlenmem, capmem uintptr</p>
<p><strong>const</strong> ptrSize = <strong>unsafe</strong>.Sizeof((\ <strong>*byte</strong> )(nil))</p>
<p><strong>switch</strong> et.size {</p>
<p><strong>case</strong> 1:</p>
<p>lenmem = uintptr(old.len)</p>
<p>newlenmem = uintptr(cap)</p>
<p>capmem = roundupsize(uintptr(newcap))</p>
<p>newcap = <strong>int</strong> (capmem)</p>
<p><strong>case</strong> ptrSize:</p>
<p>lenmem = uintptr(old.len) * ptrSize</p>
<p>newlenmem = uintptr(cap) * ptrSize</p>
<p>capmem = roundupsize(uintptr(newcap) * ptrSize)</p>
<p>newcap = <strong>int</strong> (capmem / ptrSize)</p>
<p><strong>default</strong> :</p>
<p>lenmem = uintptr(old.len) * et.size</p>
<p>newlenmem = uintptr(cap) * et.size</p>
<p>capmem = roundupsize(uintptr(newcap) * et.size)</p>
<p>newcap = <strong>int</strong> (capmem / et.size)</p>
<p>}</p>
<p><em>//</em> <em>判断非法的值，保证容量是在增加，并且容量不超过最大容量</em></p>
<p><strong>if</strong> cap &amp;lt; old.cap || uintptr(newcap) &amp;gt; maxSliceCap(et.size) {</p>
<p>panic(errorString(&quot;growslice: cap out of range&quot;))</p>
<p>}</p>
<p><strong>var</strong> p <strong>unsafe</strong>.Pointer</p>
<p><strong>if</strong> et.kind&amp;kindNoPointers != 0 {</p>
<p><em>//</em> <em>在老的切片后面继续扩充容量</em></p>
<p>p = mallocgc(capmem, nil, false)</p>
<p><em>//</em> <em>将</em> <em>lenmem</em> <em>这个多个</em> <em>bytes</em> <em>从</em> <em>old.array__地址 拷贝到</em> <em>p</em> <em>的地址处</em></p>
<p>memmove(p, old.array, lenmem)</p>
<p><em>//</em> <em>先将</em> <em>P</em> <em>地址加上新的容量得到新切片容量的地址，然后将新切片容量地址后面的</em> <em>capmem-newlenmem</em> <em>个</em> <em>bytes</em> <em>这块内存初始化。为之后继续</em> <em>append()</em> <em>操作腾出空间。</em></p>
<p>memclrNoHeapPointers( <strong>add</strong> (p, newlenmem), capmem-newlenmem)</p>
<p>} <strong>else</strong> {</p>
<p><em>//</em> <em>重新申请新的数组给新切片</em></p>
<p><em>//</em> <em>重新申请</em> <em>capmen</em> <em>这个大的内存地址，并且初始化为 <strong>0</strong> 值</em></p>
<p>p = mallocgc(capmem, et, true)</p>
<p><strong>if</strong>!writeBarrier.enabled {</p>
<p><em>//</em> <em>如果还不能打开写锁，那么只能把</em> <em>lenmem</em> <em>大小的</em> <em>bytes</em> <em>字节从</em> <em>old.array</em> <em>拷贝到</em> <em>p</em> <em>的地址处</em></p>
<p>memmove(p, old.array, lenmem)</p>
<p>} <strong>else</strong> {</p>
<p><em>//</em> <em>循环拷贝老的切片的值</em></p>
<p><strong>for</strong> i := uintptr(0); i &amp;lt; lenmem; i += et.size {</p>
<p>typedmemmove(et, <strong>add</strong> (p, i), <strong>add</strong> (old.array, i))</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><em>//</em> <em>返回最终新切片，容量更新为最新扩容之后的容量</em></p>
<p><strong>return</strong> slice{p, old.len, newcap}</p>
<p>}</p>
<p>上述就是扩容的实现。主要需要关注的有两点，一个是扩容时候的策略，还有一个就是扩容是生成全新的内存地址还是在原来的地址后追加。</p>
<h4 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a><strong>扩容策略</strong></h4><p>先看看扩容策略。</p>
<p>func main() {</p>
<p>slice := [] <strong>int</strong> {10, 20, 30, 40}</p>
<p>newSlice := append(slice, 50)</p>
<p>fmt.Printf(&quot;Before slice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, slice, &amp;slice, len(slice), cap(slice))</p>
<p>fmt.Printf(&quot;Before newSlice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, newSlice, &amp;newSlice, len(newSlice), cap(newSlice))</p>
<p>newSlice[1] += 10</p>
<p>fmt.Printf(&quot;After slice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, slice, &amp;slice, len(slice), cap(slice))</p>
<p>fmt.Printf(&quot;After newSlice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, newSlice, &amp;newSlice, len(newSlice), cap(newSlice))</p>
<p>}</p>
<p>输出结果：</p>
<p>Before slice = [10 20 30 40], Pointer = 0xc4200b0140, len = 4, cap = 4</p>
<p>Before newSlice = [10 20 30 40 50], Pointer = 0xc4200b0180, len = 5, cap = 8</p>
<p>After slice = [10 20 30 40], Pointer = 0xc4200b0140, len = 4, cap = 4</p>
<p>After newSlice = [10 30 30 40 50], Pointer = 0xc4200b0180, len = 5, cap = 8</p>
<p>用图表示出上述过程。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_ef61c79aff3e9d58.gif"  alt=""></p>
<p>从图上我们可以很容易的看出，新的切片和之前的切片已经不同了，因为新的切片更改了一个值，并没有影响到原来的数组，新切片指向的数组是一个全新的数组。并且 cap 容量也发生了变化。这之间究竟发生了什么呢？</p>
<p>Go 中切片扩容的策略是这样的：</p>
<p>如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。上面那个例子也验证了这一情况，总容量从原来的4个翻倍到现在的8个。</p>
<p>一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。</p>
<p>注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。</p>
<h4 id="新数组-or-老数组-？"><a href="#新数组-or-老数组-？" class="headerlink" title="新数组  or  老数组 ？"></a><strong>新数组</strong>  <strong>or</strong>  <strong>老数组 ？</strong></h4><p>再谈谈扩容之后的数组一定是新的么？这个不一定，分两种情况。</p>
<p>情况一：</p>
<p>func main() {</p>
<p>array := [4] <strong>int</strong> {10, 20, 30, 40}</p>
<p>slice := array[0:2]</p>
<p>newSlice := append(slice, 50)</p>
<p>fmt.Printf(&quot;Before slice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, slice, &amp;slice, len(slice), cap(slice))</p>
<p>fmt.Printf(&quot;Before newSlice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, newSlice, &amp;newSlice, len(newSlice), cap(newSlice))</p>
<p>newSlice[1] += 10</p>
<p>fmt.Printf(&quot;After slice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, slice, &amp;slice, len(slice), cap(slice))</p>
<p>fmt.Printf(&quot;After newSlice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, newSlice, &amp;newSlice, len(newSlice), cap(newSlice))</p>
<p>fmt.Printf(&quot;After array = %v\n&quot;, array)</p>
<p>}</p>
<p>打印输出：</p>
<p>Before slice = [10 20], Pointer = 0xc4200c0040, len = 2, cap = 4</p>
<p>Before newSlice = [10 20 50], Pointer = 0xc4200c0060, len = 3, cap = 4</p>
<p>After slice = [10 30], Pointer = 0xc4200c0040, len = 2, cap = 4</p>
<p>After newSlice = [10 30 50], Pointer = 0xc4200c0060, len = 3, cap = 4</p>
<p>After array = [10 30 50 40]</p>
<p>把上述过程用图表示出来，如下图。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_28fdd699b35ba17.gif"  alt=""></p>
<p>通过打印的结果，我们可以看到，在这种情况下，扩容以后并没有新建一个新的数组，扩容前后的数组都是同一个，这也就导致了新的切片修改了一个值，也影响到了老的切片了。并且 append() 操作也改变了原来数组里面的值。一个 append() 操作影响了这么多地方，如果原数组上有多个切片，那么这些切片都会被影响！无意间就产生了莫名的 bug！</p>
<p>这种情况，由于原数组还有容量可以扩容，所以执行 append() 操作以后，会在原数组上直接操作，所以这种情况下，扩容以后的数组还是指向原来的数组。</p>
<p>这种情况也极容易出现在字面量创建切片时候，第三个参数 cap 传值的时候，如果用字面量创建切片，cap 并不等于指向数组的总容量，那么这种情况就会发生。</p>
<p>slice := array[1:2:3]</p>
<p>上面这种情况非常危险，极度容易产生 bug 。</p>
<p>建议用字面量创建切片的时候，cap 的值一定要保持清醒，避免共享原数组导致的 bug。</p>
<p>情况二：</p>
<p>情况二其实就是在扩容策略里面举的例子，在那个例子中之所以生成了新的切片，是因为原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组。</p>
<p>所以建议尽量避免情况一，尽量使用情况二，避免 bug 产生。</p>
<h3 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a><strong>切片拷贝</strong></h3><p>Slice 中拷贝方法有2个。</p>
<p>func <strong>slicecopy</strong> (to, fm slice, width uintptr) <strong>int</strong> {</p>
<p><em>//</em> <em>如果源切片或者目标切片有一个长度为 <strong>0</strong> ，那么就不需要拷贝，直接</em> <em>return</em></p>
<p><strong>if</strong> fm.len == 0 || to.len == 0 {</p>
<p><strong>return</strong> 0</p>
<p>}</p>
<p><em>// n</em> <em>记录下源切片或者目标切片较短的那一个的长度</em></p>
<p>n := fm.len</p>
<p><strong>if</strong> to.len &amp;lt; n {</p>
<p>n = to.len</p>
<p>}</p>
<p><em>//</em> <em>如果入参</em> <em>width = 0__，也不需要拷贝了，返回较短的切片的长度</em></p>
<p><strong>if</strong> width == 0 {</p>
<p><strong>return</strong> n</p>
<p>}</p>
<p><em>//</em> <em>如果开启了竞争检测</em></p>
<p><strong>if</strong> raceenabled {</p>
<p>callerpc := getcallerpc(unsafe.Pointer(&amp;to))</p>
<p>pc := funcPC(slicecopy)</p>
<p>racewriterangepc(to.array, uintptr(n\ <strong>*int</strong> (width)), callerpc, pc)</p>
<p>racereadrangepc(fm.array, uintptr(n\ <strong>*int</strong> (width)), callerpc, pc)</p>
<p>}</p>
<p><em>//</em> <em>如果开启了</em> <em>The memory sanitizer (msan)</em></p>
<p><strong>if</strong> msanenabled {</p>
<p>msanwrite(to.array, uintptr(n\ <strong>*int</strong> (width)))</p>
<p>msanread(fm.array, uintptr(n\ <strong>*int</strong> (width)))</p>
<p>}</p>
<p>size := uintptr(n) * width</p>
<p><strong>if</strong> size == 1 {</p>
<p><em>//</em> <em>TODO:</em> <em>is this still worth it with new memmove impl?</em></p>
<p><em>//</em> <em>如果只有一个元素，那么指针直接转换即可</em></p>
<p>*(*byte)(to.array) = *(*byte)(fm.array) <em>// known to be a byte pointer</em></p>
<p>} <strong>else</strong> {</p>
<p><em>//</em> <em>如果不止一个元素，那么就把</em> <em>size</em> <em>个</em> <em>bytes</em> <em>从</em> <em>fm.array</em> <em>地址开始，拷贝到</em> <em>to.array</em> <em>地址之后</em></p>
<p>memmove(to.array, fm.array, size)</p>
<p>}</p>
<p><strong>return</strong> n</p>
<p>}</p>
<p>在这个方法中，slicecopy 方法会把源切片值(即 fm Slice )中的元素复制到目标切片(即 to Slice )中，并返回被复制的元素个数，copy 的两个类型必须一致。slicecopy 方法最终的复制结果取决于较短的那个切片，当较短的切片复制完成，整个复制过程就全部完成了。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_f80b1bdd4ca699a8.gif"  alt=""></p>
<p>举个例子，比如：</p>
<p>func <strong>main</strong> () {</p>
<p>array := [] <strong>int</strong> {10, 20, 30, 40}</p>
<p>slice := make([] <strong>int</strong> , 6)</p>
<p>n := copy(slice, array)</p>
<p>fmt.Println(n,slice)</p>
<p>}</p>
<p>还有一个拷贝的方法，这个方法原理和 slicecopy 方法类似，不在赘述了，注释写在代码里面了。</p>
<p>func <strong>slicestringcopy</strong> (to [] <strong>byte</strong> , fm <strong>string</strong> ) <strong>int</strong> {</p>
<p><em>//</em> <em>如果源切片或者目标切片有一个长度为 <strong>0</strong> ，那么就不需要拷贝，直接</em> <em>return</em></p>
<p><strong>if**</strong> len**(fm) == 0 || len(to) == 0 {</p>
<p><strong>return</strong> 0</p>
<p>}</p>
<p><em>// n</em> <em>记录下源切片或者目标切片较短的那一个的长度</em></p>
<p>n := len(fm)</p>
<p><strong>if**</strong> len**(to) &amp;lt; n {</p>
<p>n = len(to)</p>
<p>}</p>
<p><em>//</em> <em>如果开启了竞争检测</em></p>
<p><strong>if</strong> raceenabled {</p>
<p>callerpc := getcallerpc( <strong>unsafe</strong>.Pointer(&amp;to))</p>
<p>pc := funcPC(slicestringcopy)</p>
<p>racewriterangepc( <strong>unsafe</strong>.Pointer(&amp;to[0]), uintptr(n), callerpc, pc)</p>
<p>}</p>
<p><em>//</em> <em>如果开启了</em> <em>The memory sanitizer (msan)</em></p>
<p><strong>if</strong> msanenabled {</p>
<p>msanwrite( <strong>unsafe</strong>.Pointer(&amp;to[0]), uintptr(n))</p>
<p>}</p>
<p><em>//</em> <em>拷贝字符串至字节数组</em></p>
<p>memmove( <strong>unsafe</strong>.Pointer(&amp;to[0]), stringStructOf(&amp;fm).str, uintptr(n))</p>
<p><strong>return</strong> n</p>
<p>}</p>
<p>再举个例子，比如：</p>
<p><strong>func**</strong> main**() {</p>
<p>slice := make([]byte, 3)</p>
<p>n := copy(slice, &quot;abcdef&quot;)</p>
<p>fmt.Println(n,slice)</p>
<p>}</p>
<p>输出：</p>
<p>3 [97,98,99]</p>
<p>说到拷贝，切片中有一个需要注意的问题。</p>
<p>func main() {</p>
<p>slice := [] <strong>int</strong> {10, 20, 30, 40}</p>
<p><strong>for**</strong> index**, value := range slice {</p>
<p>fmt.Printf(&quot;value = %d , value-addr = %x , slice-addr = %x\n&quot;, value, &amp;value, &amp;slice[<strong>index</strong>])</p>
<p>}</p>
<p>}</p>
<p>输出：</p>
<p><strong>value</strong> = 10 , <strong>value</strong> -addr = c4200aedf8 , slice-addr = c4200b0320</p>
<p><strong>value</strong> = 20 , <strong>value</strong> -addr = c4200aedf8 , slice-addr = c4200b0328</p>
<p><strong>value</strong> = 30 , <strong>value</strong> -addr = c4200aedf8 , slice-addr = c4200b0330</p>
<p><strong>value</strong> = 40 , <strong>value</strong> -addr = c4200aedf8 , slice-addr = c4200b0338</p>
<p>从上面结果我们可以看到，如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。所以每次打印 Value 的地址都不变。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_d576ca1982dc9d54.gif"  alt=""></p>
<p>由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 &amp;slice[index] 获取真实的地址。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>切片slice</title>
    <url>/2021/01/09/%E5%88%87%E7%89%87slice/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><h1 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h1><p>需要说明，slice 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案。</p>
<p>1.切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。</p>
<p>2.切片的长度可以改变，因此，切片是一个可变的数组。</p>
<p>3.切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。</p>
<ol start="4">
<li>cap可以求出slice最大扩张容量，不能超出数组限制。0 &amp;lt;= len(slice) &amp;lt;= len(array)，其中array是slice引用的数组。</li>
</ol>
<p>5.切片的定义： <strong>var</strong> 变量名 []类型，比如 <strong>var</strong> str [] <strong>string**</strong> var<strong>arr []</strong>int**。</p>
<p>6.如果 slice == nil，那么 len、cap 结果都等于 0。</p>
<h3 id="创建切片的各种方式"><a href="#创建切片的各种方式" class="headerlink" title="创建切片的各种方式"></a><strong>创建切片的各种方式</strong></h3><p>package main</p>
<p>import &quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p><em>//1.__声明切片</em></p>
<p><strong>var</strong> s1 [] <strong>int</strong></p>
<p><strong>if</strong> s1 == nil {</p>
<p>fmt.Println(&quot;是空&quot;)</p>
<p>} <strong>else</strong> {</p>
<p>fmt.Println(&quot;不是空&quot;)</p>
<p>}</p>
<p><em>// 2.:=</em></p>
<p>s2 := [] <strong>int</strong> {}</p>
<p><em>// 3.make()</em></p>
<p><strong>var</strong> s3 [] <strong>int</strong> = make([] <strong>int</strong> , 0)</p>
<p>fmt.Println(s1, s2, s3)</p>
<p><em>// 4.__初始化赋值</em></p>
<p><strong>var</strong> s4 [] <strong>int</strong> = make([] <strong>int</strong> , 0, 0)</p>
<p>fmt.Println(s4)</p>
<p>s5 := [] <strong>int</strong> {1, 2, 3}</p>
<p>fmt.Println(s5)</p>
<p><em>// 5.__从数组切片</em></p>
<p>arr := [5] <strong>int</strong> {1, 2, 3, 4, 5}</p>
<p><strong>var</strong> s6 [] <strong>int</strong></p>
<p><em>//</em> <em>前包后不包</em></p>
<p>s6 = arr[1:4]</p>
<p>fmt.Println(s6)</p>
<p>}</p>
<h3 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a><strong>切片初始化</strong></h3><p>全局： <strong>var</strong> arr = […] <strong>int</strong> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} <strong>var</strong> slice0 [] <strong>int</strong> = arr[start:end] <strong>var</strong> slice1 [] <strong>int</strong> = arr[:end] <strong>var</strong> slice2 [] <strong>int</strong> = arr[start:] <strong>var</strong> slice3 [] <strong>int</strong> = arr[:] <strong>var</strong> slice4 = arr[:len(arr)-1] <em>//__去掉切片的最后一个元素</em></p>
<p>局部：</p>
<p>arr2 := […] <strong>int</strong> {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}</p>
<p>slice5 := arr[start:end]</p>
<p>slice6 := arr[:end]</p>
<p>slice7 := arr[start:]</p>
<p>slice8 := arr[:]</p>
<p>slice9 := arr[:len(arr)-1] <em>//__去掉切片的最后一个元素</em></p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-48eamj_html_cb2802cfdf90febb.jpg"  alt=""></p>
<p>代码：</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;)</p>
<p><strong>var</strong> arr = […] <strong>int</strong> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} <strong>var</strong> slice0 [] <strong>int</strong> = arr[2:8] <strong>var</strong> slice1 [] <strong>int</strong> = arr[0:6] <em>//__可以简写为</em> <em>var slice []int = arr[:end]</em> <strong>var</strong> slice2 [] <strong>int</strong> = arr[5:10] <em>//__可以简写为</em> <em>var slice[]int = arr[start:]</em> <strong>var</strong> slice3 [] <strong>int</strong> = arr[0:len(arr)] <em>//var slice []int = arr[:]</em> <strong>var</strong> slice4 = arr[:len(arr)-1] _//__去掉切片的最后一个元素_func <strong>main</strong> () {</p>
<p>fmt.Printf(&quot;全局变量：arr %v\n&quot;, arr)</p>
<p>fmt.Printf(&quot;全局变量：slice0 %v\n&quot;, slice0)</p>
<p>fmt.Printf(&quot;全局变量：slice1 %v\n&quot;, slice1)</p>
<p>fmt.Printf(&quot;全局变量：slice2 %v\n&quot;, slice2)</p>
<p>fmt.Printf(&quot;全局变量：slice3 %v\n&quot;, slice3)</p>
<p>fmt.Printf(&quot;全局变量：slice4 %v\n&quot;, slice4)</p>
<p>fmt.Printf(&quot;———————————–\n&quot;)</p>
<p>arr2 := […] <strong>int</strong> {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}</p>
<p>slice5 := arr[2:8]</p>
<p>slice6 := arr[0:6] <em>//__可以简写为</em> <em>slice := arr[:end]</em></p>
<p>slice7 := arr[5:10] <em>//__可以简写为</em> <em>slice := arr[start:]</em></p>
<p>slice8 := arr[0:len(arr)] <em>//slice := arr[:]</em></p>
<p>slice9 := arr[:len(arr)-1] <em>//__去掉切片的最后一个元素</em></p>
<p>fmt.Printf(&quot;局部变量： arr2 %v\n&quot;, arr2)</p>
<p>fmt.Printf(&quot;局部变量： slice5 %v\n&quot;, slice5)</p>
<p>fmt.Printf(&quot;局部变量： slice6 %v\n&quot;, slice6)</p>
<p>fmt.Printf(&quot;局部变量： slice7 %v\n&quot;, slice7)</p>
<p>fmt.Printf(&quot;局部变量： slice8 %v\n&quot;, slice8)</p>
<p>fmt.Printf(&quot;局部变量： slice9 %v\n&quot;, slice9)</p>
<p>}</p>
<p>输出结果：</p>
<p>全局变量： <strong>arr</strong> [0 1 2 3 4 5 6 7 8 9]</p>
<p>全局变量： <strong>slice0</strong> [2 3 4 5 6 7]</p>
<p>全局变量： <strong>slice1</strong> [0 1 2 3 4 5]</p>
<p>全局变量： <strong>slice2</strong> [5 6 7 8 9]</p>
<p>全局变量： <strong>slice3</strong> [0 1 2 3 4 5 6 7 8 9]</p>
<p>全局变量： <strong>slice4</strong> [0 1 2 3 4 5 6 7 8]</p>
<p><strong>———————————–</strong></p>
<p>局部变量： <strong>arr2</strong> [9 8 7 6 5 4 3 2 1 0]</p>
<p>局部变量： <strong>slice5</strong> [2 3 4 5 6 7]</p>
<p>局部变量： <strong>slice6</strong> [0 1 2 3 4 5]</p>
<p>局部变量： <strong>slice7</strong> [5 6 7 8 9]</p>
<p>局部变量： <strong>slice8</strong> [0 1 2 3 4 5 6 7 8 9]</p>
<p>局部变量： <strong>slice9</strong> [0 1 2 3 4 5 6 7 8]</p>
<h3 id="通过-make-来创建切片"><a href="#通过-make-来创建切片" class="headerlink" title="通过** make **来创建切片"></a><strong>通过**</strong> make <strong>**来创建切片</strong></h3><p>var slice []type = make([]type, len)</p>
<p>slice := make([]type, len)</p>
<p>slice := make([]type, len, cap)</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-48eamj_html_d583923fbbb68660.jpg"  alt=""></p>
<p>代码：</p>
<p><strong>package</strong> main</p>
<p>import (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>var slice0 [] <strong>int</strong> = make([] <strong>int</strong> , 10)</p>
<p>var slice1 = make([] <strong>int</strong> , 10)</p>
<p>var slice2 = make([] <strong>int</strong> , 10, 10)</p>
<p>func main() {</p>
<p>fmt.Printf(&quot;make全局slice0 ：%v\n&quot;, slice0)</p>
<p>fmt.Printf(&quot;make全局slice1 ：%v\n&quot;, slice1)</p>
<p>fmt.Printf(&quot;make全局slice2 ：%v\n&quot;, slice2)</p>
<p>fmt.Println(&quot;————————————–&quot;)</p>
<p>slice3 := make([] <strong>int</strong> , 10)</p>
<p>slice4 := make([] <strong>int</strong> , 10)</p>
<p>slice5 := make([] <strong>int</strong> , 10, 10)</p>
<p>fmt.Printf(&quot;make局部slice3 ：%v\n&quot;, slice3)</p>
<p>fmt.Printf(&quot;make局部slice4 ：%v\n&quot;, slice4)</p>
<p>fmt.Printf(&quot;make局部slice5 ：%v\n&quot;, slice5)</p>
<p>}</p>
<p>输出结果：</p>
<p><strong>make</strong> 全局 <strong>slice0</strong> ：[0 0 0 0 0 0 0 0 0 0]</p>
<p><strong>make</strong> 全局 <strong>slice1</strong> ：[0 0 0 0 0 0 0 0 0 0]</p>
<p><strong>make</strong> 全局 <strong>slice2</strong> ：[0 0 0 0 0 0 0 0 0 0]</p>
<p><strong>————————————–</strong></p>
<p><strong>make</strong> 局部 <strong>slice3</strong> ：[0 0 0 0 0 0 0 0 0 0]</p>
<p><strong>make</strong> 局部 <strong>slice4</strong> ：[0 0 0 0 0 0 0 0 0 0]</p>
<p><strong>make</strong> 局部 <strong>slice5</strong> ：[0 0 0 0 0 0 0 0 0 0]</p>
<p>切片的内存布局</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-48eamj_html_206fee43e4c95591.jpg"  alt=""></p>
<p>读写操作实际目标是底层数组，只需注意索引号的差别。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func <strong>main</strong> () {</p>
<p>data := […] <strong>int</strong> {0, 1, 2, 3, 4, 5}</p>
<p>s := data[2:4]</p>
<p>s[0] += 100</p>
<p>s[1] += 200</p>
<p>fmt.Println(s)</p>
<p>fmt.Println(data)</p>
<p>}</p>
<p>输出:</p>
<p>[102203]</p>
<p>[0110220345]</p>
<p>可直接创建 slice 对象，自动分配底层数组。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p>s1 := [] <strong>int</strong> {0, 1, 2, 3, 8: 100} <em>//</em> <em>通过初始化表达式构造，可使用索引号。</em></p>
<p>fmt.Println(s1, len(s1), cap(s1))</p>
<p>s2 := make([] <strong>int</strong> , 6, 8) <em>//</em> <em>使用</em> <em>make</em> <em>创建，指定</em> <em>len</em> <em>和</em> <em>cap</em> <em>值。</em></p>
<p>fmt.Println(s2, len(s2), cap(s2))</p>
<p>s3 := make([] <strong>int</strong> , 6) <em>//</em> <em>省略</em> <em>cap __，相当于</em> <em>cap = len__ 。</em></p>
<p>fmt.Println(s3, len(s3), cap(s3))</p>
<p>}</p>
<p>输出结果:</p>
<p>[01230000100] 99</p>
<p>[000000] 68</p>
<p>[000000] 66</p>
<p>使用 make 动态创建slice，避免了数组必须用常量做长度的麻烦。还可用指针直接访问底层数组，退化成普通数组操作。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;fmt&quot;</p>
<p>func <strong>main</strong> () {</p>
<p>s := [] <strong>int</strong> {0, 1, 2, 3}</p>
<p>p := &amp;s[2] <em>// *int,</em> <em>获取底层数组元素指针。</em></p>
<p>*p += 100</p>
<p>fmt.Println(s)</p>
<p>}</p>
<p>输出结果:</p>
<p>[011023]</p>
<p>至于 [][]T，是指元素类型为 []T 。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func <strong>main</strong> () {</p>
<p>data := [][] <strong>int</strong> {</p>
<p>[] <strong>int</strong> {1, 2, 3},</p>
<p>[] <strong>int</strong> {100, 200},</p>
<p>[] <strong>int</strong> {11, 22, 33, 44},</p>
<p>}</p>
<p>fmt.Println(data)</p>
<p>}</p>
<p>输出结果：</p>
<p>[[123] [100200] [11223344]]</p>
<p>可直接修改 struct array/slice 成员。</p>
<p>package main</p>
<p>import (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func main() {</p>
<p>d := [5]struct {</p>
<p>x int</p>
<p>}{}</p>
<p>s := d[:]</p>
<p>d[1].x = 10</p>
<p>s[2].x = 20</p>
<p>fmt.Println(d)</p>
<p>fmt.Printf(&quot;%p, %p\n&quot;, &amp;d, &amp;d[0])</p>
<p>}</p>
<p>输出结果:</p>
<p>[{0} {10} {20} {0} {0}]</p>
<p>0 <strong>xc4200160f0</strong> , 0 <strong>xc4200160f0</strong></p>
<h3 id="用-append-内置函数操作切片（切片追加）"><a href="#用-append-内置函数操作切片（切片追加）" class="headerlink" title="用** append **内置函数操作切片（切片追加）"></a><strong>用**</strong> append <strong>**内置函数操作切片（切片追加）</strong></h3><p><strong>package</strong> main</p>
<p>import (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func main() {</p>
<p>var a = [] <strong>int</strong> {1, 2, 3}</p>
<p>fmt.Printf(&quot;slice a : %v\n&quot;, a)</p>
<p>var b = [] <strong>int</strong> {4, 5, 6}</p>
<p>fmt.Printf(&quot;slice b : %v\n&quot;, b)</p>
<p>c := append(a, b…)</p>
<p>fmt.Printf(&quot;slice c : %v\n&quot;, c)</p>
<p>d := append(c, 7)</p>
<p>fmt.Printf(&quot;slice d : %v\n&quot;, d)</p>
<p>e := append(d, 8, 9, 10)</p>
<p>fmt.Printf(&quot;slice e : %v\n&quot;, e)</p>
<p>}</p>
<p>输出结果：</p>
<p>slice a : <strong>[1 2 3]</strong></p>
<p>slice b : <strong>[4 5 6]</strong></p>
<p>slice c : <strong>[1 2 3 4 5 6]</strong></p>
<p>slice d : <strong>[1 2 3 4 5 6 7]</strong></p>
<p>slice e : <strong>[1 2 3 4 5 6 7 8 9 10]</strong></p>
<p>append ：向 slice 尾部添加数据，返回新的 slice 对象。</p>
<p><strong>package</strong> main</p>
<p>import (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func main() {</p>
<p>s1 := make([] <strong>int</strong> , 0, 5)</p>
<p>fmt.Printf(&quot;%p\n&quot;, &amp;s1)</p>
<p>s2 := append(s1, 1)</p>
<p>fmt.Printf(&quot;%p\n&quot;, &amp;s2)</p>
<p>fmt.Println(s1, s2)</p>
<p>}</p>
<p>输出结果：</p>
<p>0xc42000a060</p>
<p>0xc42000a080</p>
<p>[] [1]</p>
<h3 id="超出原-slice-cap-限制，就会重新分配底层数组，即便原数组并未填满。"><a href="#超出原-slice-cap-限制，就会重新分配底层数组，即便原数组并未填满。" class="headerlink" title="超出原  slice.cap  限制，就会重新分配底层数组，即便原数组并未填满。"></a><strong>超出原</strong>  <strong>slice.cap</strong>  <strong>限制，就会重新分配底层数组，即便原数组并未填满。</strong></h3><p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func <strong>main</strong> () {</p>
<p>data := […] <strong>int</strong> {0, 1, 2, 3, 4, 10: 0}</p>
<p>s := data[:2:3]</p>
<p>s = append(s, 100, 200) <em>//</em> <em>一次</em> <em>append</em> <em>两个值，超出</em> <em>s.cap</em> <em>限制。</em></p>
<p>fmt.Println(s, data) <em>//</em> <em>重新分配底层数组，与原数组无关。</em></p>
<p>fmt.Println(&amp;s[0], &amp;data[0]) <em>//</em> <em>比对底层数组起始指针。</em></p>
<p>}</p>
<p>输出结果:</p>
<p>[01100200] [01234000000]</p>
<p>0xc4200160f00xc420070060</p>
<p>从输出结果可以看出，append 后的 s 重新分配了底层数组，并复制数据。如果只追加一个值，则不会超过 s.cap 限制，也就不会重新分配。<br>通常以 2 倍容量重新分配底层数组。在大批量添加数据时，建议一次性分配足够大的空间，以减少内存分配和数据复制开销。或初始化足够长的 len 属性，改用索引号进行操作。及时释放不再使用的 slice 对象，避免持有过期数组，造成 GC 无法回收。</p>
<h3 id="slice-中-cap-重新分配规律："><a href="#slice-中-cap-重新分配规律：" class="headerlink" title="slice** 中 cap 重新分配规律：**"></a><strong>slice**</strong> 中 <strong><strong>cap</strong></strong> 重新分配规律：**</h3><p><strong>package</strong> main</p>
<p>import (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func main() {</p>
<p><strong>s</strong> := make([] <strong>int</strong> , 0, 1)</p>
<p>c := cap( <strong>s</strong> )</p>
<p><strong>for</strong> i := 0; i &amp;lt; 50; i++ {</p>
<p><strong>s</strong> = append( <strong>s</strong> , i)</p>
<p><strong>if</strong> n := cap( <strong>s</strong> ); n &amp;gt; c {</p>
<p>fmt.Printf(&quot;cap: %d -&amp;gt; %d\n&quot;, c, n)</p>
<p>c = n</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>输出结果:</p>
<p>cap: 1 -&amp;gt; 2</p>
<p>cap: 2 -&amp;gt; 4</p>
<p>cap: 4 -&amp;gt; 8</p>
<p>cap: 8 -&amp;gt; 16</p>
<p>cap: 16 -&amp;gt; 32</p>
<p>cap: 32 -&amp;gt; 64</p>
<h3 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a><strong>切片拷贝</strong></h3><p><strong>package</strong> main</p>
<p>import (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func main() {</p>
<p>s1 := [] <strong>int</strong> {1, 2, 3, 4, 5}</p>
<p>fmt.Printf(&quot;slice s1 : %v\n&quot;, s1)</p>
<p>s2 := make([] <strong>int</strong> , 10)</p>
<p>fmt.Printf(&quot;slice s2 : %v\n&quot;, s2)</p>
<p>copy(s2, s1)</p>
<p>fmt.Printf(&quot;copied slice s1 : %v\n&quot;, s1)</p>
<p>fmt.Printf(&quot;copied slice s2 : %v\n&quot;, s2)</p>
<p>s3 := [] <strong>int</strong> {1, 2, 3}</p>
<p>fmt.Printf(&quot;slice s3 : %v\n&quot;, s3)</p>
<p>s3 = append(s3, s2…)</p>
<p>fmt.Printf(&quot;appended slice s3 : %v\n&quot;, s3)</p>
<p>s3 = append(s3, 4, 5, 6)</p>
<p>fmt.Printf(&quot;last slice s3 : %v\n&quot;, s3)</p>
<p>}</p>
<p>输出结果：</p>
<p>slice s1 : <strong>[1 2 3 4 5]</strong></p>
<p>slice s2 : <strong>[0 0 0 0 0 0 0 0 0 0]</strong></p>
<p>copied slice s1 : <strong>[1 2 3 4 5]</strong></p>
<p>copied slice s2 : <strong>[1 2 3 4 5 0 0 0 0 0]</strong></p>
<p>slice s3 : <strong>[1 2 3]</strong></p>
<p>appended slice s3 : <strong>[1 2 3 1 2 3 4 5 0 0 0 0 0]</strong></p>
<p>last slice s3 : <strong>[1 2 3 1 2 3 4 5 0 0 0 0 0 4 5 6]</strong></p>
<p>copy ：函数 copy 在两个 slice 间复制数据，复制长度以 len 小的为准。两个 slice 可指向同一底层数组，允许元素区间重叠。</p>
<p><strong>package</strong> main</p>
<p>import (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func main() {</p>
<p>data := […] <strong>int</strong> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</p>
<p>fmt.Println(&quot;array data : &quot;, data)</p>
<p>s1 := data[8:]</p>
<p>s2 := data[:5]</p>
<p>fmt.Printf(&quot;slice s1 : %v\n&quot;, s1)</p>
<p>fmt.Printf(&quot;slice s2 : %v\n&quot;, s2)</p>
<p>copy(s2, s1)</p>
<p>fmt.Printf(&quot;copied slice s1 : %v\n&quot;, s1)</p>
<p>fmt.Printf(&quot;copied slice s2 : %v\n&quot;, s2)</p>
<p>fmt.Println(&quot;last array data : &quot;, data)</p>
<p>}</p>
<p>输出结果:</p>
<p>array data : <strong>[0 1 2 3 4 5 6 7 8 9]</strong></p>
<p>slice s1 : <strong>[8 9]</strong></p>
<p>slice s2 : <strong>[0 1 2 3 4]</strong></p>
<p>copied slice s1 : <strong>[8 9]</strong></p>
<p>copied slice s2 : <strong>[8 9 2 3 4]</strong></p>
<p>last array data : <strong>[8 9 2 3 4 5 6 7 8 9]</strong></p>
<p>应及时将所需数据 copy 到较小的 slice，以便释放超大号底层数组内存。</p>
<h3 id="slice-遍历："><a href="#slice-遍历：" class="headerlink" title="slice** 遍历：**"></a><strong>slice**</strong> 遍历：**</h3><p><strong>package</strong> main</p>
<p>import (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func main() {</p>
<p>data := […] <strong>int</strong> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</p>
<p>slice := data[:]</p>
<p><strong>for**</strong> index**, value := range slice {</p>
<p>fmt.Printf(&quot;inde : %v , value : %v\n&quot;, <strong>index</strong> , value)</p>
<p>}</p>
<p>}</p>
<p>输出结果：</p>
<p>inde : 0 , <strong>value</strong> : 0</p>
<p>inde : 1 , <strong>value</strong> : 1</p>
<p>inde : 2 , <strong>value</strong> : 2</p>
<p>inde : 3 , <strong>value</strong> : 3</p>
<p>inde : 4 , <strong>value</strong> : 4</p>
<p>inde : 5 , <strong>value</strong> : 5</p>
<p>inde : 6 , <strong>value</strong> : 6</p>
<p>inde : 7 , <strong>value</strong> : 7</p>
<p>inde : 8 , <strong>value</strong> : 8</p>
<p>inde : 9 , <strong>value</strong> : 9</p>
<h3 id="切片-resize-（调整大小）"><a href="#切片-resize-（调整大小）" class="headerlink" title="切片** resize **（调整大小）"></a><strong>切片**</strong> resize <strong>**（调整大小）</strong></h3><p><strong>package</strong> main</p>
<p>import (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func main() {</p>
<p>var a = [] <strong>int</strong> {1, 3, 4, 5}</p>
<p>fmt.Printf(&quot;slice a : %v , len(a) : %v\n&quot;, a, len(a))</p>
<p>b := a[1:2]</p>
<p>fmt.Printf(&quot;slice b : %v , len(b) : %v\n&quot;, b, len(b))</p>
<p>c := b[0:3]</p>
<p>fmt.Printf(&quot;slice c : %v , len(c) : %v\n&quot;, c, len(c))</p>
<p>}</p>
<p>输出结果：</p>
<p><strong>slice**</strong> a<strong>: [1 3 4 5] ,</strong>len<strong>(</strong>a**) : 4</p>
<p><strong>slice**</strong> b<strong>: [3] ,</strong>len<strong>(</strong>b**) : 1</p>
<p><strong>slice**</strong> c<strong>: [3 4 5] ,</strong>len<strong>(</strong>c**) : 3</p>
<h3 id="数组和切片的内存布局"><a href="#数组和切片的内存布局" class="headerlink" title="数组和切片的内存布局"></a><strong>数组和切片的内存布局</strong></h3><p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-48eamj_html_d8eead3d66b3df3e.jpg"  alt=""></p>
<h3 id="字符串和切片（-string-and-slice-）"><a href="#字符串和切片（-string-and-slice-）" class="headerlink" title="字符串和切片（** string and slice **）"></a><strong>字符串和切片（**</strong> string and slice <strong>**）</strong></h3><p>string底层就是一个byte的数组，因此，也可以进行切片操作。</p>
<p><strong>package**</strong> main**</p>
<p><strong>import</strong> (</p>
<p>&quot; <strong>fmt</strong>&quot;</p>
<p>)</p>
<p><strong>func**</strong> main**() {</p>
<p>str := &quot;hello world&quot;</p>
<p>s1 := str[0:5]</p>
<p>fmt.Println(s1)</p>
<p>s2 := str[6:]</p>
<p>fmt.Println(s2)</p>
<p>}</p>
<p>输出结果：</p>
<p>hello</p>
<p>world</p>
<p>string本身是不可变的，因此要改变string中字符。需要如下操作：<br>英文字符串：</p>
<p><strong>package**</strong> main**</p>
<p><strong>import</strong> (</p>
<p>&quot; <strong>fmt</strong>&quot;</p>
<p>)</p>
<p><strong>func**</strong> main**() {</p>
<p>str := &quot;Hello world&quot;</p>
<p>s := []byte(str) //中文字符需要用[]rune(str)</p>
<p>s[6] = &#39;G&#39;</p>
<p>s = s[:8]</p>
<p>s = append(s, &#39;!&#39;)</p>
<p>str = string(s)</p>
<p>fmt.Println(str)</p>
<p>}</p>
<p>输出结果：</p>
<p>Hello Go!</p>
<h3 id="含有中文字符串："><a href="#含有中文字符串：" class="headerlink" title="含有中文字符串："></a><strong>含有中文字符串：</strong></h3><p><strong>package**</strong> main**</p>
<p><strong>import</strong> (</p>
<p>&quot; <strong>fmt</strong>&quot;</p>
<p>)</p>
<p><strong>func**</strong> main**() {</p>
<p>str := &quot;你好，世界！hello world！&quot;</p>
<p>s := []rune(str)</p>
<p>s[3] = &#39;够&#39;</p>
<p>s[4] = &#39;浪&#39;</p>
<p>s[12] = &#39;g&#39;</p>
<p>s = s[:14]</p>
<p>str = string(s)</p>
<p>fmt.Println(str)</p>
<p>}</p>
<p>输出结果：</p>
<p>你好，够浪！hello go</p>
<p>golang slice data[:6:8] 两个冒号的理解</p>
<p>常规slice , data[6:8]，从第6位到第8位（返回6， 7），长度len为2， 最大可扩充长度cap为4（6-9）</p>
<p>另一种写法： data[:6:8] 每个数字前都有个冒号， slice内容为data从0到第6位，长度len为6，最大扩充项cap设置为8</p>
<p>a[x:y:z] 切片内容 [x:y] 切片长度: y-x 切片容量:z-x</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func <strong>main</strong> () {</p>
<p>slice := [] <strong>int</strong> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</p>
<p>d1 := slice[6:8]</p>
<p>fmt.Println(d1, len(d1), cap(d1))</p>
<p>d2 := slice[:6:8]</p>
<p>fmt.Println(d2, len(d2), cap(d2))</p>
<p>}</p>
<p>数组or切片转字符串：</p>
<p>strings.Replace(strings.Trim(fmt.Sprint(array_or_slice), &quot;[]&quot;), &quot; &quot;, &quot;,&quot;, -1)</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>基本类型</title>
    <url>/2021/01/09/%E2%80%9D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E2%80%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><h2 id="基本类型介绍"><a href="#基本类型介绍" class="headerlink" title="基本类型介绍"></a><strong>基本类型介绍</strong></h2><p>Golang 更明确的数字类型命名，支持 Unicode，支持常用数据结构。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度(字节)</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>1</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>—</td>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
<td>0</td>
<td>uint8</td>
</tr>
<tr>
<td>rune</td>
<td>4</td>
<td>0</td>
<td>Unicode Code Point, int32</td>
</tr>
<tr>
<td>int, uint</td>
<td>4或8</td>
<td>0</td>
<td>32 或 64 位</td>
</tr>
<tr>
<td>int8, uint8</td>
<td>1</td>
<td>0</td>
<td>-128 ~ 127, 0 ~ 255，byte是uint8 的别名</td>
</tr>
<tr>
<td>int16, uint16</td>
<td>2</td>
<td>0</td>
<td>-32768 ~ 32767, 0 ~ 65535</td>
</tr>
<tr>
<td>int32, uint32</td>
<td>4</td>
<td>0</td>
<td>-21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名</td>
</tr>
<tr>
<td>int64, uint64</td>
<td>8</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>float32</td>
<td>4</td>
<td>0.0</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>float64</td>
<td>8</td>
<td>0.0</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>complex64</td>
<td>8</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>complex128</td>
<td>16</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>uintptr</td>
<td>4或8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>以存储指针的 uint32 或 uint64 整数</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>array</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>值类型</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>struct</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>值类型</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>string</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&quot;&quot;</td>
<td>UTF-8 字符串</td>
<td></td>
<td></td>
</tr>
<tr>
<td>slice</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nil</td>
<td>引用类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>map</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nil</td>
<td>引用类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>channel</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nil</td>
<td>引用类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>interface</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nil</td>
<td>接口</td>
<td></td>
<td></td>
</tr>
<tr>
<td>function</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nil</td>
<td>函数</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>支持八进制、 六进制，以及科学记数法。标准库 math 定义了各数字类型取值范围。</p>
<p>a, b, c, d := 071, 0x1F, 1e9, math.M <strong>in</strong> Int16</p>
<p>空指针值 nil，而非C/C++ NULL。</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a><strong>整型</strong></h3><p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64对应的无符号整型：uint8、uint16、uint32、uint64</p>
<p>其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。</p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a><strong>浮点型</strong></h3><p>Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。</p>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a><strong>复数</strong></h3><p>complex64和complex128</p>
<p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a><strong>布尔值</strong></h3><p>Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。</p>
<p>注意：</p>
<p>布尔类型变量的默认值为false。</p>
<p>Go 语言中不允许将整型强制转换为布尔型.</p>
<p>布尔型无法参与数值运算，也无法与其他类型进行转换。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h3><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(&quot;)中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p>
<p>s1 := &quot;hello&quot;</p>
<p>s2 := &quot;你好&quot;</p>
<h3 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a><strong>字符串转义符</strong></h3><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p>
<table>
<thead>
<tr>
<th>转义</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\r</td>
<td>回车符（返回行首）</td>
</tr>
<tr>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>\n</td>
<td>换行符（直接跳到下一行的同列位置）</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>&#39;</td>
<td>单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
</tbody></table>
<p>举个例子，我们要打印一个Windows平台下的一个文件路径：</p>
<p><strong>package</strong> main <strong>import</strong> (</p>
<p>&quot;fmt&quot;</p>
<p>)</p>
<p>func <strong>main</strong> () {</p>
<p>fmt.Println(&quot;str := &amp;quot;c:\pprof\main.exe&amp;quot;&quot;)</p>
<p>}</p>
<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a><strong>多行字符串</strong></h3><p>Go语言中要定义一个多行字符串时，就必须使用反引号字符：</p>
<p>s1 := `第一行</p>
<p>第二行</p>
<p>第三行</p>
<p>`</p>
<p>fmt.Println(s1)</p>
<p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p>
<h3 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a><strong>字符串的常用操作</strong></h3><table>
<thead>
<tr>
<th>方法</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>len(str)</td>
<td>求长度</td>
</tr>
<tr>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>+或fmt.Sprintf</td>
<td>拼接字符串</td>
</tr>
<tr>
<td>strings.Split</td>
<td>分割</td>
</tr>
<tr>
<td>strings.Contains</td>
<td>判断是否包含</td>
</tr>
<tr>
<td>strings.HasPrefix,strings.HasSuffix</td>
<td>前缀/后缀判断</td>
</tr>
<tr>
<td>strings.Index(),strings.LastIndex()</td>
<td>子串出现的位置</td>
</tr>
<tr>
<td>strings.Join(a[]string, sep string)</td>
<td>join操作</td>
</tr>
</tbody></table>
<h3 id="byte-和-rune-类型"><a href="#byte-和-rune-类型" class="headerlink" title="byte** 和 rune 类型**"></a><strong>byte**</strong> 和 <strong><strong>rune</strong></strong> 类型**</h3><p>组成每个字符串的元素叫做&quot;字符&quot;，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（&#39;）包裹起来，如：</p>
<p><strong>var</strong> a := &#39;中&#39;</p>
<p><strong>var</strong> b := &#39;x&#39;</p>
<p>Go 语言的字符有以下两种：</p>
<p>uint8类型，或者叫 <strong>byte</strong> 型，代表了ASCII码的一个字符。</p>
<p>rune类型，代表一个 UTF-8字符。</p>
<p>当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。<br> Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾</p>
<p><em>//</em> <em>遍历字符串</em></p>
<p>func <strong>traversalString</strong> () {</p>
<p>s := &quot;pprof.cn博客&quot;</p>
<p><strong>for</strong> i := 0; i &amp;lt; len(s); i++ { <em>//byte</em></p>
<p>fmt.Printf(&quot;%v(%c) &quot;, s[i], s[i])</p>
<p>}</p>
<p>fmt.Println()</p>
<p><strong>for</strong> _, r := range s { <em>//rune</em></p>
<p>fmt.Printf(&quot;%v(%c) &quot;, r, r)</p>
<p>}</p>
<p>fmt.Println()</p>
<p>}</p>
<p>输出：</p>
<p>112(p) 112(p) 114(r) 111(o) 102(f) 46(.) 99(c) 110(n) 229(å) 141() 154() 229(å) 174(®) 162(¢)</p>
<p>112(p) 112(p) 114(r) 111(o) 102(f) 46(.) 99(c) 110(n) 21338(博) 23458(客)</p>
<p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p>
<p>字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p>
<h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a><strong>修改字符串</strong></h3><p>要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<p>func <strong>changeString</strong> () {</p>
<p>s1 := &quot;hello&quot;</p>
<p><em>//</em> <em>强制类型转换</em></p>
<p>byteS1 := [] <strong>byte</strong> (s1)</p>
<p>byteS1[0] = &#39;H&#39;</p>
<p>fmt.Println( <strong>string</strong> (byteS1))</p>
<p>s2 := &quot;博客&quot;</p>
<p>runeS2 := []rune(s2)</p>
<p>runeS2[0] = &#39;狗&#39;</p>
<p>fmt.Println( <strong>string</strong> (runeS2))</p>
<p>}</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a><strong>类型转换</strong></h3><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p>
<p>强制类型转换的基本语法如下：</p>
<p>T(表达式)</p>
<p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p>
<p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p>
<p>func <strong>sqrtDemo</strong> () {</p>
<p><strong>var</strong> a, b = 3, 4</p>
<p><strong>var</strong> c <strong>int</strong></p>
<p><em>// math.Sqrt() <strong>接收的参数是</strong> float64__类型，需要强制转换</em></p>
<p>c = <strong>int</strong> (math.Sqrt(float64(a*a + b*b)))</p>
<p>fmt.Println(c)</p>
<p>}</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>命令</title>
    <url>/2021/01/08/%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>假如你已安装了golang环境，你可以在命令行执行go命令查看相关的Go语言命令：</p>
<p>$ go</p>
<p>Go is a tool for managing Go source code.</p>
<p>Usage:</p>
<p>go command [arguments]</p>
<p>The commands are:</p>
<p>build compile packages and dependencies</p>
<p>clean remove object files</p>
<p>doc <strong>show</strong> documentation <strong>for**</strong> package <strong>**or</strong> symbol</p>
<p>env print <strong>Go</strong> environment information</p>
<p>bug <strong>start</strong> a bug report</p>
<p>fix run <strong>go</strong> tool fix <strong>on</strong> packages</p>
<p>fmt run gofmt <strong>on**</strong> package** sources</p>
<p>generate generate <strong>Go</strong> files <strong>by</strong> processing <strong>source</strong></p>
<p><strong>get</strong> download <strong>and**</strong> install <strong>packages</strong> and** dependencies</p>
<p><strong>install</strong> compile <strong>and**</strong> install <strong>packages</strong> and** dependencies</p>
<p><strong>list**</strong> list** packages</p>
<p>run compile <strong>and</strong> run <strong>Go</strong> program</p>
<p><strong>test**</strong> test** packages</p>
<p>tool run specified <strong>go</strong> tool</p>
<p><strong>version</strong> print <strong>Go**</strong> version**</p>
<p>vet run <strong>go</strong> tool vet <strong>on</strong> packages</p>
<p><strong>Use</strong>&quot;go help [command]&quot; <strong>for</strong> more information about a command.</p>
<p>Additional <strong>help</strong> topics:</p>
<p>c <strong>calling**</strong> between <strong><strong>Go</strong></strong> and** C</p>
<p>buildmode description <strong>of**</strong> build** modes</p>
<p>filetype <strong>file</strong> types</p>
<p>gopath GOPATH environment <strong>variable</strong></p>
<p>environment environment <strong>variables</strong></p>
<p>importpath <strong>import**</strong> path** syntax</p>
<p>packages description <strong>of**</strong> package** lists</p>
<p>testflag description <strong>of</strong> testing flags</p>
<p>testfunc description <strong>of</strong> testing functions</p>
<p><strong>Use</strong>&quot;go help [topic]&quot; <strong>for</strong> more information about that topic.</p>
<p>go env用于打印Go语言的环境信息。</p>
<p>go run命令可以编译并运行命令源码文件。</p>
<p>go get可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。</p>
<p>go build命令用于编译我们指定的源码文件或代码包以及它们的依赖包。</p>
<p>go install用于编译并安装指定的代码包及它们的依赖包。</p>
<p>go clean命令会删除掉执行其它命令时产生的一些文件和目录。</p>
<p>go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。</p>
<p>go test命令用于对Go语言编写的程序进行测试。</p>
<p>go list命令的作用是列出指定的代码包的信息。</p>
<p>go fix会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。</p>
<p>go vet是一个用于检查Go语言源码中静态错误的简单工具。</p>
<p>go tool pprof命令来交互式的访问概要文件的内容。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Init函数和main函数</title>
    <url>/2021/01/08/Init%E5%87%BD%E6%95%B0%E5%92%8Cmain%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h1><h1 id="函数和"><a href="#函数和" class="headerlink" title="函数和"></a>函数和</h1><h1 id="main"><a href="#main" class="headerlink" title="main"></a>main</h1><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="init-函数"><a href="#init-函数" class="headerlink" title="init** 函数**"></a><strong>init**</strong> 函数**</h2><p>go语言中init函数用于包(package)的初始化，该函数是go语言的一个重要特性。</p>
<p>有下面的特征：</p>
<p>1 init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等</p>
<p>2 每个包可以拥有多个init函数</p>
<p>3 包的每个源文件也可以拥有多个init函数</p>
<p>4 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)</p>
<p>5 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序</p>
<p>6 init函数不能被其他函数调用，而是在main函数执行之前，自动被调用</p>
<h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main** 函数**"></a><strong>main**</strong> 函数**</h2><p>Go语言程序的默认入口函数(主函数)：func <strong>main</strong> ()</p>
<p>函数体用｛｝一对括号包裹。</p>
<p>func <strong>main</strong> (){</p>
<p><em>//__函数体</em></p>
<p>}</p>
<h2 id="init-函数和-main-函数的异同"><a href="#init-函数和-main-函数的异同" class="headerlink" title="init** 函数和 main 函数的异同**"></a><strong>init**</strong> 函数和 <strong><strong>main</strong></strong> 函数的异同**</h2><p>相同点：</p>
<p>两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。</p>
<p>不同点：</p>
<p>init可以应用于任意包中，且可以重复定义多个。</p>
<p>main函数只能用于main包中，且只能定义一个。</p>
<p>两个函数的执行顺序：</p>
<p>对同一个go文件的init()调用顺序是从上到下的。</p>
<p>对同一个package中不同文件是按文件名字符串比较&quot;从小到大&quot;顺序调用各文件中的init()函数。</p>
<p>对于不同的package，如果不相互依赖的话，按照main包中&quot;先import的后调用&quot;的顺序调用其包中的init()，如果package存在依赖，则先调用最早被依赖的package中的init()，最后调用main函数。</p>
<p>如果init函数中使用了println()或者print()你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang内置类型和函数</title>
    <url>/2021/01/07/golang%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#</p>
<h1 id="1-Golang"><a href="#1-Golang" class="headerlink" title="1. Golang"></a><strong>1. Golang</strong></h1><h1 id="内置类型和函数"><a href="#内置类型和函数" class="headerlink" title="内置类型和函数"></a><strong>内置类型和函数</strong></h1><h2 id="1-1-内置类型"><a href="#1-1-内置类型" class="headerlink" title="1.1.  内置类型"></a><strong>1.1.</strong>  <strong>内置类型</strong></h2><h3 id="1-1-1-值类型："><a href="#1-1-1-值类型：" class="headerlink" title="1.1.1.  值类型："></a><strong>1.1.1.</strong>  <strong>值类型：</strong></h3><p>bool</p>
<p>int(32 or 64), int8, int16, int32, int64</p>
<p>uint(32 or 64), uint8(byte), uint16, uint32, uint64</p>
<p>float32, float64</p>
<p>string</p>
<p>complex64, complex128</p>
<p>array – 固定长度的数组</p>
<h3 id="1-1-2-引用类型：-指针类型"><a href="#1-1-2-引用类型：-指针类型" class="headerlink" title="1.1.2.  引用类型：** ( 指针类型 )**"></a><strong>1.1.2.</strong>  <strong>引用类型：**</strong> ( <strong><strong>指针类型</strong></strong> )**</h3><p>slice – 序列数组(最常用)</p>
<p>map – 映射</p>
<p>chan – 管道</p>
<h2 id="1-2-内置函数"><a href="#1-2-内置函数" class="headerlink" title="1.2.  内置函数"></a><strong>1.2.</strong>  <strong>内置函数</strong></h2><p>Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。</p>
<p>append – 用来追加元素到数组、slice中,返回修改后的数组、slice</p>
<p>close – 主要用来关闭channel</p>
<p>delete – 从map中删除key对应的value</p>
<p>panic – 停止常规的goroutine （panic和recover：用来做错误处理）</p>
<p>recover – 允许程序定义goroutine的panic动作</p>
<p>real – 返回complex的实部 （complex、real imag：用于创建和操作复数）</p>
<p>imag – 返回complex的虚部</p>
<p>make – 用来分配内存，返回Type本身(只能应用于slice, map, channel)</p>
<p>new – 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针</p>
<p>cap – capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</p>
<p>copy – 用于复制和连接slice，返回复制的数目</p>
<p>len – 来求长度，比如string、array、slice、map、channel ，返回长度</p>
<p>print、println – 底层打印函数，在部署环境中建议使用 fmt 包</p>
<h2 id="1-3-内置接口-error"><a href="#1-3-内置接口-error" class="headerlink" title="1.3.  内置接口** error**"></a><strong>1.3.</strong>  <strong>内置接口**</strong> error**</h2><p>type error interface { //只要实现了Error()函数，返回值为String的都实现了err接口</p>
<p>Error() String</p>
<p>}</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>内置对象</title>
    <url>/2020/04/18/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<p>title: 内置函数<br>date: 2019-1-1 13:12:57<br>categories:</p>
<ul>
<li>web前端<br>tags:</li>
<li>web前端</li>
<li>内置对象</li>
<li>创建对象的三种方法</li>
<li>构造函数和对象的相互联系</li>
</ul>
<hr>
<h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4>]]></content>
  </entry>
  <entry>
    <title>new关键字</title>
    <url>/2019/12/30/new%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h4><p>1.new构造函数可以在内存中创建一个空的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Star(uname,age,sex)&#123;</span><br><span class="line">    this.name &#x3D; unmae;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.sex &#x3D; sex;</span><br><span class="line">&#125;</span><br><span class="line">var ldh &#x3D; new Star(&#39;刘&#39;,18,&#39;男&#39;);</span><br></pre></td></tr></table></figure>
<p>2.this就会指向刚刚创建的空对象。</p>
<p>3.执行构造函数里面的代码，给这个空对象添加属性和方法.</p>
<p>4.返回这个对象（new的作用），所以构造函数里面不需要return.</p>
<h5 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h5><p>因为属性是无序的，所以无法使用for循环</p>
<blockquote>
<p>for …in语句用于对数组或者对象（最合适的）的属性进行循环操作.</p>
</blockquote>
<p>使用方法</p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(变量 in 对象)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">例子：</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    name : &#39;ldh&#39;;</span><br><span class="line">    gae : 18;</span><br><span class="line">    sex : &#39;男&#39;</span><br><span class="line">&#125;</span><br><span class="line">for(var K in obj)&#123;</span><br><span class="line">    consloe.log(obj[K]); &#x2F;&#x2F;对象名[变量],obj[K]得到是属性值</span><br><span class="line">    &#x2F;&#x2F;我们使用for...in 里面的变量我们喜欢写K或者Key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>new关键字</tag>
        <tag>遍历对象</tag>
      </tags>
  </entry>
  <entry>
    <title>对象</title>
    <url>/2019/12/30/%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象是一个具体的事物，是由属性和方法组成的。</p>
<p><strong>属性</strong></p>
<blockquote>
<p>事物的特征，在对象中用属性来表示（常用名词）</p>
</blockquote>
<p><strong>方法</strong></p>
<blockquote>
<p>事物的行为，在对象中用方法来表示（常用动词）</p>
</blockquote>
<hr>
<h4 id="创建对象的三种方法"><a href="#创建对象的三种方法" class="headerlink" title="创建对象的三种方法"></a>创建对象的三种方法</h4><ol>
<li>利用字面量创建对象<blockquote>
<p>对象字面量{ }：花括号里面包含了表达式这个具体事物（对象）的属性和方法。</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D;&#123; &#125;;&#x2F;&#x2F;创建了一个空的对象。</span><br><span class="line">&#x2F;&#x2F;1.里面的属性或者方法采用键值对的形式  健属性名：值属性值</span><br><span class="line">&#x2F;&#x2F;2.多个属性和方法中间采用逗号隔开的。</span><br><span class="line">&#x2F;&#x2F;3.方法冒号后面跟着的是一个匿名函数的。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>利用new object创建对象</p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D;new object();</span><br><span class="line">obj.uname &#x3D; &#39;张三&#39;;</span><br><span class="line">obj.age &#x3D; 18;</span><br><span class="line">obj.sex &#x3D; &#39;男&#39;;</span><br><span class="line">obj.SayHi &#x3D; function()&#123;</span><br><span class="line">    console.log(&#39;hi~&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 1.利用等号赋值的方法，添加对象的属性和方法。</span><br><span class="line">&#x2F;&#x2F; 2.每个属性和方法之间用分号结束。</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用构造函数创建对象</p>
<blockquote>
<p>我们为什么需要使用构造函数，就是因为我们前面两种创建对象的方式一次只能创建一个对象，因此我们可以利用函数的方法，重复这些相同的代码，我们就把这个函数称为构造函数。</p>
</blockquote>
</li>
</ol>
<p>构造函数语法格式：</p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function 构造函数名()&#123;</span><br><span class="line">    this.属性 &#x3D; 值;</span><br><span class="line">    this.方法 &#x3D; function()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用构造函数：new 构造函数名();</p>
<p>案例：</p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Star(uname,age,sex)&#123;</span><br><span class="line">    this.name &#x3D; unmae;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.sex &#x3D; sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nes Star(&#39;刘德华&#39;,18,&#39;男&#39;);</span><br><span class="line">&#x2F;&#x2F;1.构造函数名字首字母要大写.</span><br><span class="line">&#x2F;&#x2F;2.构造函数不需要retun就可以返回结果.</span><br><span class="line">&#x2F;&#x2F;3.调用构造函数必须使用new.</span><br><span class="line">&#x2F;&#x2F;4.只要new Star()调用函数就创建一个对象.</span><br><span class="line">&#x2F;&#x2F;5.构造函数的属性和方法前面必须添加this.</span><br></pre></td></tr></table></figure>
<p>构造函数和对象的相互联系</p>
<ol>
<li>构造函数：它类似于Java语言里面的类class（泛指的某一大类）.</li>
<li>对象：特指一个具体的事物.</li>
<li>利用构造函数创建对象的过程我们也称为对象的实例化.</li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>对象</tag>
        <tag>创建对象的三种方法</tag>
        <tag>构造函数和对象的相互联系</tag>
      </tags>
  </entry>
  <entry>
    <title>变量作用域</title>
    <url>/2019/12/29/%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ol>
<li>全局变量在代码的任何位置都可以使用</li>
<li>特殊情况下，在函数内不使用var声明的变量也是全局变量（不建议使用）.</li>
</ol>
<p>局部变量：形参可以视为局部变量.</p>
<p>js也是在ES6的时候新增的块级作用域{  }.</p>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><ol>
<li>只要是代码，就至少有一个作用域.</li>
<li>写在函数内部的局部作用域.</li>
<li>如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域.</li>
<li>根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链，预解析运行、JS分为预解析、代码执行.</li>
</ol>
<ul>
<li>预解析JS引擎会把JS里面所有 var还有function提升到当前作用域的最前面.<h5 id="预解析分为变量预解析（变量提升）-（函数提升）"><a href="#预解析分为变量预解析（变量提升）-（函数提升）" class="headerlink" title="- 预解析分为变量预解析（变量提升）..（函数提升）"></a>- 预解析分为变量预解析（变量提升）..（函数提升）</h5></li>
</ul>
<ol>
<li>变量提升，把所有的变量声明提升到当前的作用域最前面.</li>
<li>函数提升，把所有函数声明提升到当前，不提升赋值操作，作用域的最前面，不调用函数.</li>
</ol>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1();</span><br><span class="line">console.log(c);</span><br><span class="line">console.log(b);</span><br><span class="line">console.log(a);</span><br><span class="line">function f1()&#123;</span><br><span class="line">    var a&#x3D;b&#x3D;c&#x3D;9;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>var a=b=c=9;   相当于var a=9; b=9;c=9;(没有var声明当全局变量看)</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>作用域链</tag>
        <tag>预解析分为变量预解析（变量提升）..（函数提升）</tag>
      </tags>
  </entry>
  <entry>
    <title>短路运算</title>
    <url>/2019/12/28/%E9%80%BB%E8%BE%91%E4%B8%AD%E6%96%AD%EF%BC%8C%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="短路运算（逻辑判断）"><a href="#短路运算（逻辑判断）" class="headerlink" title="短路运算（逻辑判断）"></a>短路运算（逻辑判断）</h4><p>短路运算的原理：当有多个表达式（值）时，左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值：</p>
<html>
<!--在这里插入内容-->
<ol>
<li>逻辑与</li>
语法：表达式为真，则返回值表达式2

<p>如果第一个表达式为真，则返回表达式2</p>
<p>如果第一个表达式为假，则返回表达式1</p>
<li>逻辑或短路运算</li>
如果表达式1为真，则返回表达式1，如果表达式1为假，则返回表达式2

<p>逻辑与和逻辑或优先级</p>
<p>先算与后算或</p>
</ol>
</html>

<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><ol>
<li>首先执行里面的计算器变量 var i = 1.但是这句话在for里面只执行一次 index.</li>
<li>去 i&lt;=100 求判断是否满足条件，如果满足条件，就去执行循环体,不满足条件退出循环.</li>
<li>最后去执行 i++. i++是单独写的代码，递增，第一轮结束.</li>
<li>接着去执行 i &lt;= 100 如果满足条件，就去执行循环体，不满足条件退出循环第二轮.</li>
</ol>
<h4 id="断点调试方法"><a href="#断点调试方法" class="headerlink" title="断点调试方法"></a>断点调试方法</h4><p>for 循环可以重复执行不同的代码，因为我们有计数器变量 i 的存在，i 每次循环值都会变化.</p>
<p>外层控制行数，内层控制列数</p>
<p>双重for循环，外层循环一次，内层for循环全部.</p>
<p>for循环是循环条件和数字直接相关的循环.</p>
<h4 id="函数-arguments的使用"><a href="#函数-arguments的使用" class="headerlink" title="函数 arguments的使用"></a>函数 arguments的使用</h4><p>当不确定有多少参数传递的时候，可以用argments来获取.在Javascript中，arguments事实际上它是当前函数的一个内置对象，所有函数都内置了一个arguments对象，arguments对象中存储有了传递的所有实参.</p>
<p>arguments里面存储了所有传递过来的实参.</p>
<p>//伪数组，并不是真正意义上的数组.</p>
<p>//<html></p>
<!--在这里插入内容-->
<ol>
<li>具有数组的length属性</li>
<li>按照索引的方式进行存储的</li>
<li>它没有真正数组的一些方法，pop(),push().</li>
<li>只有函数才内置好了arguments对象（匿名函数）</li>
</ol>
</html>

<p>函数的2种声明方式</p>
<ol>
<li>利用函数关键字自定义命名函数</li>
<li>函数表达式：var 变量名 = function(){  };</li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>逻辑判断</tag>
        <tag>循环</tag>
        <tag>断点调试方法</tag>
        <tag>函数 arguments的使用</tag>
      </tags>
  </entry>
  <entry>
    <title>变量命名规范</title>
    <url>/2019/12/27/js%E5%8F%98%E9%87%8F%E3%80%81js%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h3><ul>
<li><h6 id="由字母、数字、下划线、美元符号组成"><a href="#由字母、数字、下划线、美元符号组成" class="headerlink" title="由字母、数字、下划线、美元符号组成"></a>由字母、数字、下划线、美元符号组成</h6></li>
<li><h6 id="严格区分大小写"><a href="#严格区分大小写" class="headerlink" title="严格区分大小写"></a>严格区分大小写</h6></li>
<li><h6 id="不能以数字开头"><a href="#不能以数字开头" class="headerlink" title="不能以数字开头"></a>不能以数字开头</h6></li>
<li><h6 id="不能是关键字"><a href="#不能是关键字" class="headerlink" title="不能是关键字"></a>不能是关键字</h6></li>
<li><h6 id="变量名义必须有意义"><a href="#变量名义必须有意义" class="headerlink" title="变量名义必须有意义"></a>变量名义必须有意义</h6></li>
<li><h6 id="遵守驼峰命名法。首字母小写，后面的首字母需要大写"><a href="#遵守驼峰命名法。首字母小写，后面的首字母需要大写" class="headerlink" title="遵守驼峰命名法。首字母小写，后面的首字母需要大写"></a>遵守驼峰命名法。首字母小写，后面的首字母需要大写</h6></li>
<li><h6 id="推荐翻译工具：有道、爱词霸"><a href="#推荐翻译工具：有道、爱词霸" class="headerlink" title="推荐翻译工具：有道、爱词霸"></a>推荐翻译工具：有道、爱词霸</h6></li>
</ul>
<h5 id="在JS中加0为八进制"><a href="#在JS中加0为八进制" class="headerlink" title="在JS中加0为八进制"></a>在JS中加0为八进制</h5><h5 id="十六进制的前面加OX"><a href="#十六进制的前面加OX" class="headerlink" title="十六进制的前面加OX"></a>十六进制的前面加OX</h5><p>infinity 代表无穷大，大于任何数值</p>
<p>-infinity代表无穷小，小于任何数</p>
<p>NAN Not a Number 代表一个非数值</p>
<p>isNAN（）这个方法用来判断非数字，如果是数字返回false，如果不是数字返回true</p>
<h4 id="字符型转换为数字型"><a href="#字符型转换为数字型" class="headerlink" title="字符型转换为数字型"></a>字符型转换为数字型</h4><p>parseInt(string)</p>
<p>parseFloat(string)</p>
<p>Number()</p>
<p>==JS隐式转换利用算数运算符隐式转换为数值型==</p>
<p>例如 - * /</p>
<h4 id="数据类型转换为布尔类型"><a href="#数据类型转换为布尔类型" class="headerlink" title="数据类型转换为布尔类型"></a>数据类型转换为布尔类型</h4><ol>
<li><p>代表空、否定的值会被转换为false.如“0”、NaN、NULL、undefined其余值都会被转换为true.</p>
</li>
<li><p>浮点数、算数运算里面会有问题.</p>
</li>
<li><p>前置自增和后；置自增如果单独使用效果是一样的.</p>
</li>
<li><p>后置自增口诀：先返回原值后自加1.</p>
</li>
<li><p>后置自增口诀：先自加1，后返回值.</p>
</li>
</ol>
<p>比较会返回一个布尔值.</p>
<p>==默认转换数据类型（判断两边值是否相等）.</p>
<ol>
<li>我们程序里面等于符号是==默认转换数据类型，会把字符串的数据转换为数字型，只要求值相等就可以.</li>
<li>===全等要求两侧的值还有数据类型完全一致就可以.（判断两边的值和数据类型是否完全相同）.</li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>变量命名规范</tag>
        <tag>字符型转换为数字型</tag>
        <tag>数据类型转换为布尔类型</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML（2）</title>
    <url>/2019/12/04/HTML%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="HTML（2）"><a href="#HTML（2）" class="headerlink" title="HTML（2）"></a>HTML（2）</h4><h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><p>目标</p>
<ul>
<li>理解<ul>
<li>能说出表格用来做什么的</li>
<li>表格的基本结构组成</li>
</ul>
</li>
<li>应用<ul>
<li>能够熟练写出n行n列的表格</li>
<li>能够简单的合并单元格</li>
</ul>
</li>
</ul>
<h5 id="表格作用"><a href="#表格作用" class="headerlink" title="表格作用"></a>表格作用</h5><hr />
表格不是用来布局的，表格是用来展示表格数据的，因为它可以让数据显示的非常的规整，可读性非常好。

<p>特别是后台展示数据的时候，表格运用是否熟练就显得非常重要，一个清爽简约的表格能够把繁杂的数据表现得很有条理，虽然div布局也可以做到，但是总没有表格来的方便。</p>
<h6 id="1-创建表格"><a href="#1-创建表格" class="headerlink" title="1.创建表格"></a>1.创建表格</h6><hr />
在HTML网页中，要想创建表格，就需要使用表格相关的标签。

<h5 id="创建表格的相关语法"><a href="#创建表格的相关语法" class="headerlink" title="创建表格的相关语法"></a>创建表格的相关语法</h5><blockquote>
<p>&lt;table&#62;<br />&emsp;&emsp;&emsp;&lt;tr&#62;<br />&emsp;&emsp;&emsp;&emsp;&emsp;&lt;td&#62;单元格内的文字&lt;/td&#62;<br />&emsp;&emsp;&emsp;…<br />&emsp;&emsp;&emsp;&lt;tr/&#62;<br />&emsp;&emsp;&emsp;…<br />&lt;/table&#62;</p>
</blockquote>
<p>要深刻体会表格、行、单元格他们的构成。</p>
<p>在上面的语法中包含基本的三对HTMLb标签，分别为table、tr、td，它们是创建表格的基本标签，缺一不可，下面对他们进行具体的解释</p>
<ol>
<li>table用于定义一个表格标签</li>
<li>tr标签用于定义表格中的行，必须嵌套在table标签中</li>
<li>tdy用于定义表格中的单元格，必须嵌套在&lt;tr&#62;&lt;/tr&#62;标签中</li>
<li>字母td指表格数据（table date）,即数据单元格的内容，表格最适合的地方就是用来存储数据的</li>
</ol>
<h6 id="2-表格属性"><a href="#2-表格属性" class="headerlink" title="2.表格属性"></a>2.表格属性</h6><hr />

<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th>常用属性值</th>
</tr>
</thead>
<tbody><tr>
<td>border</td>
<td>设置表格的边框（默认border=”0” 无边框）</td>
<td>像素值</td>
</tr>
<tr>
<td>cellspacing</td>
<td>设置单元格与单元格边框之间的空白间距</td>
<td>像素值（默认为2像素）</td>
</tr>
<tr>
<td>cellpading</td>
<td>设置单元格内容与单元格边框之间的空白间距</td>
<td>像素值（默认1像素）</td>
</tr>
<tr>
<td>width</td>
<td>设置表格的宽度</td>
<td>像素值</td>
</tr>
<tr>
<td>height</td>
<td>设置表格的高度</td>
<td>像素值</td>
</tr>
<tr>
<td>align</td>
<td>设置表格在网页种的水平对齐方式</td>
<td>left、center、right</td>
</tr>
</tbody></table>
<h6 id="3-表头单元格th"><a href="#3-表头单元格th" class="headerlink" title="3.表头单元格th"></a>3.表头单元格th</h6><hr />

<ul>
<li>作用</li>
</ul>
<p>一般表头单元格位于表格的第一行或第一列，并且文本加粗居中</p>
<ul>
<li>语法</li>
</ul>
<p>只需用表头标签&lt;th&#62;&lt;/th&#62;替代相应的单元格标签&lt;td&#62;&lt;/td&#62;即可。</p>
<h6 id="4-表格标题caption"><a href="#4-表格标题caption" class="headerlink" title="4.表格标题caption"></a>4.表格标题caption</h6><p>定义和用法：</p>
<blockquote>
<p>&lt;table&#62;<br/>&ensp;&ensp;&lt;caption&#62;我是表格标题&lt;/caption&#62;<br/>&lt;/table&#62;</p>
</blockquote>
<p>注意：</p>
<ol>
<li>caption元素定义表格标题，通常这个标题会被居中且显示于表格之上。</li>
<li>caption标签必须紧随table标签之后</li>
<li>这个标签只存在表格里面才有意义</li>
</ol>
<h6 id="5-合并单元格"><a href="#5-合并单元格" class="headerlink" title="5.合并单元格"></a>5.合并单元格</h6><hr / >
合并单元格是我们比较常用的一个操作，但是不会合并的很复杂。

<h6 id="5-1合并单元格2种方式"><a href="#5-1合并单元格2种方式" class="headerlink" title="5.1合并单元格2种方式"></a>5.1合并单元格2种方式</h6><ul>
<li>跨行合并：rowspan=”合并单元格的个数”</li>
<li>跨列合并：colspan=”合并单元格的个数”</li>
</ul>
<p>合并单元格三部曲：</p>
<ol>
<li>先确定是跨行还是跨列合并</li>
<li>根据先上后下先左后右的原则找到目标单元格，然后写上合并方式还有要合并的单元格数量，比如：&lt;td&emsp;colspan=”3”&gt;&lt;/td&#62;</li>
<li>删除多余的单元格</li>
</ol>
<h5 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h5><hr />

<h6 id="1-1无序列表"><a href="#1-1无序列表" class="headerlink" title="1.1无序列表"></a>1.1无序列表</h6><p>无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下：</p>
<blockquote>
<p>&lt;ul&#62;<br />&ensp;&ensp;&lt;li&#62;列表项1&lt;/li&#62;<br />&ensp;&ensp;&lt;li&#62;列表项1&lt;/li&#62;<br />&ensp;&ensp;&lt;li&#62;列表项1&lt;/li&#62;<br />&ensp;&ensp;…<br />&lt;/ul&#62;</p>
</blockquote>
<h6 id="1-2有序列表"><a href="#1-2有序列表" class="headerlink" title="1.2有序列表"></a>1.2有序列表</h6><p>有序列表即为有排列顺序的列表，其各个列表按照一定的顺序排列定义，有序列表的基本语法格式如下：</p>
<blockquote>
<p>&lt;ol&#62;<br />&ensp;&ensp;&lt;li&#62;列表项1&lt;/li&#62;<br />&ensp;&ensp;&lt;li&#62;列表项1&lt;/li&#62;<br />&ensp;&ensp;&lt;li&#62;列表项1&lt;/li&#62;<br />&ensp;&ensp;…<br />&lt;/ol&#62;</p>
</blockquote>
<h6 id="1-3自定义列表"><a href="#1-3自定义列表" class="headerlink" title="1.3自定义列表"></a>1.3自定义列表</h6><blockquote>
<p>&lt;dl&#62;<br />&ensp;&ensp;&lt;dt&#62;名词&lt;/dt&#62;<br />&ensp;&ensp;&lt;dd&#62;名词解释1&lt;/dd&#62;<br />&ensp;&ensp;&lt;dd&#62;名词解释2&lt;/dd&#62;<br />&ensp;&ensp;…<br />&lt;/dl&#62;</p>
</blockquote>
<p>两兄弟dt和dd，dd和dt是并列关系</p>
<h5 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h5><hr />
表单的目的是为了收集用户信息。
> 在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3部分构成。

<h6 id="2-1-input控件"><a href="#2-1-input控件" class="headerlink" title="2.1 input控件"></a>2.1 input控件</h6><p>语法</p>
<blockquote>
<p>&lt;input type =”属性值“ value=”你好”&#62;</p>
</blockquote>
<ul>
<li>input输入的意思</li>
<li><input/>标签为单标签</li>
<li>type属性设置不同的属性值用来指定不同的控件类型</li>
<li>除了type属性还有别的属性</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>text</td>
<td>单行文本输入框</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>password</td>
<td>密码输入框</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>radio</td>
<td>单选按钮</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>checkbox</td>
<td>复选框</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>button</td>
<td>普通按钮</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>submit</td>
<td>提交按钮</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>reset</td>
<td>重置按钮</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>image</td>
<td>图象形式的提交按钮</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>file</td>
<td>文件域</td>
</tr>
<tr>
<td>name</td>
<td>由用户自定义</td>
<td>控件名称</td>
</tr>
<tr>
<td>value</td>
<td>由用户自定义</td>
<td>input控件中的默认文本值</td>
</tr>
<tr>
<td>size</td>
<td>正整数</td>
<td>input控件在页面中的显示宽度</td>
</tr>
<tr>
<td>checked</td>
<td>checked</td>
<td>定义选择控件默认被选中的项</td>
</tr>
<tr>
<td>maxlength</td>
<td>正整数</td>
<td>控件允许输入的最多字符数</td>
</tr>
</tbody></table>
<p>radio单选按钮可以通过name属性进行区分,让几个中只能选择一个。</p>
<p>checkbox复选框按钮可以通过设置name属性进行多选。</p>
<p>checked属性设置默认选中项目（一般单选按钮和复选按钮才会有）。</p>
<p>普通按钮需要写value值，提交按钮不需要，图片提交按钮里面必须包含src属性</p>
<h6 id="2-2label标签"><a href="#2-2label标签" class="headerlink" title="2.2label标签"></a>2.2label标签</h6><hr />
目的：

<p>label标签主要目的是为了提高用户体验。为用户提供最优秀的服务。</p>
<p><strong>概念：</strong></p>
<p>label标签为input元素定义标注(标签)。</p>
<p><strong>作用：</strong></p>
<p>用于绑定一个表单元素，当点击label标签的时候，被绑定的表单元素就会获得输入焦点。</p>
<p><strong>如何绑定元素呢？</strong></p>
<p>1.第一种用法就是用label直接包括input表单。</p>
<blockquote>
<p><label>用户明：&lt;input type=”radio” name=”username” value=”请输入用户名”&#62;<label/></p>
</blockquote>
<p>适合单个表单选择</p>
<p>2.第二种用法for属性规定label与哪个表单元素绑定。</p>
<blockquote>
<p><label for="sex">男</label></p>
</blockquote>
<h6 id="2-3textarea控件-文本域"><a href="#2-3textarea控件-文本域" class="headerlink" title="2.3textarea控件(文本域)"></a>2.3textarea控件(文本域)</h6><hr />
语法:

<blockquote>
<p><textarea ><br />文本内容<br />&lt;/testarea&#62;</p>
</blockquote>
<p>作用：</p>
<p>通过textarea控件可以轻松地创建多行文本输入框</p>
<p>文本框和文本域区别</p>
<table>
<thead>
<tr>
<th>表单</th>
<th>名称</th>
<th>区别</th>
<th>默认值显示</th>
<th>用于场景</th>
</tr>
</thead>
<tbody><tr>
<td>input<br />type=”text”</td>
<td>文本框</td>
<td>只能显示一行文本</td>
<td>单标签，通过value显示默认值</td>
<td>用户名、昵称、密码等</td>
</tr>
<tr>
<td>textarea</td>
<td>文本域</td>
<td>可以显示多行文本</td>
<td>双标签、默认值写到标签中间</td>
<td>留言板</td>
</tr>
</tbody></table>
<h6 id="2-4select下拉列表"><a href="#2-4select下拉列表" class="headerlink" title="2.4select下拉列表"></a>2.4select下拉列表</h6><hr />
目的：

<p>如果有多个选项让用户选择，为了节约空间，我们可以使用select控件定义下拉列表。</p>
<p>语法：</p>
<blockquote>
<p><select><br />&nbsp;&nbsp;<option>选项1<option><br />&nbsp;&nbsp;<option>选项1<option><br />&nbsp;&nbsp;<option>选项1<option><br />&nbsp;&nbsp;…<br /></select></p>
</blockquote>
<p>注意：</p>
<p>1.<select>标签至少包含一对<option></p>
<p>2.在option中定义selectd=”selectd”时，当前项即为默认选中项。</p>
<p>3.现在实际开发使用较少</p>
<h5 id="3-表单域"><a href="#3-表单域" class="headerlink" title="3.表单域"></a>3.表单域</h5><p>通过form表单域收集用户信息传递给服务器</p>
<p>目的：</p>
<p>在html中，form标签被用于定义表单域，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。</p>
<p>语法：</p>
<blockquote>
<form action="url地址" method="提交方式" name="表单名称"&#62;<br />各种表单控件<br /></form>
</blockquote>
<p>常用属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>action</td>
<td>url地址</td>
<td>用于指定接受并处理表单数据的服务器程序的url地址</td>
</tr>
<tr>
<td>method</td>
<td>get/post</td>
<td>用于设置表单数据的提交方式，其取值为get或post。</td>
</tr>
<tr>
<td>name</td>
<td>名称</td>
<td>用于指定表单的名称，以区分同一个页面中的多个表单</td>
</tr>
</tbody></table>
<h6 id="查文档"><a href="#查文档" class="headerlink" title="查文档"></a>查文档</h6><p>w3c: <a href="http://www.w3scholl.com.cn/" target="_blank" rel="noopener">http://www.w3scholl.com.cn/</a></p>
<p>MDN: <a href="http://developer.mozilla.ora/zh-CN/" target="_blank" rel="noopener">http://developer.mozilla.ora/zh-CN/</a></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>表格标签</tag>
        <tag>列表标签</tag>
        <tag>表单标签</tag>
        <tag>查文档</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML（1）</title>
    <url>/2019/12/03/html/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="HTML（1）"><a href="#HTML（1）" class="headerlink" title="HTML（1）"></a>HTML（1）</h4><ul>
<li>理解<ul>
<li>HTML的概念</li>
<li>HTML标签的分类</li>
<li>HTML标签的关系</li>
<li>HTML标签的语义化</li>
</ul>
</li>
<li>应用<ul>
<li>HTML骨架格式</li>
<li>vscode</li>
</ul>
</li>
<li>HTML指的是超本文标记语言（Hyper Text Markup Language）</li>
<li>HTML不是一种编程语言，而是一种标记语言（markup langguage）</li>
<li>标记语言是一套标记标签（markup tag）<h5 id="html的作用"><a href="#html的作用" class="headerlink" title="html的作用"></a>html的作用</h5><blockquote>
<p>网页是由网页元素组成的，这些元素是利用html标签描述出来，然后通过浏览器解析，就可以显示给用户。</p>
</blockquote>
<h5 id="超文本有两层含义"><a href="#超文本有两层含义" class="headerlink" title="超文本有两层含义"></a>超文本有两层含义</h5></li>
</ul>
<ol>
<li>因为它可以加入图片、声音、动画、多媒体等内容（超越文本限制）。</li>
<li>不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文本连接（超链接文本）。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;timg.jpg&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="html骨架标签"><a href="#html骨架标签" class="headerlink" title="html骨架标签"></a>html骨架标签</h5>HTML有自己的语言语法骨架格式：（要遵循，要专业）要求务必非常流畅的默写下来。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">         &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">&lt;html&gt;</span><br></pre></td></tr></table></figure>
<h6 id="html骨架标签总结"><a href="#html骨架标签总结" class="headerlink" title="html骨架标签总结"></a>html骨架标签总结</h6><table>
<thead>
<tr>
<th>标签名</th>
<th>定义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#60;html&#62;&#60;html&#62;</td>
<td>HTML标签</td>
<td>页面中最大的标签，称为根标签</td>
</tr>
<tr>
<td>&#60;head&#62;&#60;head&#62;</td>
<td>文档的头部</td>
<td>注意在head标签中我们必须要设置的标签是title</td>
</tr>
<tr>
<td>&#60;title&#62;&#60;title&#62;</td>
<td>文档的标签</td>
<td>让页面拥有属于自己的网页标题</td>
</tr>
<tr>
<td>&#60;body&#62;&#60;body&#62;</td>
<td>文档的主题</td>
<td>元素包含文档的所有内容，页面内容基本都是放到body里面的</td>
</tr>
</tbody></table>
<h5 id="html元素标签分类"><a href="#html元素标签分类" class="headerlink" title="html元素标签分类"></a>html元素标签分类</h5><h6 id="标签"><a href="#标签" class="headerlink" title="标签:"></a>标签:</h6><p>在html页面中，带有“&lt;&gt;”符号的元素被称为HTML标签，如上面提到的&#60;html&#62;、&#60;head&#62;、&#60;body&#62;都是html骨架结构标签。</p>
<h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><ol>
<li>常规标签（双标签）<blockquote>
<p><font color=#008000>&lt;标签名&gt;</font> 内容 <font color=#008000>&lt;标签名&gt;</font>  比如 <font color=#008000><body></font> 我是文字 <font color=#008000></body></font></p>
</blockquote>
</li>
</ol>
<ul>
<li>该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般被称为“开始标签（start tag）”，“&lt;/标签名&gt;”表示该标签作用结束，一般称为结束标签（end tag）。</li>
<li>和开始标签相比，结束标签只是在前面加了一个关闭字符“/”。</li>
</ul>
<ol start="2">
<li>空元素标签（单标签）<blockquote>
<p><font color=#008000>&lt;标签名/&gt;</font>比如 <font color=#008000>&lt; br / &gt;</font> </p>
</blockquote>
</li>
</ol>
<ul>
<li>空元素用单标签来表示，简单点说，就是里面不包含内容，只有一个开始标签不需要关闭。</li>
<li>单标签很少。</li>
</ul>
<h5 id="HTML标签关系"><a href="#HTML标签关系" class="headerlink" title="HTML标签关系"></a>HTML标签关系</h5><p>主要针对双标签的相互关系分为两种：</p>
<ol>
<li>嵌套关系<blockquote>
<p><font color=#008000><head></font><br/><br>&emsp;&emsp;<font color=#008000><title><title/></font><br/><font color=#008000><head/></font></p>
</blockquote>
</li>
</ol>
<p>2.并列关系</p>
<blockquote>
<p><font color=#008000><head></font><font color=#008000><head/></font><br/><font color=#008000><body></font><font color=#008000><body/></font>    </p>
</blockquote>
<p>建议：</p>
<blockquote>
<p>如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab身位（一个tab是4个空格）。如果是并列关系，最好上下对齐。</p>
</blockquote>
<h5 id="文档类型-lt-DOCTYPE-gt"><a href="#文档类型-lt-DOCTYPE-gt" class="headerlink" title="文档类型&lt;!DOCTYPE&gt;"></a>文档类型&lt;!DOCTYPE&gt;</h5><p>用法：</p>
<blockquote>
<!DOCTYPE html>
</blockquote>
<p>作用：<br>&lt;!DOCTYPE&gt;声明位于文档中的最前面的位置，处于&#60;html&#62;标签之前。此标签可告知浏览器文档使用哪种HTML或者XHTML规范。</p>
<h5 id="页面语言lang"><a href="#页面语言lang" class="headerlink" title="页面语言lang"></a>页面语言lang</h5><blockquote>
<p><font color=#008000>&lt;html lang=”en”&#62;</font> 指定html语言种类</p>
</blockquote>
<p>最常见的2个：</p>
<ol>
<li>en定义语言为英语</li>
<li>zh-CN定义语言为中文</li>
</ol>
<p>简单来说，可能对程序来说没有太大的作用，但是它可以告诉浏览器，搜索引擎，一些处理html的程序对页面语言内容来做一些对应处理或者事情，比如可以</p>
<ul>
<li>根据lang属性来设定不同语言的css样式，或者字体</li>
<li>告诉搜索引擎做精确的识别</li>
<li>让语法检查程序做语言识别</li>
<li>帮助翻译工具做识别</li>
</ul>
<h5 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h5><blockquote>
<p><font color=#008000>&lt;meta charset=”UTF-8”/&#62;</font><br>字符集（character set）是多个字符的合集，计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p>
</blockquote>
<p>utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。</p>
<ul>
<li>gb2312简单中文。包括6763个汉字</li>
<li>BIGS 繁体中文，港澳台等用</li>
<li>GBK包含全部中文字符，是GB2312的扩展，加入对繁体字的支持，兼容GB2312</li>
<li>UTF-8则基本包含全世界所有国家需要用到的字符</li>
</ul>
<h5 id="HTML标签语义化"><a href="#HTML标签语义化" class="headerlink" title="HTML标签语义化"></a>HTML标签语义化</h5><p>白话：所谓标签语义化，就是指标签的含义。</p>
<blockquote>
<p>根据标签的含义，在合适的地方给一个最为合理的标签，让结构更清晰。</p>
</blockquote>
<ol>
<li>方便代码的阅读和维护</li>
<li>同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容</li>
<li>使用语义化标签会具有更好地搜索引擎优化</li>
</ol>
<h5 id="html常用标签"><a href="#html常用标签" class="headerlink" title="html常用标签"></a>html常用标签</h5><p>HTML和CSS是两种完全不同的语言，HTML是结构，CSS是样式。</p>
<h4 id="1-1排版标签"><a href="#1-1排版标签" class="headerlink" title="1.1排版标签"></a>1.1排版标签</h4><hr />
排版标签主要是和CSS搭配使用，显示网页结构的标签，是网页布局最常用的标签
1. 标题标签h（熟记）
单词缩写： head 头部、标题 &ensp; &ensp; title 文档标题
为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即

<p><strong>标题标签语义</strong>：作为标题使用，并且依据重要性递减<br>其基本语法格式如下：</p>
<blockquote>
<p><font color=#008000>&lt;h1&#62;标题</font><font color=#008000>&lt;h1/&#62;</font><br/><font color=#008000>&lt;h2&#62;标题</font><font color=#008000>&lt;h2/&#62;</font> <br/><font color=#008000>&lt;h3&#62;标题</font><font color=#008000>&lt;h3/&#62;</font><br/><font color=#008000>&lt;h4&#62;标题</font><font color=#008000>&lt;h4/&#62;</font> <br/><font color=#008000>&lt;h5&#62;标题</font><font color=#008000>&lt;h5/&#62;</font><br/><font color=#008000>&lt;h6&#62;标题</font><font color=#008000>&lt;h6/&#62;</font> </p>
</blockquote>
<p>2.段落标签p（熟记）<br>单词缩写：pargraph 段落</p>
<p><strong>作用语义</strong><br>可以把HTML文档分割为若干段落<br>在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是</p>
<blockquote>
<p><font color=#008000>&lt;p&#62;文本内容</font><font color=#008000>&lt;p/&#62;</font></p>
</blockquote>
<p> 是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。</p>
<p>3.水平线标签hr（认识）<br>单词缩写：horizontal &ensp;横线</p>
<p>在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，&#60;hr/&#62;就是创建横跨网页水平线地标签。其基本语法格式如下：</p>
<blockquote>
<p><font color=#008000>&lt;hr/&#62;</font>是单标签</p>
</blockquote>
<p>在网页中显示默认样式的水平线。</p>
<p>4.换行标签br（熟记）<br>单词缩写：break 打断，换行</p>
<p>在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果某段文本强制换行显示，就需要使用换行标签</p>
<blockquote>
<p><font color=#008000>&lt;br/&#62;</font></p>
</blockquote>
<p>5.div和span标签（重点）</p>
<p>div &ensp;span&ensp;是没有语义的 &ensp;是网页布局的主要两个盒子</p>
<p>div就是division的缩写 分割，分区的意思，其实有很多div来组合网页。</p>
<p>span &ensp;跨度，跨距；范围</p>
<p>语法格式：</p>
<blockquote>
<p><font color=#008000>&lt;div&#62;</font>这是头部<font color=#008000>&lt;div/&#62;</font> &ensp;&ensp;&ensp;<font color=#008000>&lt;span&#62;</font>今日价格<font color=#008000>&lt;span/&#62;</font></p>
</blockquote>
<p>它们两个都是盒子，用来装我们网页元素的，只不过他们有区别，我们要记住记住使用方法和特点就好了</p>
<ul>
<li>div标签用来布局的，但是现在==一行只能放一个DIV==</li>
<li>span标签用来布局的，==一行上可以放好多个span==</li>
</ul>
<h6 id="排版标签总结"><a href="#排版标签总结" class="headerlink" title="排版标签总结"></a>排版标签总结</h6><table>
<thead>
<tr>
<th>标签名</th>
<th>定义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#60;hx&#62;&#60;/hx&#62;</td>
<td>标题标签</td>
<td>作为标题使用，并且依据重要性递减</td>
</tr>
<tr>
<td>&#60;p&#62;&#60;/p&#62;</td>
<td>段落标签</td>
<td>可以把HTML文档分割为若干段落</td>
</tr>
<tr>
<td>&#60;hr /&#62;</td>
<td>水平线标签</td>
<td>一条水平分割线</td>
</tr>
<tr>
<td>&#60;br /&#62;</td>
<td>换行标签</td>
<td></td>
</tr>
<tr>
<td>&#60;div&#62;&#60;/div&#62;</td>
<td>div标签</td>
<td>用来布局的，但是现在一行只能放一个div</td>
</tr>
<tr>
<td>&#60;span&#62;&#60;/span&#62;</td>
<td>span标签</td>
<td>用来布局的，一行上可以放好多个span</td>
</tr>
</tbody></table>
<h4 id="1-2文本格式化标签"><a href="#1-2文本格式化标签" class="headerlink" title="1.2文本格式化标签"></a>1.2文本格式化标签</h4><hr />
在网页中，有时需要为文字设置粗体、斜体或者下划线效果，这时就需要用到HTML文本格式化标签，使文字以特殊的方式显示。

<table>
<thead>
<tr>
<th>标签</th>
<th>显示效果</th>
</tr>
</thead>
<tbody><tr>
<td>&#60;b&#62;&#60;/b&#62;&#60;strong&#62;&#60;/strong&#62;</td>
<td>文字以==粗体==方式显示（XHTML推荐使用strong）</td>
</tr>
<tr>
<td>&#60;i&#62;&#60;/i&#62; ，&#60;em&#62;&#60;/em&#62;</td>
<td>文字以==斜体==方式显示（XHTML推荐使用em）</td>
</tr>
<tr>
<td>&#60;s&#62;&#60;/s&#62;,&#60;del&#62;&#60;/del&#62;</td>
<td>文字以==加删除线==方式显示（XHTML推荐使用del）</td>
</tr>
<tr>
<td>&#60;u&#62;&#60;/u&#62;,&#60;ins&#62;&#60;/ins&#62;</td>
<td>文字==加下划线==方式显示（XHTML不赞成使用u）</td>
</tr>
</tbody></table>
<h4 id="1-3标签属性"><a href="#1-3标签属性" class="headerlink" title="1.3标签属性"></a>1.3标签属性</h4><hr />
所谓标签属性就是外在特性，比如手机颜色手机尺寸。

<p>使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下：</p>
<blockquote>
<p><font color=#008000>&lt;标签名&emsp;属性1=”属性值1”属性2=”属性值2”…&#62;</font>内容<font color=#008000>&lt;标签名/&#62;</font><br /><br><font color=#008000>&lt;手机 &emsp;颜色=”红色”大小=”5寸”&#62;</font><font color=#008000>&lt;div/&#62;</font></p>
</blockquote>
<h4 id="1-4图像标签img（重点）"><a href="#1-4图像标签img（重点）" class="headerlink" title="1.4图像标签img（重点）"></a>1.4图像标签img（重点）</h4><hr />
单词缩写： image图像

<p>要想在网页中显示图像就需要使用图像标签，以下是图像标签&#60;img/&#62;以及和它相关的属性，（它是一个单标签）</p>
<p>语法如下：</p>
<blockquote>
<p><font color=#008000>&lt;img&ensp;src=”图像URL”/&#62;</font></p>
</blockquote>
<p>该语法中src属性用于指定图像文件的路径h和文件名，它是img标签的必需属性。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>URL</td>
<td>图像的路径</td>
</tr>
<tr>
<td>alt</td>
<td>文本</td>
<td>图像不能显示时的替换文本</td>
</tr>
<tr>
<td>title</td>
<td>文本</td>
<td>鼠标悬停时显示的内容</td>
</tr>
<tr>
<td>width</td>
<td>像素(XHTML不支持页面百分比)</td>
<td>设置图像的宽度</td>
</tr>
<tr>
<td>height</td>
<td>像素（XHTML不支持页面百分比）</td>
<td>设置图像的高度</td>
</tr>
<tr>
<td>boder</td>
<td>数字</td>
<td>设置图像边框的宽度</td>
</tr>
</tbody></table>
<p>注意：</p>
<ol>
<li>标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</li>
<li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li>
<li>采取键值对的格式&ensp;key=”value”的格式。</li>
</ol>
<h4 id="1-5链接标签（重点）"><a href="#1-5链接标签（重点）" class="headerlink" title="1.5链接标签（重点）"></a>1.5链接标签（重点）</h4><hr />
单词缩写： anchor。锚，铁锚的

<p>在html中创建超链接非常简单，只需用标签把文字包括起来就好</p>
<p>语法格式：</p>
<blockquote>
<p><font color=#008000>&lt;a&ensp;href=”跳转目标”&ensp;target=”目标窗口弹出方式”&#62;</font>文本或者图像 <font color=#008000>&lt;/a&#62;</font></p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>href</td>
<td>用于指定链接目标的url地址，（必须属性）当为标签应用href属性时，它就具有了超链接的功能</td>
</tr>
<tr>
<td>target</td>
<td>用于指定链接页面的打开方式，其取值有self和blank两种，其中self为默认值，blank为在新窗口中打开方式。</td>
</tr>
</tbody></table>
<h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><ol>
<li>外部链接 需要添加http://</li>
<li>内部链接直接链接内部页面名称即可，比如&#60;a href=”index.html”&#62;首页&#60;/a&#62;</li>
<li>如果当时没有确定链接目标时，通常将链接标签的href属性值定义为”#”（即href=”#”）,表示该链接暂时为一个空链接。</li>
<li>不仅可以创建文本超链接，在网页中各个元素，如图像、表格、音频、视频等都可以添加超链接。</li>
</ol>
<h4 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h4><hr />
在html中还有一种特殊的标签--注释标签。如果需要在html文档中添加一些便于阅读和理解但又不需要显示在页面中注释文字，就需要用到注释标签。

<p>语法格式：</p>
<blockquote>
<p><font color=#008000>&lt;！–注释语句–&#62;</font> 快捷键是：ctrl+/或者ctrl+shift+/</p>
</blockquote>
<h4 id="路径（重点）"><a href="#路径（重点）" class="headerlink" title="路径（重点）"></a>路径（重点）</h4><hr />
页面中的图片会非常多，通常我们会新建一个文件夹专门用于存放图片文件（images），这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。路径可分为，相对路径和绝对路径。

<h5 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h5><hr />
以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径。


<table>
<thead>
<tr>
<th>路径分类</th>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>同一级路径</td>
<td></td>
<td>只需要输入图像文件的名称即可，如&#60;img src=”baidu.gif”/&#62;</td>
</tr>
<tr>
<td>下一级路径</td>
<td>“/”</td>
<td>图像文件位于HTML文件同级文件夹下（例如文件夹名称为：images）如&amp;#60；img src=”images/baidu.gif”/&#62;</td>
</tr>
<tr>
<td>上一级路径</td>
<td>“../”</td>
<td>在文件名之前加入“../”，如果是上两级，则需要使用“../../”,以此类推，如&#60;img src=”../baidu.gif”/&#62;</td>
</tr>
</tbody></table>
<h5 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h5><hr />
绝对路径以web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的。

<p>如“D：\web\img\logo.gif”</p>
<h5 id="5-锚点定位"><a href="#5-锚点定位" class="headerlink" title="5.锚点定位"></a>5.锚点定位</h5><hr />
通过锚点定位创建锚点链接，用户能够快速定位到目标内容。

<p>创建锚点定位链接分为两部：</p>
<blockquote>
<p>1.使用相应的ID名称标注跳转目标的位置。（找目标）<br /><font color=#008000>&lt;h3 id=”two”&#62;</font>第二集<font color=#008000>&lt;/h3&#62;</font><br /><br />2.使用 <font color=#008000>&lt;a href=”#id名”&#62;</font>链接文本<font color=#008000>&lt;/a&#62;</font>创建链接文本（被点击的）（拉关系）  <font color=#008000>&lt;a href=”#two”&#62;</font>链接文本<font color=#008000>&lt;/a&#62;</font></p>
</blockquote>
<h5 id="6-base标签"><a href="#6-base标签" class="headerlink" title="6.base标签"></a>6.base标签</h5><hr />
语法：

<blockquote>
<p><font color=#008000>&lt;base target=”_blank”/&#62;</font></p>
</blockquote>
<ol>
<li>base可以设置整体链接的打开状态</li>
<li>base写到&lt;head&#62;&lt;head/&#62;之间</li>
<li>把所有的链接都默认设置添加target=”_blank”</li>
</ol>
<h5 id="7-什么是XHTML"><a href="#7-什么是XHTML" class="headerlink" title="7.什么是XHTML"></a>7.什么是XHTML</h5><p>XHTML是更严格更纯净的HTML代码。</p>
<ul>
<li>XHTML指可扩展超文本标签语言</li>
<li>XHTML的目标是取代HTML</li>
<li>XHTML与HTML4.01几乎是相同的</li>
<li>XHTML是更严格更纯净的HTML版本</li>
<li>XHTML是作为一种XML应用被重新定义的HTML</li>
<li>XHTML是一个W3C标准</li>
</ul>
<h6 id="7-1XHTML与HTML有什么区别？"><a href="#7-1XHTML与HTML有什么区别？" class="headerlink" title="7.1XHTML与HTML有什么区别？"></a>7.1XHTML与HTML有什么区别？</h6><ul>
<li>XHTML指的是可扩展超文本标记语言</li>
<li>XHTML与HTML4.0.1几乎是相同的</li>
<li>XHTML是更严格更纯净的HTML版本</li>
<li>XHTML是以XML应用的方式定义的HTML</li>
<li>XHTML是2001年1月发布的w3c推荐标准</li>
<li>XHTML得到所有主流浏览器的支持</li>
<li>XHTML元素是以XML格式编写的HTML元素。XHTML是严格版本的HTML,例如它要求标签必须小写，标签必须正确关闭，标签顺序必须正确排列，对于属性都必须使用双引号等。</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>html作用</tag>
        <tag>骨架标签</tag>
        <tag>排版标签</tag>
        <tag>文本格式化标签</tag>
        <tag>图像标签</tag>
        <tag>链接标签</tag>
        <tag>相对路径、绝对路径</tag>
        <tag>锚点定位</tag>
        <tag>base标签</tag>
      </tags>
  </entry>
  <entry>
    <title>web标准</title>
    <url>/2019/12/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="web标准"><a href="#web标准" class="headerlink" title="web标准"></a>web标准</h4><h5 id="常用浏览器内核"><a href="#常用浏览器内核" class="headerlink" title="常用浏览器内核"></a>常用浏览器内核</h5><table>
<thead>
<tr>
<th>浏览器</th>
<th>内核</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>IE</td>
<td>Trident</td>
<td>IE、猎豹安全、360极速浏览器、百度浏览器</td>
</tr>
<tr>
<td>firefox</td>
<td>Gecko</td>
<td>可惜这几年已经没落了，打开速度极慢、升级频繁、不友好的flash</td>
</tr>
<tr>
<td>safari</td>
<td>webkit</td>
<td>现在很多人错误地把叫做chrome内核（即使现在chrome已经是blink了）</td>
</tr>
<tr>
<td>chrome</td>
<td>chromium/Blink</td>
<td>在Chromium项目中研发Blink渲染引擎，内置于Chrome浏览器之中。Blink其实Webkit的分支。大部分国产浏览器最新版都采用Blink内核，二次开发</td>
</tr>
<tr>
<td>OPera</td>
<td>Blink</td>
<td>现在跟随chrome采用blink内核</td>
</tr>
</tbody></table>
<h5 id="web标准-1"><a href="#web标准-1" class="headerlink" title="web标准"></a>web标准</h5><p>web标准不是某一个标准，而是由W3C组织和其他标准化组织制定的一系列标准的合集。</p>
<p>W3C万维网联盟是国际最著名的标准化组织。1994年成立之后，至今已发布近百项相关万维网标准，对万维网发展做出了重要贡献。</p>
<p>W3C就类似于现实世界中的联合国。</p>
<p>++经典面试题：说出网页中web标准三层组成。++</p>
<p><strong>构成：</strong> 主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。</p>
<table>
<thead>
<tr>
<th>标准</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>结构用于对网页元素进行整理和分类，主要是HTML</td>
</tr>
<tr>
<td>表现</td>
<td>表现用于设置网页元素的版式、颜色、大小等外观样式，主要使用CSS</td>
</tr>
<tr>
<td>行为</td>
<td>行为是指网页模型的定义及交互的编写，主要使用Javascript</td>
</tr>
</tbody></table>
<h5 id="web标准的好处"><a href="#web标准的好处" class="headerlink" title="web标准的好处"></a>web标准的好处</h5><p>遵循web标准可以让不同我们写的页面更标准更统一外，还有许多优点</p>
<ol>
<li>让web的发展前景更广阔。</li>
<li>内容能被更广泛的设备访问。</li>
<li>更容易被搜索引擎搜索。</li>
<li>降低网站流量费用。</li>
<li>是网站更易于维护</li>
<li>提高页面浏览速度。</li>
</ol>
<h5 id="web标准小结"><a href="#web标准小结" class="headerlink" title="web标准小结"></a>web标准小结</h5><ul>
<li>web标准有三层结构，分别是结构（html）、表现（CSS）、行为（javascript）</li>
<li>结构类似人类的身体，表现类似人的着装，行为类似人的行为动作</li>
<li>理想状态下，他们是三层独立的，放到不同的文件里面。</li>
</ul>
<h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><p>浏览器内核包括两部分，渲染引擎和JS引擎。渲染引擎负责读取网页内容，整理讯息，计算网页的显示方式并显示页面，JS引擎是解析执行JS获取网页的动态效果。后来js引擎越来越独立，内核就倾向于只指渲染引擎。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>浏览器内核</tag>
        <tag>web标准</tag>
        <tag>web标准三层组成</tag>
      </tags>
  </entry>
</search>
