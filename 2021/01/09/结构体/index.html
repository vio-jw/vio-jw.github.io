<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>结构体 | Jw's Blog</title><meta name="description" content="结构体"><meta name="keywords" content="golang"><meta name="author" content="vio-jw,yjw-1017@outlook.com"><meta name="copyright" content="vio-jw"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/u=1081158815,3939059762&fm=26&gp=0.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="结构体"><meta name="twitter:description" content="结构体"><meta name="twitter:image" content="https://wallroom.io/img/1920x1080/bg-0cf6fd0.jpg"><meta property="og:type" content="article"><meta property="og:title" content="结构体"><meta property="og:url" content="http://1py1vm.coding-pages.com/2021/01/09/%E7%BB%93%E6%9E%84%E4%BD%93/"><meta property="og:site_name" content="Jw's Blog"><meta property="og:description" content="结构体"><meta property="og:image" content="https://wallroom.io/img/1920x1080/bg-0cf6fd0.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://1py1vm.coding-pages.com/2021/01/09/%E7%BB%93%E6%9E%84%E4%BD%93/"><link rel="prev" title="条件语句switch" href="http://1py1vm.coding-pages.com/2021/01/09/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5switch/"><link rel="next" title="map底层" href="http://1py1vm.coding-pages.com/2021/01/09/map%E5%BA%95%E5%B1%82/"><link rel="stylesheet" href="https://fonts.geekzu.org/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"正心,取势,明道,优术,修身,齐家,治国,平天下,践行,合众","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/20170917230838_HPMLr.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">49</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 爱好</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#结构体"><span class="toc-number">1.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类型别名和自定义类型"><span class="toc-number">1.1.</span> <span class="toc-text">类型别名和自定义类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义类型"><span class="toc-number">1.1.1.</span> <span class="toc-text">自定义类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型别名"><span class="toc-number">1.1.2.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型定义和类型别名的区别"><span class="toc-number">1.1.3.</span> <span class="toc-text">类型定义和类型别名的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构体-1"><span class="toc-number">1.2.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体的定义"><span class="toc-number">1.2.1.</span> <span class="toc-text">结构体的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体实例化"><span class="toc-number">1.2.2.</span> <span class="toc-text">结构体实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本实例化"><span class="toc-number">1.2.3.</span> <span class="toc-text">基本实例化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名结构体"><span class="toc-number">1.3.</span> <span class="toc-text">匿名结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建指针类型结构体"><span class="toc-number">1.3.1.</span> <span class="toc-text">创建指针类型结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#取结构体的地址实例化"><span class="toc-number">1.3.2.</span> <span class="toc-text">取结构体的地址实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体初始化"><span class="toc-number">1.3.3.</span> <span class="toc-text">结构体初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用键值对初始化"><span class="toc-number">1.3.4.</span> <span class="toc-text">使用键值对初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用值的列表初始化"><span class="toc-number">1.3.5.</span> <span class="toc-text">使用值的列表初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体内存布局"><span class="toc-number">1.3.6.</span> <span class="toc-text">结构体内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题"><span class="toc-number">1.3.7.</span> <span class="toc-text">面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-number">1.3.8.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法和接收者"><span class="toc-number">1.3.9.</span> <span class="toc-text">方法和接收者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针类型的接收者"><span class="toc-number">1.3.10.</span> <span class="toc-text">指针类型的接收者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#值类型的接收者"><span class="toc-number">1.3.11.</span> <span class="toc-text">值类型的接收者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候应该使用指针类型接收者"><span class="toc-number">1.3.12.</span> <span class="toc-text">什么时候应该使用指针类型接收者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任意类型添加方法"><span class="toc-number">1.3.13.</span> <span class="toc-text">任意类型添加方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体的匿名字段"><span class="toc-number">1.3.14.</span> <span class="toc-text">结构体的匿名字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套结构体"><span class="toc-number">1.3.15.</span> <span class="toc-text">嵌套结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套匿名结构体"><span class="toc-number">1.3.16.</span> <span class="toc-text">嵌套匿名结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套结构体的字段名冲突"><span class="toc-number">1.3.17.</span> <span class="toc-text">嵌套结构体的字段名冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体的-quot-继承-quot"><span class="toc-number">1.3.18.</span> <span class="toc-text">结构体的&quot;继承&quot;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体字段的可见性"><span class="toc-number">1.3.19.</span> <span class="toc-text">结构体字段的可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体与-JSON-序列化"><span class="toc-number">1.3.20.</span> <span class="toc-text">结构体与** JSON **序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体标签（-Tag-）"><span class="toc-number">1.3.21.</span> <span class="toc-text">结构体标签（** Tag **）</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://wallroom.io/img/1920x1080/bg-0cf6fd0.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Jw's Blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 爱好</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">结构体</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-01-09 22:35:28"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-01-09</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-05-09 22:36:01"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-05-09</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/golang/">golang</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2021/01/09/%E7%BB%93%E6%9E%84%E4%BD%93/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2021/01/09/%E7%BB%93%E6%9E%84%E4%BD%93/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>#</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go语言中没有&quot;类&quot;的概念，也不支持&quot;类&quot;的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p>
<h2 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a><strong>类型别名和自定义类型</strong></h2><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a><strong>自定义类型</strong></h3><p>在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型，Go语言中可以使用type关键字来定义自定义类型。</p>
<p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p>
<p><em>// <strong>将</strong> MyInt <strong>定义为</strong> int__类型</em></p>
<p>type MyInt <strong>int</strong></p>
<p>通过Type关键字的定义，MyInt就是一种新的类型，它具有int的特性。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a><strong>类型别名</strong></h3><p>类型别名是Go1.9版本添加的新功能。</p>
<p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p>
<p>type TypeAlias = Type</p>
<p>我们之前见过的rune和byte就是类型别名，他们的定义如下：</p>
<p>type byte = uint8</p>
<p>type rune = int32</p>
<h3 id="类型定义和类型别名的区别"><a href="#类型定义和类型别名的区别" class="headerlink" title="类型定义和类型别名的区别"></a><strong>类型定义和类型别名的区别</strong></h3><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p>
<p><em>//__类型定义</em></p>
<p>type NewInt <strong>int</strong></p>
<p><em>//__类型别名</em></p>
<p>type MyInt = <strong>int</strong></p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> a NewInt</p>
<p><strong>var</strong> b MyInt</p>
<p>fmt.Printf(&quot;type of a:%T\n&quot;, a) <em>//type of a:main.NewInt</em></p>
<p>fmt.Printf(&quot;type of b:%T\n&quot;, b) <em>//type of b:int</em></p>
<p>}</p>
<p>结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。b的类型是int。MyInt类型只会在代码中存在，编译完成时并不会有MyInt类型。</p>
<h2 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a><strong>结构体</strong></h2><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。</p>
<p>Go语言中通过struct来实现面向对象。</p>
<h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a><strong>结构体的定义</strong></h3><p>使用type和struct关键字来定义结构体，具体代码格式如下：</p>
<p>type类型名 struct {</p>
<p>字段名 字段类型</p>
<p>字段名 字段类型</p>
<p>…</p>
<p>}</p>
<p>其中：</p>
<p>1.类型名：标识自定义结构体的名称，在同一个包内不能重复。</p>
<p>2.字段名：表示结构体字段名。结构体中的字段名必须唯一。</p>
<p>3.字段类型：表示结构体字段的具体类型。</p>
<p>举个例子，我们定义一个Person（人）结构体，代码如下：</p>
<p>type person <strong>struct</strong> {</p>
<p>name string</p>
<p>city string</p>
<p>age int8</p>
<p>}</p>
<p>同样类型的字段也可以写在一行，</p>
<p>type person1 <strong>struct</strong> {</p>
<p>name, city string</p>
<p>age int8</p>
<p>}</p>
<p>这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了。</p>
<p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p>
<h3 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a><strong>结构体实例化</strong></h3><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p>
<p>结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。</p>
<p><strong>var</strong> 结构体实例 结构体类型</p>
<h3 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a><strong>基本实例化</strong></h3><p>type person <strong>struct</strong> {</p>
<p>name <strong>string</strong></p>
<p>city <strong>string</strong></p>
<p>age int8</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> p1 person</p>
<p>p1.name = &quot;pprof.cn&quot;</p>
<p>p1.city = &quot;北京&quot;</p>
<p>p1.age = 18</p>
<p>fmt.Printf(&quot;p1=%v\n&quot;, p1) <em>//p1={pprof.cn</em> <em>北京</em> <em>18}</em></p>
<p>fmt.Printf(&quot;p1=%#v\n&quot;, p1) <em>//p1=main.person{name:&quot;pprof.cn&quot;, city:&quot; <strong>北京</strong>&quot;, age:18}</em></p>
<p>}</p>
<p>我们通过.来访问结构体的字段（成员变量）,例如p1.name和p1.age等。</p>
<h2 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a><strong>匿名结构体</strong></h2><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p>
<p>package main</p>
<p><strong>import</strong> (</p>
<p>&quot;fmt&quot;)</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> user <strong>struct</strong> {Name <strong>string</strong> ; Age <strong>int</strong> }</p>
<p>user.Name = &quot;pprof.cn&quot;</p>
<p>user.Age = 18</p>
<p>fmt.Printf(&quot;%#v\n&quot;, user)</p>
<p>}</p>
<h3 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a><strong>创建指针类型结构体</strong></h3><p>我们还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p>
<p><strong>var</strong> p2 = <strong>new</strong> (person)</p>
<p>fmt.Printf(&quot;%T\n&quot;, p2) <em>//*main.person</em></p>
<p>fmt.Printf(&quot;p2=%#v\n&quot;, p2) <em>//p2=&amp;main.person{name:&quot;&quot;, city:&quot;&quot;, age:0}</em></p>
<p>从打印的结果中我们可以看出p2是一个结构体指针。</p>
<p>需要注意的是在Go语言中支持对结构体指针直接使用.来访问结构体的成员。</p>
<p>var p2 = <strong>new</strong> (person)</p>
<p>p2.name = &quot;测试&quot;</p>
<p>p2.age = 18</p>
<p>p2.city = &quot;北京&quot;</p>
<p>fmt.Printf(&quot;p2=%#v\n&quot;, p2) //p2=&amp;main.person{name:&quot;测试&quot;, city:&quot;北京&quot;, age:18}</p>
<h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a><strong>取结构体的地址实例化</strong></h3><p>使用&amp;对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。</p>
<p>p3 := &amp;person{}</p>
<p>fmt.Printf(&quot;%T\n&quot;, p3) //*main.person</p>
<p>fmt.Printf(&quot;p3=%#v\n&quot;, p3) //p3=&amp;main.person{name:&quot;&quot;, city:&quot;&quot;, age:0}</p>
<p>p3.name = &quot;博客&quot;</p>
<p>p3.age = 30</p>
<p>p3.city = &quot;成都&quot;</p>
<p>fmt.Printf(&quot;p3=%#v\n&quot;, p3) //p3=&amp;main.person{name:&quot;博客&quot;, city:&quot;成都&quot;, age:30}</p>
<p>p3.name = &quot;博客&quot;其实在底层是(*p3).name = &quot;博客&quot;，这是Go语言帮我们实现的语法糖。</p>
<h3 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a><strong>结构体初始化</strong></h3><p>type person <strong>struct</strong> {</p>
<p>name <strong>string</strong></p>
<p>city <strong>string</strong></p>
<p>age int8</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> p4 person</p>
<p>fmt.Printf(&quot;p4=%#v\n&quot;, p4) <em>//p4=main.person{name:&quot;&quot;, city:&quot;&quot;, age:0}</em></p>
<p>}</p>
<h3 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a><strong>使用键值对初始化</strong></h3><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p>
<p>p5 := person{</p>
<p>name: &quot;pprof.cn&quot;,</p>
<p>city: &quot;北京&quot;,</p>
<p>age: 18,</p>
<p>}</p>
<p>fmt.Printf(&quot;p5=%#v\n&quot;, p5) //p5=main.person{name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18}</p>
<p>也可以对结构体指针进行键值对初始化，例如：</p>
<p>p6 := &amp;person{</p>
<p>name: &quot;pprof.cn&quot;,</p>
<p>city: &quot;北京&quot;,</p>
<p>age: 18,</p>
<p>}</p>
<p>fmt.Printf(&quot;p6=%#v\n&quot;, p6) //p6=&amp;main.person{name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18}</p>
<p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p>
<p>p7 := &amp;person{</p>
<p>city: &quot;北京&quot;,</p>
<p>}</p>
<p>fmt.Printf(&quot;p7=%#v\n&quot;, p7) //p7=&amp;main.person{name:&quot;&quot;, city:&quot;北京&quot;, age:0}</p>
<h3 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a><strong>使用值的列表初始化</strong></h3><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p>
<p>p8 := &amp;person{</p>
<p>&quot;pprof.cn&quot;,</p>
<p>&quot;北京&quot;,</p>
<p>18,</p>
<p>}</p>
<p>fmt.Printf(&quot;p8=%#v\n&quot;, p8) //p8=&amp;main.person{name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18}</p>
<p>使用这种格式初始化时，需要注意：</p>
<p>1.必须初始化结构体的所有字段。</p>
<p>2.初始值的填充顺序必须与字段在结构体中的声明顺序一致。</p>
<p>3.该方式不能和键值初始化方式混用。</p>
<h3 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a><strong>结构体内存布局</strong></h3><p>type test struct {</p>
<p>a int8</p>
<p>b int8</p>
<p>c int8</p>
<p>d int8</p>
<p>}</p>
<p>n := test{</p>
<p>1, 2, 3, 4,</p>
<p>}</p>
<p>fmt.Printf(&quot;n.a %p\n&quot;, &amp;n.a)</p>
<p>fmt.Printf(&quot;n.b %p\n&quot;, &amp;n.b)</p>
<p>fmt.Printf(&quot;n.c %p\n&quot;, &amp;n.c)</p>
<p>fmt.Printf(&quot;n.d %p\n&quot;, &amp;n.d)</p>
<p>输出：</p>
<p><strong>n</strong>.a 0 <strong>xc0000a0060</strong></p>
<p><strong>n</strong>.b 0 <strong>xc0000a0061</strong></p>
<p><strong>n</strong>.c 0 <strong>xc0000a0062</strong></p>
<p><strong>n</strong>.d 0 <strong>xc0000a0063</strong></p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a><strong>面试题</strong></h3><p>type student <strong>struct</strong> {</p>
<p>name string</p>
<p>age <strong>int</strong></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>m := make(map[string]*student)</p>
<p>stus := []student{</p>
<p>{name: &quot;pprof.cn&quot;, age: 18},</p>
<p>{name: &quot;测试&quot;, age: 23},</p>
<p>{name: &quot;博客&quot;, age: 28},</p>
<p>}</p>
<p><strong>for</strong> _, stu := range stus {</p>
<p>m[stu.name] = &amp;stu</p>
<p>}</p>
<p><strong>for</strong> k, v := range m {</p>
<p>fmt.Println(k, &quot;=&amp;gt;&quot;, v.name)</p>
<p>}</p>
<p>}</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h3><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p>
<p>func <strong>newPerson</strong> (name, city string, age int8) *person {</p>
<p><strong>return</strong> &amp;person{</p>
<p>name: name,</p>
<p>city: city,</p>
<p>age: age,</p>
<p>}</p>
<p>}</p>
<p>调用构造函数</p>
<p>p9 := newPerson(&quot;pprof.cn&quot;, &quot;测试&quot;, 90)</p>
<p>fmt.Printf(&quot;%#v\n&quot;, p9)</p>
<h3 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a><strong>方法和接收者</strong></h3><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。</p>
<p>方法的定义格式如下：</p>
<p>func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {</p>
<p>函数体</p>
<p>}</p>
<p>其中，</p>
<p>1.接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是 <strong>self</strong> 、 <strong>this</strong> 之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。</p>
<p>2.接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</p>
<p>3.方法名、参数列表、返回参数：具体格式与函数定义相同。</p>
<p>举个例子：</p>
<p><em>//Person</em> <em>结构体</em></p>
<p>type Person <strong>struct</strong> {</p>
<p>name <strong>string</strong></p>
<p>age int8</p>
<p>}</p>
<p><em>//NewPerson</em> _构造函数_func <strong>NewPerson</strong> (name <strong>string</strong> , age int8) *Person {</p>
<p><strong>return</strong> &amp;Person{</p>
<p>name: name,</p>
<p>age: age,</p>
<p>}</p>
<p>}</p>
<p><em>//Dream Person__做梦的方法</em></p>
<p>func (p Person) Dream() {</p>
<p>fmt.Printf(&quot;%s的梦想是学好Go语言！\n&quot;, p.name)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>p1 := NewPerson(&quot;测试&quot;, 25)</p>
<p>p1.Dream()</p>
<p>}</p>
<p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p>
<h3 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a><strong>指针类型的接收者</strong></h3><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如我们为Person添加一个SetAge方法，来修改实例变量的年龄。</p>
<p><em>// SetAge</em> <em>设置 <strong>p</strong> 的年龄</em></p>
<p><em>//</em> <em>使用指针接收者</em></p>
<p>func (p *Person) SetAge(newAge int8) {</p>
<p>p.age = newAge</p>
<p>}</p>
<p>调用该方法：</p>
<p>func <strong>main</strong> () {</p>
<p>p1 := NewPerson(&quot;测试&quot;, 25)</p>
<p>fmt.Println(p1.age) <em>// 25</em></p>
<p>p1.SetAge(30)</p>
<p>fmt.Println(p1.age) <em>// 30</em></p>
<p>}</p>
<h3 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a><strong>值类型的接收者</strong></h3><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p>
<p><em>// SetAge2</em> <em>设置 <strong>p</strong> 的年龄__//</em> <em>使用值接收者</em></p>
<p>func (p Person) SetAge2(newAge int8) {</p>
<p>p.age = newAge</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>p1 := NewPerson(&quot;测试&quot;, 25)</p>
<p>p1.Dream()</p>
<p>fmt.Println(p1.age) <em>// 25</em></p>
<p>p1.SetAge2(30) <em>// (*p1).SetAge2(30)</em></p>
<p>fmt.Println(p1.age) <em>// 25</em></p>
<p>}</p>
<h3 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a><strong>什么时候应该使用指针类型接收者</strong></h3><p>1.需要修改接收者中的值</p>
<p>2.接收者是拷贝代价比较大的大对象</p>
<p>3.保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</p>
<h3 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a><strong>任意类型添加方法</strong></h3><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p>
<p><em>//MyInt</em> <em>将 <strong>int</strong> 定义为自定义 <strong>MyInt</strong> 类型</em></p>
<p>type MyInt <strong>int</strong></p>
<p><em>//SayHello</em> <em>为 <strong>MyInt</strong> 添加一个 <strong>SayHello</strong> 的方法</em></p>
<p>func (m MyInt) SayHello() {</p>
<p>fmt.Println(&quot;Hello, 我是一个int。&quot;)</p>
<p>}func <strong>main</strong> () {</p>
<p><strong>var</strong> m1 MyInt</p>
<p>m1.SayHello() <em>//Hello,</em> <em>我是一个 <strong>int</strong> 。</em></p>
<p>m1 = 100</p>
<p>fmt.Printf(&quot;%#v %T\n&quot;, m1, m1) <em>//100 main.MyInt</em></p>
<p>}</p>
<p>注意事项： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p>
<h3 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a><strong>结构体的匿名字段</strong></h3><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p>
<p><em>//Person</em> <em>结构体 <strong>Person</strong> 类型</em></p>
<p>type Person <strong>struct</strong> {</p>
<p>string</p>
<p><strong>int</strong></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>p1 := Person{</p>
<p>&quot;pprof.cn&quot;,</p>
<p>18,</p>
<p>}</p>
<p>fmt.Printf(&quot;%#v\n&quot;, p1) <em>//main.Person{string:&quot;pprof.cn&quot;, int:18}</em></p>
<p>fmt.Println(p1.string, p1. <strong>int</strong> ) <em>//pprof.cn 18</em></p>
<p>}</p>
<p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p>
<h3 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a><strong>嵌套结构体</strong></h3><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p>
<p><em>//Address</em> <em>地址结构体</em></p>
<p>type Address <strong>struct</strong> {</p>
<p>Province string</p>
<p>City string</p>
<p>}</p>
<p><em>//User</em> <em>用户结构体</em></p>
<p>type User <strong>struct</strong> {</p>
<p>Name string</p>
<p>Gender string</p>
<p>Address Address</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>user1 := User{</p>
<p>Name: &quot;pprof&quot;,</p>
<p>Gender: &quot;女&quot;,</p>
<p>Address: Address{</p>
<p>Province: &quot;黑龙江&quot;,</p>
<p>City: &quot;哈尔滨&quot;,</p>
<p>},</p>
<p>}</p>
<p>fmt.Printf(&quot;user1=%#v\n&quot;, user1)<em>//user1=main.User{Name:&quot;pprof&quot;, Gender:&quot; <strong>女</strong>&quot;, Address:main.Address{Province:&quot; <strong>黑龙江</strong>&quot;, City:&quot; <strong>哈尔滨</strong>&quot;}}</em></p>
<p>}</p>
<h3 id="嵌套匿名结构体"><a href="#嵌套匿名结构体" class="headerlink" title="嵌套匿名结构体"></a><strong>嵌套匿名结构体</strong></h3><p><em>//Address</em> <em>地址结构体</em></p>
<p>type Address <strong>struct</strong> {</p>
<p>Province <strong>string</strong></p>
<p>City <strong>string</strong></p>
<p>}</p>
<p><em>//User</em> <em>用户结构体</em></p>
<p>type User <strong>struct</strong> {</p>
<p>Name <strong>string</strong></p>
<p>Gender <strong>string</strong></p>
<p>Address <em>//__匿名结构体</em></p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> user2 User</p>
<p>user2.Name = &quot;pprof&quot;</p>
<p>user2.Gender = &quot;女&quot;</p>
<p>user2.Address.Province = &quot;黑龙江&quot;<em>// <strong>通过匿名结构体</strong>.__字段名访问</em></p>
<p>user2.City = &quot;哈尔滨&quot;<em>//__直接访问匿名结构体的字段名</em></p>
<p>fmt.Printf(&quot;user2=%#v\n&quot;, user2) <em>//user2=main.User{Name:&quot;pprof&quot;, Gender:&quot; <strong>女</strong>&quot;, Address:main.Address{Province:&quot; <strong>黑龙江</strong>&quot;, City:&quot; <strong>哈尔滨</strong>&quot;}}</em></p>
<p>}</p>
<p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</p>
<h3 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a><strong>嵌套结构体的字段名冲突</strong></h3><p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p>
<p><em>//Address</em> <em>地址结构体</em></p>
<p>type Address <strong>struct</strong> {</p>
<p>Province <strong>string</strong></p>
<p>City <strong>string</strong></p>
<p>CreateTime <strong>string</strong></p>
<p>}</p>
<p><em>//Email</em> <em>邮箱结构体</em></p>
<p>type Email <strong>struct</strong> {</p>
<p>Account <strong>string</strong></p>
<p>CreateTime <strong>string</strong></p>
<p>}</p>
<p><em>//User</em> <em>用户结构体</em></p>
<p>type User <strong>struct</strong> {</p>
<p>Name <strong>string</strong></p>
<p>Gender <strong>string</strong></p>
<p>Address</p>
<p>Email</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p><strong>var</strong> user3 User</p>
<p>user3.Name = &quot;pprof&quot;</p>
<p>user3.Gender = &quot;女&quot;</p>
<p><em>// user3.CreateTime = &quot;2019&quot; //ambiguous selector user3.CreateTime</em></p>
<p>user3.Address.CreateTime = &quot;2000&quot;<em>// <strong>指定</strong> Address <strong>结构体中的</strong> CreateTime</em></p>
<p>user3.Email.CreateTime = &quot;2000&quot;<em>// <strong>指定</strong> Email <strong>结构体中的</strong> CreateTime</em></p>
<p>}</p>
<h3 id="结构体的-quot-继承-quot"><a href="#结构体的-quot-继承-quot" class="headerlink" title="结构体的&quot;继承&quot;"></a><strong>结构体的&quot;继承&quot;</strong></h3><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p>
<p><em>//Animal</em> <em>动物</em></p>
<p>type Animal <strong>struct</strong> {</p>
<p>name string</p>
<p>}</p>
<p>func (a *Animal) move() {</p>
<p>fmt.Printf(&quot;%s会动！\n&quot;, a.name)</p>
<p>}</p>
<p><em>//Dog</em> <em>狗</em></p>
<p>type Dog <strong>struct</strong> {</p>
<p>Feet int8</p>
<p>*Animal <em>//__通过嵌套匿名结构体实现继承</em></p>
<p>}</p>
<p>func (d *Dog) wang() {</p>
<p>fmt.Printf(&quot;%s会汪汪汪~\n&quot;, d.name)</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>d1 := &amp;Dog{</p>
<p>Feet: 4,</p>
<p>Animal: &amp;Animal{ <em>//__注意嵌套的是结构体指针</em></p>
<p>name: &quot;乐乐&quot;,</p>
<p>},</p>
<p>}</p>
<p>d1.wang() <em>// <strong>乐乐会汪汪汪</strong> ~</em></p>
<p>d1.move() <em>//__乐乐会动！</em></p>
<p>}</p>
<h3 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a><strong>结构体字段的可见性</strong></h3><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p>
<h3 id="结构体与-JSON-序列化"><a href="#结构体与-JSON-序列化" class="headerlink" title="结构体与** JSON **序列化"></a><strong>结构体与**</strong> JSON <strong>**序列化</strong></h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号&quot;&quot;包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。</p>
<p><em>//Student</em> <em>学生</em></p>
<p>type Student <strong>struct</strong> {</p>
<p>ID <strong>int</strong></p>
<p>Gender <strong>string</strong></p>
<p>Name <strong>string</strong></p>
<p>}</p>
<p><em>//Class</em> <em>班级</em></p>
<p>type Class <strong>struct</strong> {</p>
<p>Title <strong>string</strong></p>
<p>Students []*Student</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>c := &amp;Class{</p>
<p>Title: &quot;101&quot;,</p>
<p>Students: make([]*Student, 0, 200),</p>
<p>}</p>
<p><strong>for</strong> i := 0; i &amp;lt; 10; i++ {</p>
<p>stu := &amp;Student{</p>
<p>Name: fmt.Sprintf(&quot;stu%02d&quot;, i),</p>
<p>Gender: &quot;男&quot;,</p>
<p>ID: i,</p>
<p>}</p>
<p>c.Students = append(c.Students, stu)</p>
<p>}</p>
<p><em>//JSON <strong>序列化：结构体</strong> –&amp;gt;JSON__格式的字符串</em></p>
<p>data, err := json.Marshal(c)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;json marshal failed&quot;)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>fmt.Printf(&quot;json:%s\n&quot;, data)</p>
<p><em>//JSON <strong>反序列化：</strong> JSON <strong>格式的字符串</strong> –&amp;gt;__结构体</em></p>
<p>str := <code>{&amp;quot;Title&amp;quot;:&amp;quot;101&amp;quot;,&amp;quot;Students&amp;quot;:[{&amp;quot;ID&amp;quot;:0,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu00&amp;quot;},{&amp;quot;ID&amp;quot;:1,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu01&amp;quot;},{&amp;quot;ID&amp;quot;:2,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu02&amp;quot;},{&amp;quot;ID&amp;quot;:3,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu03&amp;quot;},{&amp;quot;ID&amp;quot;:4,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu04&amp;quot;},{&amp;quot;ID&amp;quot;:5,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu05&amp;quot;},{&amp;quot;ID&amp;quot;:6,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu06&amp;quot;},{&amp;quot;ID&amp;quot;:7,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu07&amp;quot;},{&amp;quot;ID&amp;quot;:8,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu08&amp;quot;},{&amp;quot;ID&amp;quot;:9,&amp;quot;Gender&amp;quot;:&amp;quot;男&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;stu09&amp;quot;}]}</code></p>
<p>c1 := &amp;Class{}</p>
<p>err = json.Unmarshal([] <strong>byte</strong> (str), c1)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;json unmarshal failed!&quot;)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>fmt.Printf(&quot;%#v\n&quot;, c1)</p>
<p>}</p>
<h3 id="结构体标签（-Tag-）"><a href="#结构体标签（-Tag-）" class="headerlink" title="结构体标签（** Tag **）"></a><strong>结构体标签（**</strong> Tag <strong>**）</strong></h3><p>Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。</p>
<p>Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p>
<p><code>key1:&amp;quot;value1&amp;quot; key2:&amp;quot;value2&amp;quot;</code></p>
<p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 注意事项： 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p>
<p>例如我们为Student结构体的每个字段定义json序列化时使用的Tag：</p>
<p><em>//Student</em> <em>学生</em></p>
<p>type Student <strong>struct</strong> {</p>
<p>ID <strong>int</strong> <code>json:&amp;quot;id&amp;quot;</code> <em>// <strong>通过指定</strong> tag <strong>实现</strong> json <strong>序列化该字段时的</strong> key</em></p>
<p>Gender string_//json <strong>序列化是默认使用字段名作为</strong> key_</p>
<p>name string_// <strong>私有不能被</strong> json__包访问_</p>
<p>}</p>
<p>func <strong>main</strong> () {</p>
<p>s1 := Student{</p>
<p>ID: 1,</p>
<p>Gender: &quot;女&quot;,</p>
<p>name: &quot;pprof&quot;,</p>
<p>}</p>
<p>data, err := json.Marshal(s1)</p>
<p><strong>if</strong> err != nil {</p>
<p>fmt.Println(&quot;json marshal failed!&quot;)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>fmt.Printf(&quot;json str:%s\n&quot;, data) <em>//json str:{&quot;id&quot;:1,&quot;Gender&quot;:&quot; <strong>女</strong>&quot;}</em></p>
<p>}</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:yjw-1017@outlook.com">vio-jw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://1py1vm.coding-pages.com/2021/01/09/%E7%BB%93%E6%9E%84%E4%BD%93/">http://1py1vm.coding-pages.com/2021/01/09/%E7%BB%93%E6%9E%84%E4%BD%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://1py1vm.coding-pages.com" target="_blank">Jw's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a></div><div class="post_share"><div class="social-share" data-image="https://wallroom.io/img/1920x1080/bg-12d9d47.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/01/09/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5switch/"><img class="prev_cover lazyload" data-src="https://wallroom.io/img/1920x1080/bg-129be97.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">条件语句switch</div></div></a></div><div class="next-post pull_right"><a href="/2021/01/09/map%E5%BA%95%E5%B1%82/"><img class="next_cover lazyload" data-src="https://wallroom.io/img/1920x1080/bg-2c050a7.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">map底层</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/01/07/golang内置类型和函数/" title="golang内置类型和函数"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-119e935.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-07</div><div class="relatedPosts_title">golang内置类型和函数</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/08/Init函数和main函数/" title="Init函数和main函数"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-0d4abee.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-08</div><div class="relatedPosts_title">Init函数和main函数</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/08/命令/" title="命令"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-0cf6fd0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-08</div><div class="relatedPosts_title">命令</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/09/”基本类型“/" title="基本类型"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-0ecf3b1.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-09</div><div class="relatedPosts_title">基本类型</div></div></a></div><div class="relatedPosts_item"><a href="/2021/02/19/GMP原理和调度/" title="GMP原理和调度"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-12d9d47.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-02-19</div><div class="relatedPosts_title">GMP原理和调度</div></div></a></div><div class="relatedPosts_item"><a href="/2021/02/19/Channel/" title="Channel"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-05e3c1f.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-02-19</div><div class="relatedPosts_title">Channel</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'iEgNuNBCTaihslibuDwal7C5-gzGzoHsz',
  appKey: 'm6S8TQcmY7gNtxgbvUV8dBhp',
  placeholder: '分享你的想法吧~',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" style="background-image: url(https://wallroom.io/img/1920x1080/bg-0cf6fd0.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By vio-jw</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a><img class="icp-icon" src="/img/icp.png"/><span>闽ICP备20007536</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script></body></html>