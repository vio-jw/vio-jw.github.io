<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>slice底层实现 | Jw's Blog</title><meta name="description" content="slice底层实现"><meta name="keywords" content="golang"><meta name="author" content="vio-jw,yjw-1017@outlook.com"><meta name="copyright" content="vio-jw"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/u=1081158815,3939059762&fm=26&gp=0.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="slice底层实现"><meta name="twitter:description" content="slice底层实现"><meta name="twitter:image" content="https://wallroom.io/img/1920x1080/bg-2f6baac.jpg"><meta property="og:type" content="article"><meta property="og:title" content="slice底层实现"><meta property="og:url" content="http://1py1vm.coding-pages.com/2021/01/09/slice%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"><meta property="og:site_name" content="Jw's Blog"><meta property="og:description" content="slice底层实现"><meta property="og:image" content="https://wallroom.io/img/1920x1080/bg-2f6baac.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://1py1vm.coding-pages.com/2021/01/09/slice%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"><link rel="prev" title="指针" href="http://1py1vm.coding-pages.com/2021/01/09/%E6%8C%87%E9%92%88/"><link rel="next" title="切片slice" href="http://1py1vm.coding-pages.com/2021/01/09/%E5%88%87%E7%89%87slice/"><link rel="stylesheet" href="https://fonts.geekzu.org/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"正心,取势,明道,优术,修身,齐家,治国,平天下,践行,合众","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/20170917230838_HPMLr.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">49</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 爱好</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Slice"><span class="toc-number">1.</span> <span class="toc-text">Slice</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#底层实现"><span class="toc-number">2.</span> <span class="toc-text">底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#切片和数组"><span class="toc-number">2.0.1.</span> <span class="toc-text">切片和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片的数据结构"><span class="toc-number">2.0.2.</span> <span class="toc-text">切片的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建切片"><span class="toc-number">2.0.3.</span> <span class="toc-text">创建切片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#make-和切片字面量"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">make  和切片字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nil-和空切片"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">nil  和空切片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片扩容"><span class="toc-number">2.0.4.</span> <span class="toc-text">切片扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#扩容策略"><span class="toc-number">2.0.4.1.</span> <span class="toc-text">扩容策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#新数组-or-老数组-？"><span class="toc-number">2.0.4.2.</span> <span class="toc-text">新数组  or  老数组 ？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片拷贝"><span class="toc-number">2.0.5.</span> <span class="toc-text">切片拷贝</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://wallroom.io/img/1920x1080/bg-2f6baac.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Jw's Blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 爱好</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">slice底层实现</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-01-09 22:31:20"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-01-09</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-05-09 22:32:10"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-05-09</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/golang/">golang</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2021/01/09/slice%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2021/01/09/slice%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>#</p>
<h1 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h1><h1 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h1><p><strong>本章不属于基础部分但是面试经常会问到建议学学</strong></p>
<p>切片是 Go 中的一种基本的数据结构，使用这种结构可以用来管理数据集合。切片的设计想法是由动态数组概念而来，为了开发者可以更加方便的使一个数据结构可以自动增加和减少。但是切片本身并不是动态数据或者数组指针。切片常见的操作有 reslice、append、copy。与此同时，切片还具有可索引，可迭代的优秀特性。</p>
<h3 id="切片和数组"><a href="#切片和数组" class="headerlink" title="切片和数组"></a><strong>切片和数组</strong></h3><p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_e352b7e670418019.gif"  alt=""></p>
<p>关于切片和数组怎么选择？接下来好好讨论讨论这个问题。</p>
<p>在 Go 中，与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和函数传参操作都会复制整个数组数据。</p>
<p>func main() {</p>
<p>arrayA := [2] <strong>int</strong> {100, 200}</p>
<p>var arrayB [2] <strong>int</strong></p>
<p>arrayB = arrayA</p>
<p>fmt.Printf(&quot;arrayA : %p , %v\n&quot;, &amp;arrayA, arrayA)</p>
<p>fmt.Printf(&quot;arrayB : %p , %v\n&quot;, &amp;arrayB, arrayB)</p>
<p>testArray(arrayA)</p>
<p>}</p>
<p>func testArray( <strong>x</strong> [2] <strong>int</strong> ) {</p>
<p>fmt.Printf(&quot;func Array : %p , %v\n&quot;, &amp; <strong>x</strong> , <strong>x</strong> )</p>
<p>}</p>
<p>打印结果：</p>
<p>arrayA : 0xc4200bebf0 , <strong>[100 200]</strong></p>
<p>arrayB : 0xc4200bec00 , <strong>[100 200]</strong></p>
<p>func Array : 0xc4200bec30 , <strong>[100 200]</strong></p>
<p>可以看到，三个内存地址都不同，这也就验证了 Go 中数组赋值和函数传参都是值复制的。那这会导致什么问题呢？</p>
<p>假想每次传参都用数组，那么每次数组都要被复制一遍。如果数组大小有 100万，在64位机器上就需要花费大约 800W 字节，即 8MB 内存。这样会消耗掉大量的内存。于是乎有人想到，函数传参用数组的指针。</p>
<p>func <strong>main</strong> () {</p>
<p>arrayA := [2] <strong>int</strong> {100, 200}</p>
<p>testArrayPoint(&amp;arrayA) <em>// 1.__传数组指针</em></p>
<p>arrayB := arrayA[:]</p>
<p>testArrayPoint(&amp;arrayB) <em>// 2.__传切片</em></p>
<p>fmt.Printf(&quot;arrayA : %p , %v\n&quot;, &amp;arrayA, arrayA)</p>
<p>}</p>
<p>func <strong>testArrayPoint</strong> (x *[] <strong>int</strong> ) {</p>
<p>fmt.Printf(&quot;func Array : %p , %v\n&quot;, x, *x)</p>
<p>(*x)[1] += 100</p>
<p>}</p>
<p>打印结果：</p>
<p>func Array : 0xc4200b0140 , <strong>[100 200]</strong></p>
<p>func Array : 0xc4200b0180 , <strong>[100 300]</strong></p>
<p>arrayA : 0xc4200b0140 , <strong>[100 400]</strong></p>
<p>这也就证明了数组指针确实到达了我们想要的效果。现在就算是传入10亿的数组，也只需要再栈上分配一个8个字节的内存给指针就可以了。这样更加高效的利用内存，性能也比之前的好。</p>
<p>不过传指针会有一个弊端，从打印结果可以看到，第一行和第三行指针地址都是同一个，万一原数组的指针指向更改了，那么函数里面的指针指向都会跟着更改。</p>
<p>切片的优势也就表现出来了。用切片传数组参数，既可以达到节约内存的目的，也可以达到合理处理好共享内存的问题。打印结果第二行就是切片，切片的指针和原来数组的指针是不同的。</p>
<p>由此我们可以得出结论：</p>
<p>把第一个大数组传递给函数会消耗很多内存，采用切片的方式传参可以避免上述问题。切片是引用传递，所以它们不需要使用额外的内存并且比使用数组更有效率。</p>
<p>但是，依旧有反例。</p>
<p><strong>package</strong> main</p>
<p><strong>import</strong>&quot;testing&quot;</p>
<p>func <strong>array</strong> () [1024] <strong>int</strong> {</p>
<p>var x [1024] <strong>int</strong></p>
<p><strong>for</strong> i := 0; i &amp;lt; len(x); i++ {</p>
<p>x[i] = i</p>
<p>}</p>
<p><strong>return</strong> x</p>
<p>}</p>
<p>func <strong>slice</strong> () [] <strong>int</strong> {</p>
<p>x := make([] <strong>int</strong> , 1024)</p>
<p><strong>for</strong> i := 0; i &amp;lt; len(x); i++ {</p>
<p>x[i] = i</p>
<p>}</p>
<p><strong>return</strong> x</p>
<p>}</p>
<p>func <strong>BenchmarkArray</strong> (b *testing.B) {</p>
<p><strong>for</strong> i := 0; i &amp;lt; b.N; i++ {</p>
<p>array()</p>
<p>}</p>
<p>}</p>
<p>func <strong>BenchmarkSlice</strong> (b *testing.B) {</p>
<p><strong>for</strong> i := 0; i &amp;lt; b.N; i++ {</p>
<p>slice()</p>
<p>}</p>
<p>}</p>
<p>我们做一次性能测试，并且禁用内联和优化，来观察切片的堆上内存分配的情况。</p>
<p>go test -bench . -benchmem -gcflags &quot;-N -l&quot;</p>
<p>输出结果比较&quot;令人意外&quot;：</p>
<p>BenchmarkArray-4 500000 3637 ns/op 0 B/op 0 alloc s/op</p>
<p>BenchmarkSlice-4 300000 4055 ns/op 8192 B/op 1 alloc s/op</p>
<p>解释一下上述结果，在测试 Array 的时候，用的是4核，循环次数是500000，平均每次执行时间是3637 ns，每次执行堆上分配内存总量是0，分配次数也是0 。</p>
<p>而切片的结果就&quot;差&quot;一点，同样也是用的是4核，循环次数是300000，平均每次执行时间是4055 ns，但是每次执行一次，堆上分配内存总量是8192，分配次数也是1 。</p>
<p>这样对比看来，并非所有时候都适合用切片代替数组，因为切片底层数组可能会在堆上分配内存，而且小数组在栈上拷贝的消耗也未必比<br> make 消耗大。</p>
<h3 id="切片的数据结构"><a href="#切片的数据结构" class="headerlink" title="切片的数据结构"></a><strong>切片的数据结构</strong></h3><p>切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。</p>
<p>切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个与指向数组的动态窗口。</p>
<p>给定项的切片索引可能比相关数组的相同元素的索引小。和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个长度可变的数组。</p>
<p>Slice 的数据结构定义如下:</p>
<p>type slice <strong>struct</strong> {</p>
<p>array unsafe.Pointer</p>
<p>len <strong>int</strong></p>
<p>cap <strong>int</strong></p>
<p>}</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_c686a3c163ab625e.gif"  alt=""></p>
<p>切片的结构体由3部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_402755e53a58b0fd.gif"  alt=""></p>
<p>如果想从 slice 中得到一块内存地址，可以这样做：</p>
<p>s := make([] <strong>byte</strong> , 200)</p>
<p>ptr := <strong>unsafe</strong>.Pointer(&amp;s[0])</p>
<p>如果反过来呢？从 Go 的内存地址中构造一个 slice。</p>
<p><strong>var</strong> ptr <strong>unsafe</strong>.Pointer <strong>var</strong> s1 = <strong>struct</strong> {</p>
<p>addr uintptr</p>
<p>len <strong>int</strong></p>
<p>cap <strong>int</strong></p>
<p>}{ptr, length, length}</p>
<p>s := *(*[] <strong>byte</strong> )( <strong>unsafe</strong>.Pointer(&amp;s1))</p>
<p>构造一个虚拟的结构体，把 slice 的数据结构拼出来。</p>
<p>当然还有更加直接的方法，在 Go 的反射中就存在一个与之对应的数据结构 SliceHeader，我们可以用它来构造一个 slice</p>
<p><strong>var</strong> o [] <strong>byte</strong></p>
<p>sliceHeader := (*reflect.SliceHeader)(( <strong>unsafe</strong>.Pointer(&amp;o)))</p>
<p>sliceHeader.Cap = length</p>
<p>sliceHeader.Len = length</p>
<p>sliceHeader.Data = uintptr(ptr)</p>
<h3 id="创建切片"><a href="#创建切片" class="headerlink" title="创建切片"></a><strong>创建切片</strong></h3><p>make 函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。</p>
<p>创建切片有两种形式，make 创建切片，空切片。</p>
<h4 id="make-和切片字面量"><a href="#make-和切片字面量" class="headerlink" title="make  和切片字面量"></a><strong>make</strong>  <strong>和切片字面量</strong></h4><p>func <strong>makeslice</strong> (et *_type, len, cap <strong>int</strong> ) slice {</p>
<p><em>//</em> <em>根据切片的数据类型，获取切片的最大容量</em></p>
<p>maxElements := maxSliceCap(et.size)</p>
<p><em>//</em> <em>比较切片的长度，长度值域应该在<strong>[0,maxElements]</strong>之间</em></p>
<p><strong>if</strong> len &amp;lt; 0 || uintptr(len) &amp;gt; maxElements {</p>
<p>panic(errorString(&quot;makeslice: len out of range&quot;))</p>
<p>}</p>
<p><em>//</em> <em>比较切片的容量，容量值域应该在<strong>[len,maxElements]</strong>之间</em></p>
<p><strong>if</strong> cap &amp;lt; len || uintptr(cap) &amp;gt; maxElements {</p>
<p>panic(errorString(&quot;makeslice: cap out of range&quot;))</p>
<p>}</p>
<p><em>//</em> <em>根据切片的容量申请内存</em></p>
<p>p := mallocgc(et.size*uintptr(cap), et, true)</p>
<p><em>//</em> <em>返回申请好内存的切片的首地址</em></p>
<p><strong>return</strong> slice{p, len, cap}</p>
<p>}</p>
<p>还有一个 int64 的版本：</p>
<p>func makeslice64(et *_type, len64, cap64 int64) slice {</p>
<p>len := int(len64)</p>
<p><strong>if</strong> int64(len) != len64 {</p>
<p>panic(errorString(&quot;makeslice: len out of range&quot;))</p>
<p>}</p>
<p>cap := int(cap64)</p>
<p><strong>if</strong> int64(cap) != cap64 {</p>
<p>panic(errorString(&quot;makeslice: cap out of range&quot;))</p>
<p>}</p>
<p>return makeslice(et, len, cap)</p>
<p>}</p>
<p>实现原理和上面的是一样的，只不过多了把 int64 转换成 int 这一步罢了。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_126c0648a5821967.gif"  alt=""></p>
<p>上图是用 make 函数创建的一个 len = 4， cap = 6 的切片。内存空间申请了6个 int 类型的内存大小。由于 len = 4，所以后面2个暂时访问不到，但是容量还是在的。这时候数组里面每个变量都是0 。</p>
<p>除了 make 函数可以创建切片以外，字面量也可以创建切片。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_ea9899f0204721f2.gif"  alt=""></p>
<p>这里是用字面量创建的一个 len = 6，cap = 6 的切片，这时候数组里面每个元素的值都初始化完成了。需要注意的是 [] 里面不要写数组的容量，因为如果写了个数以后就是数组了，而不是切片了。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_e7bfbfb11184a935.gif"  alt=""></p>
<p>还有一种简单的字面量创建切片的方法。如上图。上图就 Slice A 创建出了一个 len = 3，cap = 3 的切片。从原数组的第二位元素(0是第一位)开始切，一直切到第四位为止(不包括第五位)。同理，Slice B 创建出了一个 len = 2，cap = 4 的切片。</p>
<h4 id="nil-和空切片"><a href="#nil-和空切片" class="headerlink" title="nil  和空切片"></a><strong>nil</strong>  <strong>和空切片</strong></h4><p>nil 切片和空切片也是常用的。</p>
<p><strong>var</strong> slice [] <strong>int</strong></p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_f0a0d73823735804.gif"  alt=""></p>
<p>nil 切片被用在很多标准库和内置函数中，描述一个不存在的切片的时候，就需要用到 nil 切片。比如函数在发生异常的时候，返回的切片就是 nil 切片。nil 切片的指针指向 nil。</p>
<p>空切片一般会用来表示一个空的集合。比如数据库查询，一条结果也没有查到，那么就可以返回一个空切片。</p>
<p>silce := make( [] <strong>int</strong> , 0 )</p>
<p>slice := [] <strong>int</strong> { }</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_c207da75ab2a4e00.gif"  alt=""></p>
<p>空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。</p>
<p>最后需要说明的一点是。不管是使用 nil 切片还是空切片，对其调用内置函数 append，len 和 cap 的效果都是一样的。</p>
<h3 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a><strong>切片扩容</strong></h3><p>当一个切片的容量满了，就需要扩容了。怎么扩，策略是什么？</p>
<p>func <strong>growslice</strong> (et *_type, old slice, cap <strong>int</strong> ) slice {</p>
<p><strong>if</strong> raceenabled {</p>
<p>callerpc := getcallerpc( <strong>unsafe</strong>.Pointer(&amp;et))</p>
<p>racereadrangepc(old.array, uintptr(old.len\ <strong>*int</strong> (et.size)), callerpc, funcPC(growslice))</p>
<p>}</p>
<p><strong>if</strong> msanenabled {</p>
<p>msanread(old.array, uintptr(old.len\ <strong>*int</strong> (et.size)))</p>
<p>}</p>
<p><strong>if</strong> et.size == 0 {</p>
<p><em>//</em> <em>如果新要扩容的容量比原来的容量还要小，这代表要缩容了，那么可以直接报 <strong>panic</strong> 了。</em></p>
<p><strong>if</strong> cap &amp;lt; old.cap {</p>
<p>panic(errorString(&quot;growslice: cap out of range&quot;))</p>
<p>}</p>
<p><em>//</em> <em>如果当前切片的大小为 <strong>0</strong> ，还调用了扩容方法，那么就新生成一个新的容量的切片返回。</em></p>
<p><strong>return</strong> slice{ <strong>unsafe</strong>.Pointer(&amp;zerobase), old.len, cap}</p>
<p>}</p>
<p><em>//</em> <em>这里就是扩容的策略</em></p>
<p>newcap := old.cap</p>
<p>doublecap := newcap + newcap</p>
<p><strong>if</strong> cap &amp;gt; doublecap {</p>
<p>newcap = cap</p>
<p>} <strong>else</strong> {</p>
<p><strong>if</strong> old.len &amp;lt; 1024 {</p>
<p>newcap = doublecap</p>
<p>} <strong>else</strong> {</p>
<p><strong>for</strong> newcap &amp;lt; cap {</p>
<p>newcap += newcap / 4</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><em>//</em> <em>计算新的切片的容量，长度。</em></p>
<p><strong>var</strong> lenmem, newlenmem, capmem uintptr</p>
<p><strong>const</strong> ptrSize = <strong>unsafe</strong>.Sizeof((\ <strong>*byte</strong> )(nil))</p>
<p><strong>switch</strong> et.size {</p>
<p><strong>case</strong> 1:</p>
<p>lenmem = uintptr(old.len)</p>
<p>newlenmem = uintptr(cap)</p>
<p>capmem = roundupsize(uintptr(newcap))</p>
<p>newcap = <strong>int</strong> (capmem)</p>
<p><strong>case</strong> ptrSize:</p>
<p>lenmem = uintptr(old.len) * ptrSize</p>
<p>newlenmem = uintptr(cap) * ptrSize</p>
<p>capmem = roundupsize(uintptr(newcap) * ptrSize)</p>
<p>newcap = <strong>int</strong> (capmem / ptrSize)</p>
<p><strong>default</strong> :</p>
<p>lenmem = uintptr(old.len) * et.size</p>
<p>newlenmem = uintptr(cap) * et.size</p>
<p>capmem = roundupsize(uintptr(newcap) * et.size)</p>
<p>newcap = <strong>int</strong> (capmem / et.size)</p>
<p>}</p>
<p><em>//</em> <em>判断非法的值，保证容量是在增加，并且容量不超过最大容量</em></p>
<p><strong>if</strong> cap &amp;lt; old.cap || uintptr(newcap) &amp;gt; maxSliceCap(et.size) {</p>
<p>panic(errorString(&quot;growslice: cap out of range&quot;))</p>
<p>}</p>
<p><strong>var</strong> p <strong>unsafe</strong>.Pointer</p>
<p><strong>if</strong> et.kind&amp;kindNoPointers != 0 {</p>
<p><em>//</em> <em>在老的切片后面继续扩充容量</em></p>
<p>p = mallocgc(capmem, nil, false)</p>
<p><em>//</em> <em>将</em> <em>lenmem</em> <em>这个多个</em> <em>bytes</em> <em>从</em> <em>old.array__地址 拷贝到</em> <em>p</em> <em>的地址处</em></p>
<p>memmove(p, old.array, lenmem)</p>
<p><em>//</em> <em>先将</em> <em>P</em> <em>地址加上新的容量得到新切片容量的地址，然后将新切片容量地址后面的</em> <em>capmem-newlenmem</em> <em>个</em> <em>bytes</em> <em>这块内存初始化。为之后继续</em> <em>append()</em> <em>操作腾出空间。</em></p>
<p>memclrNoHeapPointers( <strong>add</strong> (p, newlenmem), capmem-newlenmem)</p>
<p>} <strong>else</strong> {</p>
<p><em>//</em> <em>重新申请新的数组给新切片</em></p>
<p><em>//</em> <em>重新申请</em> <em>capmen</em> <em>这个大的内存地址，并且初始化为 <strong>0</strong> 值</em></p>
<p>p = mallocgc(capmem, et, true)</p>
<p><strong>if</strong>!writeBarrier.enabled {</p>
<p><em>//</em> <em>如果还不能打开写锁，那么只能把</em> <em>lenmem</em> <em>大小的</em> <em>bytes</em> <em>字节从</em> <em>old.array</em> <em>拷贝到</em> <em>p</em> <em>的地址处</em></p>
<p>memmove(p, old.array, lenmem)</p>
<p>} <strong>else</strong> {</p>
<p><em>//</em> <em>循环拷贝老的切片的值</em></p>
<p><strong>for</strong> i := uintptr(0); i &amp;lt; lenmem; i += et.size {</p>
<p>typedmemmove(et, <strong>add</strong> (p, i), <strong>add</strong> (old.array, i))</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><em>//</em> <em>返回最终新切片，容量更新为最新扩容之后的容量</em></p>
<p><strong>return</strong> slice{p, old.len, newcap}</p>
<p>}</p>
<p>上述就是扩容的实现。主要需要关注的有两点，一个是扩容时候的策略，还有一个就是扩容是生成全新的内存地址还是在原来的地址后追加。</p>
<h4 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a><strong>扩容策略</strong></h4><p>先看看扩容策略。</p>
<p>func main() {</p>
<p>slice := [] <strong>int</strong> {10, 20, 30, 40}</p>
<p>newSlice := append(slice, 50)</p>
<p>fmt.Printf(&quot;Before slice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, slice, &amp;slice, len(slice), cap(slice))</p>
<p>fmt.Printf(&quot;Before newSlice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, newSlice, &amp;newSlice, len(newSlice), cap(newSlice))</p>
<p>newSlice[1] += 10</p>
<p>fmt.Printf(&quot;After slice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, slice, &amp;slice, len(slice), cap(slice))</p>
<p>fmt.Printf(&quot;After newSlice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, newSlice, &amp;newSlice, len(newSlice), cap(newSlice))</p>
<p>}</p>
<p>输出结果：</p>
<p>Before slice = [10 20 30 40], Pointer = 0xc4200b0140, len = 4, cap = 4</p>
<p>Before newSlice = [10 20 30 40 50], Pointer = 0xc4200b0180, len = 5, cap = 8</p>
<p>After slice = [10 20 30 40], Pointer = 0xc4200b0140, len = 4, cap = 4</p>
<p>After newSlice = [10 30 30 40 50], Pointer = 0xc4200b0180, len = 5, cap = 8</p>
<p>用图表示出上述过程。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_ef61c79aff3e9d58.gif"  alt=""></p>
<p>从图上我们可以很容易的看出，新的切片和之前的切片已经不同了，因为新的切片更改了一个值，并没有影响到原来的数组，新切片指向的数组是一个全新的数组。并且 cap 容量也发生了变化。这之间究竟发生了什么呢？</p>
<p>Go 中切片扩容的策略是这样的：</p>
<p>如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。上面那个例子也验证了这一情况，总容量从原来的4个翻倍到现在的8个。</p>
<p>一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。</p>
<p>注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。</p>
<h4 id="新数组-or-老数组-？"><a href="#新数组-or-老数组-？" class="headerlink" title="新数组  or  老数组 ？"></a><strong>新数组</strong>  <strong>or</strong>  <strong>老数组 ？</strong></h4><p>再谈谈扩容之后的数组一定是新的么？这个不一定，分两种情况。</p>
<p>情况一：</p>
<p>func main() {</p>
<p>array := [4] <strong>int</strong> {10, 20, 30, 40}</p>
<p>slice := array[0:2]</p>
<p>newSlice := append(slice, 50)</p>
<p>fmt.Printf(&quot;Before slice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, slice, &amp;slice, len(slice), cap(slice))</p>
<p>fmt.Printf(&quot;Before newSlice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, newSlice, &amp;newSlice, len(newSlice), cap(newSlice))</p>
<p>newSlice[1] += 10</p>
<p>fmt.Printf(&quot;After slice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, slice, &amp;slice, len(slice), cap(slice))</p>
<p>fmt.Printf(&quot;After newSlice = %v, Pointer = %p, len = %d, cap = %d\n&quot;, newSlice, &amp;newSlice, len(newSlice), cap(newSlice))</p>
<p>fmt.Printf(&quot;After array = %v\n&quot;, array)</p>
<p>}</p>
<p>打印输出：</p>
<p>Before slice = [10 20], Pointer = 0xc4200c0040, len = 2, cap = 4</p>
<p>Before newSlice = [10 20 50], Pointer = 0xc4200c0060, len = 3, cap = 4</p>
<p>After slice = [10 30], Pointer = 0xc4200c0040, len = 2, cap = 4</p>
<p>After newSlice = [10 30 50], Pointer = 0xc4200c0060, len = 3, cap = 4</p>
<p>After array = [10 30 50 40]</p>
<p>把上述过程用图表示出来，如下图。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_28fdd699b35ba17.gif"  alt=""></p>
<p>通过打印的结果，我们可以看到，在这种情况下，扩容以后并没有新建一个新的数组，扩容前后的数组都是同一个，这也就导致了新的切片修改了一个值，也影响到了老的切片了。并且 append() 操作也改变了原来数组里面的值。一个 append() 操作影响了这么多地方，如果原数组上有多个切片，那么这些切片都会被影响！无意间就产生了莫名的 bug！</p>
<p>这种情况，由于原数组还有容量可以扩容，所以执行 append() 操作以后，会在原数组上直接操作，所以这种情况下，扩容以后的数组还是指向原来的数组。</p>
<p>这种情况也极容易出现在字面量创建切片时候，第三个参数 cap 传值的时候，如果用字面量创建切片，cap 并不等于指向数组的总容量，那么这种情况就会发生。</p>
<p>slice := array[1:2:3]</p>
<p>上面这种情况非常危险，极度容易产生 bug 。</p>
<p>建议用字面量创建切片的时候，cap 的值一定要保持清醒，避免共享原数组导致的 bug。</p>
<p>情况二：</p>
<p>情况二其实就是在扩容策略里面举的例子，在那个例子中之所以生成了新的切片，是因为原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组。</p>
<p>所以建议尽量避免情况一，尽量使用情况二，避免 bug 产生。</p>
<h3 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a><strong>切片拷贝</strong></h3><p>Slice 中拷贝方法有2个。</p>
<p>func <strong>slicecopy</strong> (to, fm slice, width uintptr) <strong>int</strong> {</p>
<p><em>//</em> <em>如果源切片或者目标切片有一个长度为 <strong>0</strong> ，那么就不需要拷贝，直接</em> <em>return</em></p>
<p><strong>if</strong> fm.len == 0 || to.len == 0 {</p>
<p><strong>return</strong> 0</p>
<p>}</p>
<p><em>// n</em> <em>记录下源切片或者目标切片较短的那一个的长度</em></p>
<p>n := fm.len</p>
<p><strong>if</strong> to.len &amp;lt; n {</p>
<p>n = to.len</p>
<p>}</p>
<p><em>//</em> <em>如果入参</em> <em>width = 0__，也不需要拷贝了，返回较短的切片的长度</em></p>
<p><strong>if</strong> width == 0 {</p>
<p><strong>return</strong> n</p>
<p>}</p>
<p><em>//</em> <em>如果开启了竞争检测</em></p>
<p><strong>if</strong> raceenabled {</p>
<p>callerpc := getcallerpc(unsafe.Pointer(&amp;to))</p>
<p>pc := funcPC(slicecopy)</p>
<p>racewriterangepc(to.array, uintptr(n\ <strong>*int</strong> (width)), callerpc, pc)</p>
<p>racereadrangepc(fm.array, uintptr(n\ <strong>*int</strong> (width)), callerpc, pc)</p>
<p>}</p>
<p><em>//</em> <em>如果开启了</em> <em>The memory sanitizer (msan)</em></p>
<p><strong>if</strong> msanenabled {</p>
<p>msanwrite(to.array, uintptr(n\ <strong>*int</strong> (width)))</p>
<p>msanread(fm.array, uintptr(n\ <strong>*int</strong> (width)))</p>
<p>}</p>
<p>size := uintptr(n) * width</p>
<p><strong>if</strong> size == 1 {</p>
<p><em>//</em> <em>TODO:</em> <em>is this still worth it with new memmove impl?</em></p>
<p><em>//</em> <em>如果只有一个元素，那么指针直接转换即可</em></p>
<p>*(*byte)(to.array) = *(*byte)(fm.array) <em>// known to be a byte pointer</em></p>
<p>} <strong>else</strong> {</p>
<p><em>//</em> <em>如果不止一个元素，那么就把</em> <em>size</em> <em>个</em> <em>bytes</em> <em>从</em> <em>fm.array</em> <em>地址开始，拷贝到</em> <em>to.array</em> <em>地址之后</em></p>
<p>memmove(to.array, fm.array, size)</p>
<p>}</p>
<p><strong>return</strong> n</p>
<p>}</p>
<p>在这个方法中，slicecopy 方法会把源切片值(即 fm Slice )中的元素复制到目标切片(即 to Slice )中，并返回被复制的元素个数，copy 的两个类型必须一致。slicecopy 方法最终的复制结果取决于较短的那个切片，当较短的切片复制完成，整个复制过程就全部完成了。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_f80b1bdd4ca699a8.gif"  alt=""></p>
<p>举个例子，比如：</p>
<p>func <strong>main</strong> () {</p>
<p>array := [] <strong>int</strong> {10, 20, 30, 40}</p>
<p>slice := make([] <strong>int</strong> , 6)</p>
<p>n := copy(slice, array)</p>
<p>fmt.Println(n,slice)</p>
<p>}</p>
<p>还有一个拷贝的方法，这个方法原理和 slicecopy 方法类似，不在赘述了，注释写在代码里面了。</p>
<p>func <strong>slicestringcopy</strong> (to [] <strong>byte</strong> , fm <strong>string</strong> ) <strong>int</strong> {</p>
<p><em>//</em> <em>如果源切片或者目标切片有一个长度为 <strong>0</strong> ，那么就不需要拷贝，直接</em> <em>return</em></p>
<p><strong>if**</strong> len**(fm) == 0 || len(to) == 0 {</p>
<p><strong>return</strong> 0</p>
<p>}</p>
<p><em>// n</em> <em>记录下源切片或者目标切片较短的那一个的长度</em></p>
<p>n := len(fm)</p>
<p><strong>if**</strong> len**(to) &amp;lt; n {</p>
<p>n = len(to)</p>
<p>}</p>
<p><em>//</em> <em>如果开启了竞争检测</em></p>
<p><strong>if</strong> raceenabled {</p>
<p>callerpc := getcallerpc( <strong>unsafe</strong>.Pointer(&amp;to))</p>
<p>pc := funcPC(slicestringcopy)</p>
<p>racewriterangepc( <strong>unsafe</strong>.Pointer(&amp;to[0]), uintptr(n), callerpc, pc)</p>
<p>}</p>
<p><em>//</em> <em>如果开启了</em> <em>The memory sanitizer (msan)</em></p>
<p><strong>if</strong> msanenabled {</p>
<p>msanwrite( <strong>unsafe</strong>.Pointer(&amp;to[0]), uintptr(n))</p>
<p>}</p>
<p><em>//</em> <em>拷贝字符串至字节数组</em></p>
<p>memmove( <strong>unsafe</strong>.Pointer(&amp;to[0]), stringStructOf(&amp;fm).str, uintptr(n))</p>
<p><strong>return</strong> n</p>
<p>}</p>
<p>再举个例子，比如：</p>
<p><strong>func**</strong> main**() {</p>
<p>slice := make([]byte, 3)</p>
<p>n := copy(slice, &quot;abcdef&quot;)</p>
<p>fmt.Println(n,slice)</p>
<p>}</p>
<p>输出：</p>
<p>3 [97,98,99]</p>
<p>说到拷贝，切片中有一个需要注意的问题。</p>
<p>func main() {</p>
<p>slice := [] <strong>int</strong> {10, 20, 30, 40}</p>
<p><strong>for**</strong> index**, value := range slice {</p>
<p>fmt.Printf(&quot;value = %d , value-addr = %x , slice-addr = %x\n&quot;, value, &amp;value, &amp;slice[<strong>index</strong>])</p>
<p>}</p>
<p>}</p>
<p>输出：</p>
<p><strong>value</strong> = 10 , <strong>value</strong> -addr = c4200aedf8 , slice-addr = c4200b0320</p>
<p><strong>value</strong> = 20 , <strong>value</strong> -addr = c4200aedf8 , slice-addr = c4200b0328</p>
<p><strong>value</strong> = 30 , <strong>value</strong> -addr = c4200aedf8 , slice-addr = c4200b0330</p>
<p><strong>value</strong> = 40 , <strong>value</strong> -addr = c4200aedf8 , slice-addr = c4200b0338</p>
<p>从上面结果我们可以看到，如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。所以每次打印 Value 的地址都不变。</p>
<p><img src="/" class="lazyload" data-src="RackMultipart20210430-4-jez5xf_html_d576ca1982dc9d54.gif"  alt=""></p>
<p>由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 &amp;slice[index] 获取真实的地址。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:yjw-1017@outlook.com">vio-jw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://1py1vm.coding-pages.com/2021/01/09/slice%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">http://1py1vm.coding-pages.com/2021/01/09/slice%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://1py1vm.coding-pages.com" target="_blank">Jw's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a></div><div class="post_share"><div class="social-share" data-image="https://wallroom.io/img/1920x1080/bg-12d9d47.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/01/09/%E6%8C%87%E9%92%88/"><img class="prev_cover lazyload" data-src="https://wallroom.io/img/1920x1080/bg-22331bf.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">指针</div></div></a></div><div class="next-post pull_right"><a href="/2021/01/09/%E5%88%87%E7%89%87slice/"><img class="next_cover lazyload" data-src="https://wallroom.io/img/1920x1080/bg-1c91ee8.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">切片slice</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/01/07/golang内置类型和函数/" title="golang内置类型和函数"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-119e935.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-07</div><div class="relatedPosts_title">golang内置类型和函数</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/08/Init函数和main函数/" title="Init函数和main函数"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-0d4abee.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-08</div><div class="relatedPosts_title">Init函数和main函数</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/08/命令/" title="命令"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-0cf6fd0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-08</div><div class="relatedPosts_title">命令</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/09/”基本类型“/" title="基本类型"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-0ecf3b1.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-09</div><div class="relatedPosts_title">基本类型</div></div></a></div><div class="relatedPosts_item"><a href="/2021/02/19/GMP原理和调度/" title="GMP原理和调度"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-12d9d47.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-02-19</div><div class="relatedPosts_title">GMP原理和调度</div></div></a></div><div class="relatedPosts_item"><a href="/2021/02/19/Channel/" title="Channel"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-05e3c1f.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-02-19</div><div class="relatedPosts_title">Channel</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'iEgNuNBCTaihslibuDwal7C5-gzGzoHsz',
  appKey: 'm6S8TQcmY7gNtxgbvUV8dBhp',
  placeholder: '分享你的想法吧~',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" style="background-image: url(https://wallroom.io/img/1920x1080/bg-2f6baac.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By vio-jw</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a><img class="icp-icon" src="/img/icp.png"/><span>闽ICP备20007536</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script></body></html>