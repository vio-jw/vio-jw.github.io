<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>单元测试 | Jw's Blog</title><meta name="description" content="单元测试"><meta name="keywords" content="golang"><meta name="author" content="vio-jw,yjw-1017@outlook.com"><meta name="copyright" content="vio-jw"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/u=1081158815,3939059762&fm=26&gp=0.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="单元测试"><meta name="twitter:description" content="单元测试"><meta name="twitter:image" content="https://wallroom.io/img/1920x1080/bg-2b801d4.jpg"><meta property="og:type" content="article"><meta property="og:title" content="单元测试"><meta property="og:url" content="http://1py1vm.coding-pages.com/2021/02/19/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"><meta property="og:site_name" content="Jw's Blog"><meta property="og:description" content="单元测试"><meta property="og:image" content="https://wallroom.io/img/1920x1080/bg-2b801d4.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://1py1vm.coding-pages.com/2021/02/19/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"><link rel="prev" title="闭包、递归" href="http://1py1vm.coding-pages.com/2021/02/19/%E9%97%AD%E5%8C%85%E3%80%81%E9%80%92%E5%BD%92/"><link rel="next" title="定时器" href="http://1py1vm.coding-pages.com/2021/02/19/%E5%AE%9A%E6%97%B6%E5%99%A8/"><link rel="stylesheet" href="https://fonts.geekzu.org/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"正心,取势,明道,优术,修身,齐家,治国,平天下,践行,合众","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/20170917230838_HPMLr.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">49</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 爱好</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#单元测试"><span class="toc-number">1.</span> <span class="toc-text">单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#go-test-工具"><span class="toc-number">1.1.</span> <span class="toc-text">go test** 工具**</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试函数"><span class="toc-number">1.2.</span> <span class="toc-text">测试函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#测试函数的格式"><span class="toc-number">1.2.1.</span> <span class="toc-text">测试函数的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试函数示例"><span class="toc-number">1.2.2.</span> <span class="toc-text">测试函数示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试组"><span class="toc-number">1.3.</span> <span class="toc-text">测试组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#子测试"><span class="toc-number">1.4.</span> <span class="toc-text">子测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试覆盖率"><span class="toc-number">1.5.</span> <span class="toc-text">测试覆盖率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基准测试"><span class="toc-number">1.6.</span> <span class="toc-text">基准测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基准测试函数格式"><span class="toc-number">1.6.1.</span> <span class="toc-text">基准测试函数格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基准测试示例"><span class="toc-number">1.6.2.</span> <span class="toc-text">基准测试示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能比较函数"><span class="toc-number">1.6.3.</span> <span class="toc-text">性能比较函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重置时间"><span class="toc-number">1.6.4.</span> <span class="toc-text">重置时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并行测试"><span class="toc-number">1.6.5.</span> <span class="toc-text">并行测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Setup-与-TearDown"><span class="toc-number">1.7.</span> <span class="toc-text">Setup** 与 **TearDown</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TestMain"><span class="toc-number">1.7.1.</span> <span class="toc-text">TestMain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子测试的-Setup-与-Teardown"><span class="toc-number">1.7.2.</span> <span class="toc-text">子测试的** Setup 与 Teardown**</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例函数"><span class="toc-number">1.8.</span> <span class="toc-text">示例函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#示例函数示例"><span class="toc-number">1.8.1.</span> <span class="toc-text">示例函数示例</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://wallroom.io/img/1920x1080/bg-2b801d4.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Jw's Blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 爱好</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">单元测试</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-02-19 22:39:19"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-02-19</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-05-09 22:51:18"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-05-09</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/golang/">golang</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2021/02/19/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2021/02/19/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>#</p>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>不写测试的开发不是好程序员。我个人非常崇尚TDD（Test Driven Development）的，然而可惜的是国内的程序员都不太关注测试这一部分。 这篇文章主要介绍下在Go语言中如何做单元测试和基准测试。</p>
<h2 id="go-test-工具"><a href="#go-test-工具" class="headerlink" title="go test** 工具**"></a><strong>go test**</strong> 工具**</h2><p>Go语言中的测试依赖go test命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。</p>
<p>go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以_test.go为后缀名的源代码文件都是go test测试的一部分，不会被go build编译到最终的可执行文件中。</p>
<p>在*_test.go文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>测试函数</td>
<td>函数名前缀为Test</td>
<td>测试程序的一些逻辑行为是否正确</td>
</tr>
<tr>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>基准函数</td>
<td>函数名前缀为Benchmark</td>
<td>测试函数的性能</td>
</tr>
<tr>
<td>示例函数</td>
<td>函数名前缀为Example</td>
<td>为文档提供示例文档</td>
</tr>
</tbody></table>
<p>go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p>
<p>Golang单元测试对文件名和方法名，参数都有很严格的要求。</p>
<p>1、文件名必须以 <strong>xx_test</strong>.go命名</p>
<p>2、方法必须是 <strong>Test</strong> [^a-z]开头</p>
<p>3、方法参数必须 <strong>t</strong> \ <strong>*testing</strong>.T</p>
<p>4、使用 <strong>go**</strong> test**执行单元测试</p>
<p>go test的参数解读：</p>
<p>go test是go语言自带的测试工具，其中包含的是两类，单元测试和性能测试</p>
<p>通过go help test可以看到go test的使用说明：</p>
<p>格式形如：<br> go test [-c] [-i] [build flags] [packages] [flags for test binary]</p>
<p>参数解读：</p>
<p>-c : 编译go test成为可执行的二进制文件，但是不运行测试。</p>
<p>-i : 安装测试包依赖的package，但是不运行测试。</p>
<p>关于build flags，调用go help build，这些是编译运行过程中需要使用到的参数，一般设置为空</p>
<p>关于packages，调用go help packages，这些是关于包的管理，一般设置为空</p>
<p>关于flags for test binary，调用go help testflag，这些是go test过程中经常使用到的参数</p>
<p>-test.v : 是否输出全部的单元测试用例（不管成功或者失败），默认没有加上，所以只输出失败的单元测试用例。</p>
<p>-test.run pattern: 只跑哪些单元测试用例</p>
<p>-test.bench patten: 只跑那些性能测试用例</p>
<p>-test.benchmem : 是否在性能测试的时候输出内存情况</p>
<p>-test.benchtime t : 性能测试运行的时间，默认是1s</p>
<p>-test.cpuprofile cpu.out : 是否输出cpu性能分析文件</p>
<p>-test.memprofile mem.out : 是否输出内存性能分析文件</p>
<p>-test.blockprofile block.out : 是否输出内部goroutine阻塞的性能分析文件</p>
<p>-test.memprofilerate n : 内存性能分析的时候有一个分配了多少的时候才打点记录的问题。这个参数就是设置打点的内存分配间隔，也就是profile中一个sample代表的内存大小。默认是设置为512 * 1024的。如果你将它设置为1，则每分配一个内存块就会在profile中有个打点，那么生成的profile的sample就会非常多。如果你设置为0，那就是不做打点了。</p>
<p>你可以通过设置memprofilerate=1和GOGC=off来关闭内存回收，并且对每个内存块的分配进行观察。</p>
<p>-test.blockprofilerate n: 基本同上，控制的是goroutine阻塞时候打点的纳秒数。默认不设置就相当于-test.blockprofilerate=1，每一纳秒都打点记录一下</p>
<p>-test.parallel n : 性能测试的程序并行cpu数，默认等于GOMAXPROCS。</p>
<p>-test.timeout t : 如果测试用例运行时间超过t，则抛出panic</p>
<p>-test.cpu 1,2,4 : 程序运行在哪些CPU上面，使用二进制的1所在位代表，和nginx的nginx_worker_cpu_affinity是一个道理</p>
<p>-test.short : 将那些运行时间较长的测试用例运行时间缩短</p>
<p>目录结构：</p>
<p>test</p>
<p>|</p>
<p>—— calc.go</p>
<p>|</p>
<p>—— calc_test.go</p>
<h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a><strong>测试函数</strong></h2><h3 id="测试函数的格式"><a href="#测试函数的格式" class="headerlink" title="测试函数的格式"></a><strong>测试函数的格式</strong></h3><p>每个测试函数必须导入testing包，测试函数的基本格式（签名）如下：</p>
<p>func <strong>TestName</strong> (t *testing.T){</p>
<p><em>// …</em></p>
<p>}</p>
<p>测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头，举几个例子：\</p>
<p>func <strong>TestAdd</strong> (t *testing.T){ … }func <strong>TestSum</strong> (t *testing.T){ … }func <strong>TestLog</strong> (t *testing.T){ … }</p>
<p>其中参数t用于报告测试失败和附加的日志信息。 testing.T的拥有的方法如下：</p>
<p>func (c *T) Error(args … <strong>interface</strong> {})</p>
<p>func (c *T) Errorf(format <strong>string</strong> , args … <strong>interface</strong> {})</p>
<p>func (c *T) Fail()</p>
<p>func (c *T) FailNow()</p>
<p>func (c *T) Failed() <strong>bool**</strong> func<strong>(c *T)</strong>Fatal<strong>(args …</strong>interface<strong>{})</strong>func<strong>(c *T)</strong>Fatalf<strong>(format</strong>string <strong>, args …</strong> interface<strong>{})</strong>func<strong>(c *T)</strong>Log<strong>(args …</strong>interface<strong>{})</strong>func<strong>(c *T)</strong>Logf<strong>(format</strong>string <strong>, args …</strong> interface<strong>{})</strong>func<strong>(c *T)</strong>Name<strong>()</strong>string <strong>**func</strong> (t *T) <strong>Parallel</strong> () <strong>func</strong> (t *T) <strong>Run</strong> (name <strong>string</strong> , f func(t *T)) <strong>bool**</strong> func<strong>(c *T)</strong>Skip<strong>(args …</strong>interface<strong>{})</strong>func<strong>(c *T)</strong>SkipNow<strong>()</strong>func<strong>(c *T)</strong>Skipf<strong>(format</strong>string <strong>, args …</strong> interface<strong>{})</strong>func<strong>(c *T)</strong>Skipped<strong>()</strong>bool**</p>
<h3 id="测试函数示例"><a href="#测试函数示例" class="headerlink" title="测试函数示例"></a><strong>测试函数示例</strong></h3><p>就像细胞是构成我们身体的基本单位，一个软件程序也是由很多单元组件构成的。单元组件可以是函数、结构体、方法和最终用户可能依赖的任意东西。总之我们需要确保这些组件是能够正常运行的。单元测试是一些利用各种方法测试单元组件的程序，它会将结果与预期输出进行比较。</p>
<p>接下来，我们定义一个split的包，包中定义了一个Split函数，具体实现如下：</p>
<p><em>// split/split.go</em></p>
<p>package split</p>
<p><strong>import</strong>&quot;strings&quot;</p>
<p><em>// split package with a single split function.</em></p>
<p>_// Split slices s into all substrings separated by sep and// returns a slice of the substrings between those separators._func <strong>Split</strong> (s, sep string) (result []string) {</p>
<p>i := strings.Index(s, sep)</p>
<p><strong>for</strong> i &amp;gt; -1 {</p>
<p>result = append(result, s[:i])</p>
<p>s = s[i+1:]</p>
<p>i = strings.Index(s, sep)</p>
<p>}</p>
<p>result = append(result, s)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>在当前目录下，我们创建一个split_test.go的测试文件，并定义一个测试函数如下：</p>
<p><em>// split/split_test.go</em></p>
<p>package split</p>
<p><strong>import</strong> (</p>
<p>&quot;reflect&quot;</p>
<p>&quot;testing&quot;</p>
<p>)</p>
<p>func <strong>TestSplit</strong> (t *testing.T) { <em>//</em> <em>测试函数名必须以 <strong>Test</strong> 开头，必须接收一个 <strong>*testing.T</strong> 类型参数</em></p>
<p>got := Split(&quot;a:b:c&quot;, &quot;:&quot;) <em>//</em> <em>程序输出的结果</em></p>
<p>want := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;} <em>//</em> <em>期望的结果</em></p>
<p><strong>if</strong>!reflect.DeepEqual(want, got) { <em>//</em> <em>因为 <strong>slice</strong> 不能比较直接，借助反射包中的方法比较</em></p>
<p>t.Errorf(&quot;excepted:%v, got:%v&quot;, want, got) <em>//</em> <em>测试失败输出错误提示</em></p>
<p>}</p>
<p>}</p>
<p>此时split这个包中的文件如下：</p>
<p><strong>split</strong> $ ls -l</p>
<p>total 16</p>
<p>-rw-r–r– 1 pprof staff 40842915:50 <strong>split</strong>.go</p>
<p>-rw-r–r– 1 pprof staff 46642916:04 split_test.go</p>
<p>在split包路径下，执行go test命令，可以看到输出结果如下：</p>
<p><strong>split</strong> $ go test</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 0.005 <strong>s</strong></p>
<p>一个测试用例有点单薄，我们再编写一个测试使用多个字符切割字符串的例子，在split_test.go中添加如下测试函数：</p>
<p>func <strong>TestMoreSplit</strong> (t *testing.T) {</p>
<p>got := Split(&quot;abcd&quot;, &quot;bc&quot;)</p>
<p>want := []string{&quot;a&quot;, &quot;d&quot;}</p>
<p><strong>if</strong>!reflect.DeepEqual(want, got) {</p>
<p>t.Errorf(&quot;excepted:%v, got:%v&quot;, want, got)</p>
<p>}</p>
<p>}</p>
<p>再次运行go test命令，输出结果如下：</p>
<p>split $ go test</p>
<p>— FAIL: TestMultiSplit (0.00s)</p>
<p>split_test.go:20: excepted:[a d], got:[a cd]</p>
<p>FAIL</p>
<p>exit status 1</p>
<p>FAIL github.com/pprof/studygo/code_demo/test_demo/split 0.006s</p>
<p>这一次，我们的测试失败了。我们可以为go test命令添加-v参数，查看测试函数名称和运行时间：</p>
<p>split $ go test -v</p>
<p>=== RUN TestSplit</p>
<p>— PASS: TestSplit (0.00s)</p>
<p>=== RUN TestMoreSplit</p>
<p>— FAIL: TestMoreSplit (0.00s)</p>
<p>split_test.go:21: excepted:[a d], got:[a cd]</p>
<p>FAIL</p>
<p>exit status 1</p>
<p>FAIL github.com/pprof/studygo/code_demo/test_demo/split 0.005s</p>
<p>这一次我们能清楚的看到是TestMoreSplit这个测试没有成功。 还可以在go test命令后添加-run参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被go test命令执行。</p>
<p>split $ go test -v -run=&quot;More&quot;</p>
<p>=== RUN TestMoreSplit</p>
<p>— FAIL: TestMoreSplit (0.00s)</p>
<p>split_test.go:21: excepted:[a d], got:[a cd]</p>
<p>FAIL</p>
<p>exit status 1</p>
<p>FAIL github.com/pprof/studygo/code_demo/test_demo/split 0.006s</p>
<p>现在我们回过头来解决我们程序中的问题。很显然我们最初的split函数并没有考虑到sep为多个字符的情况，我们来修复下这个Bug：</p>
<p>package split</p>
<p><strong>import</strong>&quot;strings&quot;</p>
<p><em>// split package with a single split function.</em></p>
<p>_// Split slices s into all substrings separated by sep and// returns a slice of the substrings between those separators._func <strong>Split</strong> (s, sep string) (result []string) {</p>
<p>i := strings.Index(s, sep)</p>
<p><strong>for</strong> i &amp;gt; -1 {</p>
<p>result = append(result, s[:i])</p>
<p>s = s[i+len(sep):] <em>//</em> <em>这里使用<strong>len(sep)</strong>获取 <strong>sep</strong> 的长度</em></p>
<p>i = strings.Index(s, sep)</p>
<p>}</p>
<p>result = append(result, s)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>这一次我们再来测试一下，我们的程序。注意，当我们修改了我们的代码之后不要仅仅执行那些失败的测试函数，我们应该完整的运行所有的测试，保证不会因为修改代码而引入了新的问题。</p>
<p>split $ go test -v</p>
<p><em>=== RUN TestSplit</em></p>
<p>— PASS: TestSplit (0.00s)</p>
<p><em>=== RUN TestMoreSplit</em></p>
<p>— PASS: TestMoreSplit (0.00s)</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/split 0.006s</p>
<p>这一次我们的测试都通过了</p>
<h2 id="测试组"><a href="#测试组" class="headerlink" title="测试组"></a><strong>测试组</strong></h2><p>我们现在还想要测试一下split函数对中文字符串的支持，这个时候我们可以再编写一个TestChineseSplit测试函数，但是我们也可以使用如下更友好的一种方式来添加更多的测试用例。</p>
<p>func <strong>TestSplit</strong> (t *testing.T) {</p>
<p><em>//</em> <em>定义一个测试用例类型</em></p>
<p>type test <strong>struct</strong> {</p>
<p>input string</p>
<p>sep string</p>
<p>want []string</p>
<p>}</p>
<p><em>//</em> <em>定义一个存储测试用例的切片</em></p>
<p>tests := []test{</p>
<p>{input: &quot;a:b:c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},</p>
<p>{input: &quot;a:b:c&quot;, sep: &quot;,&quot;, want: []string{&quot;a:b:c&quot;}},</p>
<p>{input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},</p>
<p>{input: &quot;枯藤老树昏鸦&quot;, sep: &quot;老&quot;, want: []string{&quot;枯藤&quot;, &quot;树昏鸦&quot;}},</p>
<p>}</p>
<p><em>//</em> <em>遍历切片，逐一执行测试用例</em></p>
<p><strong>for</strong> _, tc := range tests {</p>
<p>got := Split(tc.input, tc.sep)</p>
<p><strong>if</strong>!reflect.DeepEqual(got, tc.want) {</p>
<p>t.Errorf(&quot;excepted:%v, got:%v&quot;, tc.want, got)</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>我们通过上面的代码把多个测试用例合到一起，再次执行go test命令。</p>
<p><strong>split</strong> $ go test -v</p>
<p>=== RUN TestSplit</p>
<p>— FAIL: TestSplit (0.00 <strong>s</strong> )</p>
<p>split_test.go:42: excepted:[枯藤 树昏鸦], got:[枯藤 树昏鸦]</p>
<p>FAIL</p>
<p><strong>exit</strong> status 1</p>
<p>FAIL github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 0.006 <strong>s</strong></p>
<p>我们的测试出现了问题，仔细看打印的测试失败提示信息：excepted:[枯藤 树昏鸦], got:[枯藤 树昏鸦]，你会发现[枯藤 树昏鸦]中有个不明显的空串，这种情况下十分推荐使用%#v的格式化方式。</p>
<p>我们修改下测试用例的格式化输出错误提示部分：</p>
<p>func TestSplit(t *testing.T) {</p>
<p>…</p>
<p><strong>for</strong> _, tc := range tests {</p>
<p>got := Split(tc.input, tc.sep)</p>
<p><strong>if</strong>!reflect.DeepEqual(got, tc.want) {</p>
<p>t.Errorf(&quot;excepted:%#v, got:%#v&quot;, tc.want, got)</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>此时运行go test命令后就能看到比较明显的提示信息了：</p>
<p>split $ go test -v</p>
<p>=== RUN TestSplit</p>
<p>— FAIL: TestSplit (0.00s)</p>
<p>split_test.go:42: excepted:[]string{&quot;枯藤&quot;, &quot;树昏鸦&quot;}, got:[]string{&quot;&quot;, &quot;枯藤&quot;, &quot;树昏鸦&quot;}</p>
<p>FAIL</p>
<p>exit status 1</p>
<p>FAIL github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s</p>
<h2 id="子测试"><a href="#子测试" class="headerlink" title="子测试"></a><strong>子测试</strong></h2><p>看起来都挺不错的，但是如果测试用例比较多的时候，我们是没办法一眼看出来具体是哪个测试用例失败了。我们可能会想到下面的解决办法</p>
<p>func <strong>TestSplit</strong> (t *testing.T) {</p>
<p>type test <strong>struct</strong> { <em>//</em> <em>定义 <strong>test</strong> 结构体</em></p>
<p>input string</p>
<p>sep string</p>
<p>want []string</p>
<p>}</p>
<p>tests := map[string]test{ <em>//</em> <em>测试用例使用 <strong>map</strong> 存储</em></p>
<p>&quot;simple&quot;: {input: &quot;a:b:c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},</p>
<p>&quot;wrong sep&quot;: {input: &quot;a:b:c&quot;, sep: &quot;,&quot;, want: []string{&quot;a:b:c&quot;}},</p>
<p>&quot;more sep&quot;: {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},</p>
<p>&quot;leading sep&quot;: {input: &quot;枯藤老树昏鸦&quot;, sep: &quot;老&quot;, want: []string{&quot;枯藤&quot;, &quot;树昏鸦&quot;}},</p>
<p>}</p>
<p><strong>for</strong> name, tc := range tests {</p>
<p>got := Split(tc.input, tc.sep)</p>
<p><strong>if</strong>!reflect.DeepEqual(got, tc.want) {</p>
<p>t.Errorf(&quot;name:%s excepted:%#v, got:%#v&quot;, name, tc.want, got) <em>//</em> <em>将测试用例的 <strong>name</strong> 格式化输出</em></p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>上面的做法是能够解决问题的。同时Go1.7+中新增了子测试，我们可以按照如下方式使用t.Run执行子测试：</p>
<p>func <strong>TestSplit</strong> (t *testing.T) {</p>
<p>type test <strong>struct</strong> { <em>//</em> <em>定义 <strong>test</strong> 结构体</em></p>
<p>input string</p>
<p>sep string</p>
<p>want []string</p>
<p>}</p>
<p>tests := map[string]test{ <em>//</em> <em>测试用例使用 <strong>map</strong> 存储</em></p>
<p>&quot;simple&quot;: {input: &quot;a:b:c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},</p>
<p>&quot;wrong sep&quot;: {input: &quot;a:b:c&quot;, sep: &quot;,&quot;, want: []string{&quot;a:b:c&quot;}},</p>
<p>&quot;more sep&quot;: {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},</p>
<p>&quot;leading sep&quot;: {input: &quot;枯藤老树昏鸦&quot;, sep: &quot;老&quot;, want: []string{&quot;枯藤&quot;, &quot;树昏鸦&quot;}},</p>
<p>}</p>
<p><strong>for</strong> name, tc := range tests {</p>
<p>t.Run(name, func(t *testing.T) { <em>//</em> <em>使用<strong>t.Run()</strong>执行子测试</em></p>
<p>got := Split(tc.input, tc.sep)</p>
<p><strong>if</strong>!reflect.DeepEqual(got, tc.want) {</p>
<p>t.Errorf(&quot;excepted:%#v, got:%#v&quot;, tc.want, got)</p>
<p>}</p>
<p>})</p>
<p>}</p>
<p>}</p>
<p>此时我们再执行go test命令就能够看到更清晰的输出内容了：</p>
<p>split $ go test -v</p>
<p>=== RUN TestSplit</p>
<p>=== RUN TestSplit/leading_sep</p>
<p>=== RUN TestSplit/simple</p>
<p>=== RUN TestSplit/wrong_sep</p>
<p>=== RUN TestSplit/more_sep</p>
<p>— FAIL: TestSplit (0.00s)</p>
<p>— FAIL: TestSplit/leading_sep (0.00s)</p>
<p>split_test.go:83: excepted:[]string{&quot;枯藤&quot;, &quot;树昏鸦&quot;}, got:[]string{&quot;&quot;, &quot;枯藤&quot;, &quot;树昏鸦&quot;}</p>
<p>— PASS: TestSplit/simple (0.00s)</p>
<p>— PASS: TestSplit/wrong_sep (0.00s)</p>
<p>— PASS: TestSplit/more_sep (0.00s)</p>
<p>FAIL</p>
<p>exit status 1</p>
<p>FAIL github.com/pprof/studygo/code_demo/test_demo/split 0.006s</p>
<p>这个时候我们要把测试用例中的错误修改回来：</p>
<p>func <strong>TestSplit</strong> (t *testing.T) {</p>
<p>…</p>
<p>tests := map[string]test{ <em>//</em> <em>测试用例使用 <strong>map</strong> 存储</em></p>
<p>&quot;simple&quot;: {input: &quot;a:b:c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},</p>
<p>&quot;wrong sep&quot;: {input: &quot;a:b:c&quot;, sep: &quot;,&quot;, want: []string{&quot;a:b:c&quot;}},</p>
<p>&quot;more sep&quot;: {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},</p>
<p>&quot;leading sep&quot;: {input: &quot;枯藤老树昏鸦&quot;, sep: &quot;老&quot;, want: []string{&quot;&quot;, &quot;枯藤&quot;, &quot;树昏鸦&quot;}},</p>
<p>}</p>
<p>…</p>
<p>}</p>
<p>我们都知道可以通过-run=RegExp来指定运行的测试用例，还可以通过/来指定要运行的子测试用例，例如：go test -v -run=Split/simple只会运行simple对应的子测试用例。</p>
<h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a><strong>测试覆盖率</strong></h2><p>测试覆盖率是你的代码被测试套件覆盖的百分比。通常我们使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。</p>
<p>Go提供内置功能来检查你的代码覆盖率。我们可以使用go test -cover来查看测试覆盖率。例如：</p>
<p><strong>split</strong> $ go test -cover</p>
<p>PASS</p>
<p>coverage: 100.0% of statements</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 0.005 <strong>s</strong></p>
<p>从上面的结果可以看到我们的测试用例覆盖了100%的代码。</p>
<p>Go还提供了一个额外的-coverprofile参数，用来将覆盖率相关的记录信息输出到一个文件。例如：</p>
<p><strong>split</strong> $ go test -cover -coverprofile=c.out</p>
<p>PASS</p>
<p>coverage: 100.0% of statements</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 0.005 <strong>s</strong></p>
<p>上面的命令会将覆盖率相关的信息输出到当前文件夹下面的c.out文件中，然后我们执行go tool cover -html=c.out，使用cover工具来处理生成的记录信息，该命令会打开本地的浏览器窗口生成一个HTML报告。</p>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a><strong>基准测试</strong></h2><h3 id="基准测试函数格式"><a href="#基准测试函数格式" class="headerlink" title="基准测试函数格式"></a><strong>基准测试函数格式</strong></h3><p>基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：</p>
<p>func <strong>BenchmarkName</strong> (b *testing.B){</p>
<p><em>// …</em></p>
<p>}</p>
<p>基准测试以Benchmark为前缀，需要一个*testing.B类型的参数b，基准测试必须要执行b.N次，这样的测试才有对照性，b.N的值是系统根据实际情况去调整的，从而保证测试的稳定性。 testing.B拥有的方法如下：</p>
<p>func (c *B) Error(args … <strong>interface</strong> {})</p>
<p>func (c *B) Errorf(format <strong>string</strong> , args … <strong>interface</strong> {})</p>
<p>func (c *B) Fail()</p>
<p>func (c *B) FailNow()</p>
<p>func (c *B) Failed() <strong>bool**</strong> func<strong>(c *B)</strong>Fatal<strong>(args …</strong>interface<strong>{})</strong>func<strong>(c *B)</strong>Fatalf<strong>(format</strong>string <strong>, args …</strong> interface<strong>{})</strong>func<strong>(c *B)</strong>Log<strong>(args …</strong>interface<strong>{})</strong>func<strong>(c *B)</strong>Logf<strong>(format</strong>string <strong>, args …</strong> interface<strong>{})</strong>func<strong>(c *B)</strong>Name<strong>()</strong>string <strong>**func</strong> (b *B) <strong>ReportAllocs</strong> () <strong>func</strong> (b *B) <strong>ResetTimer</strong> () <strong>func</strong> (b *B) <strong>Run</strong> (name <strong>string</strong> , f func(b *B)) <strong>bool**</strong> func<strong>(b *B)</strong>RunParallel<strong>(body func(*PB))</strong>func<strong>(b *B)</strong>SetBytes<strong>(n int64)</strong>func<strong>(b *B)</strong>SetParallelism<strong>(p</strong>int<strong>)</strong>func<strong>(c *B)</strong>Skip<strong>(args …</strong>interface<strong>{})</strong>func<strong>(c *B)</strong>SkipNow<strong>()</strong>func<strong>(c *B)</strong>Skipf<strong>(format</strong>string <strong>, args …</strong> interface<strong>{})</strong>func<strong>(c *B)</strong>Skipped<strong>()</strong>bool <strong>**func</strong> (b *B) <strong>StartTimer</strong> () <strong>func</strong> (b *B) <strong>StopTimer</strong> ()</p>
<h3 id="基准测试示例"><a href="#基准测试示例" class="headerlink" title="基准测试示例"></a><strong>基准测试示例</strong></h3><p>我们为split包中的Split函数编写基准测试如下：</p>
<p>func <strong>BenchmarkSplit</strong> (b *testing.B) {</p>
<p><strong>for</strong> i := 0; i &amp;lt; b.N; i++ {</p>
<p>Split(&quot;枯藤老树昏鸦&quot;, &quot;老&quot;)</p>
<p>}</p>
<p>}</p>
<p>基准测试并不会默认执行，需要增加-bench参数，所以我们通过执行go test -bench=Split命令执行基准测试，输出结果如下：</p>
<p><strong>split</strong> $ go test -bench=Split</p>
<p>goos: darwin</p>
<p>goarch: amd64</p>
<p>pkg: github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong></p>
<p>BenchmarkSplit-810000000203 ns/op</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 2.255 <strong>s</strong></p>
<p>其中BenchmarkSplit-8表示对Split函数进行基准测试，数字8表示GOMAXPROCS的值，这个对于并发基准测试很重要。10000000和203ns/op表示每次调用Split函数耗时203ns，这个结果是10000000次调用的平均值。</p>
<p>我们还可以为基准测试添加-benchmem参数，来获得内存分配的统计数据。</p>
<p><strong>split</strong> $ go test -bench=Split -benchmem</p>
<p>goos: darwin</p>
<p>goarch: amd64</p>
<p>pkg: github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong></p>
<p>BenchmarkSplit-810000000215 ns/op 112 B/op 3 allocs/op</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 2.394 <strong>s</strong></p>
<p>其中，112 B/op表示每次操作内存分配了112字节，3 allocs/op则表示每次操作进行了3次内存分配。 我们将我们的Split函数优化如下：</p>
<p>func <strong>Split</strong> (s, sep string) (result []string) {</p>
<p>result = make([]string, 0, strings.Count(s, sep)+1)</p>
<p>i := strings.Index(s, sep)</p>
<p><strong>for</strong> i &amp;gt; -1 {</p>
<p>result = append(result, s[:i])</p>
<p>s = s[i+len(sep):] <em>//</em> <em>这里使用<strong>len(sep)</strong>获取 <strong>sep</strong> 的长度</em></p>
<p>i = strings.Index(s, sep)</p>
<p>}</p>
<p>result = append(result, s)</p>
<p><strong>return</strong></p>
<p>}</p>
<p>这一次我们提前使用make函数将result初始化为一个容量足够大的切片，而不再像之前一样通过调用append函数来追加。我们来看一下这个改进会带来多大的性能提升：</p>
<p><strong>split</strong> $ go test -bench=Split -benchmem</p>
<p>goos: darwin</p>
<p>goarch: amd64</p>
<p>pkg: github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong></p>
<p>BenchmarkSplit-810000000127 ns/op 48 B/op 1 allocs/op</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 1.423 <strong>s</strong></p>
<p>这个使用make函数提前分配内存的改动，减少了2/3的内存分配次数，并且减少了一半的内存分配。</p>
<h3 id="性能比较函数"><a href="#性能比较函数" class="headerlink" title="性能比较函数"></a><strong>性能比较函数</strong></h3><p>上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？我们通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。</p>
<p>性能比较函数通常是一个带有参数的函数，被多个不同的Benchmark函数传入不同的值来调用。举个例子如下：</p>
<p>func <strong>benchmark</strong> (b *testing.B, size <strong>int</strong> ){<em>/* … */</em>}func <strong>Benchmark10</strong> (b *testing.B){ benchmark(b, 10) }func <strong>Benchmark100</strong> (b *testing.B){ benchmark(b, 100) }func <strong>Benchmark1000</strong> (b *testing.B){ benchmark(b, 1000) }</p>
<p>例如我们编写了一个计算斐波那契数列的函数如下：</p>
<p><em>// fib.go</em></p>
<p><em>// Fib</em> <em>是一个计算第 <em>_n</em></em> 个斐波那契数的函数_func <strong>Fib</strong> (n <strong>int</strong> ) <strong>int</strong> {</p>
<p><strong>if</strong> n &amp;lt; 2 {</p>
<p><strong>return</strong> n</p>
<p>}</p>
<p><strong>return</strong> Fib(n-1) + Fib(n-2)</p>
<p>}</p>
<p>我们编写的性能比较函数如下：</p>
<p><em>// fib_test.go</em></p>
<p>func <strong>benchmarkFib</strong> (b *testing.B, n <strong>int</strong> ) {</p>
<p><strong>for</strong> i := 0; i &amp;lt; b.N; i++ {</p>
<p>Fib(n)</p>
<p>}</p>
<p>}</p>
<p>func <strong>BenchmarkFib1</strong> (b *testing.B) { benchmarkFib(b, 1) }func <strong>BenchmarkFib2</strong> (b *testing.B) { benchmarkFib(b, 2) }func <strong>BenchmarkFib3</strong> (b *testing.B) { benchmarkFib(b, 3) }func <strong>BenchmarkFib10</strong> (b *testing.B) { benchmarkFib(b, 10) }func <strong>BenchmarkFib20</strong> (b *testing.B) { benchmarkFib(b, 20) }func <strong>BenchmarkFib40</strong> (b *testing.B) { benchmarkFib(b, 40) }</p>
<p>运行基准测试：</p>
<p>split $ go test -bench=.</p>
<p>goos: darwin</p>
<p>goarch: amd64</p>
<p>pkg: github.com/pprof/studygo/code_demo/test_demo/fib</p>
<p>BenchmarkFib1-8 1000000000 2.03 ns/op</p>
<p>BenchmarkFib2-8 300000000 5.39 ns/op</p>
<p>BenchmarkFib3-8 200000000 9.71 ns/op</p>
<p>BenchmarkFib10-8 5000000 325 ns/op</p>
<p>BenchmarkFib20-8 30000 42460 ns/op</p>
<p>BenchmarkFib40-8 2 638524980 ns/op</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/fib 12.944s</p>
<p>这里需要注意的是，默认情况下，每个基准测试至少运行1秒。如果在Benchmark函数返回时没有到1秒，则b.N的值会按1,2,5,10,20,50，…增加，并且函数再次运行。</p>
<p>最终的BenchmarkFib40只运行了两次，每次运行的平均值只有不到一秒。像这种情况下我们应该可以使用-benchtime标志增加最小基准时间，以产生更准确的结果。例如：</p>
<p>split $ go test -bench=Fib40 -benchtime=20s</p>
<p>goos: darwin</p>
<p>goarch: amd64</p>
<p>pkg: github.com/pprof/studygo/code_demo/test_demo/fib</p>
<p>BenchmarkFib40-8 50 663205114 ns/op</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/fib 33.849s</p>
<p>这一次BenchmarkFib40函数运行了50次，结果就会更准确一些了。</p>
<p>使用性能比较函数做测试的时候一个容易犯的错误就是把b.N作为输入的大小，例如以下两个例子都是错误的示范：</p>
<p><em>//</em> _错误示范__1_func <strong>BenchmarkFibWrong</strong> (b *testing.B) {</p>
<p><strong>for</strong> n := 0; n &amp;lt; b.N; n++ {</p>
<p>Fib(n)</p>
<p>}</p>
<p>}</p>
<p><em>//</em> _错误示范__2_func <strong>BenchmarkFibWrong2</strong> (b *testing.B) {</p>
<p>Fib(b.N)</p>
<p>}</p>
<h3 id="重置时间"><a href="#重置时间" class="headerlink" title="重置时间"></a><strong>重置时间</strong></h3><p>b.ResetTimer之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。例如：</p>
<p>func <strong>BenchmarkSplit</strong> (b *testing.B) {</p>
<p>time.Sleep(5 * time.Second) <em>//</em> <em>假设需要做一些耗时的无关操作</em></p>
<p>b.ResetTimer() <em>//</em> <em>重置计时器</em></p>
<p><strong>for</strong> i := 0; i &amp;lt; b.N; i++ {</p>
<p>Split(&quot;枯藤老树昏鸦&quot;, &quot;老&quot;)</p>
<p>}</p>
<p>}</p>
<h3 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a><strong>并行测试</strong></h3><p>func (b _B) RunParallel(body func(_PB))会以并行的方式执行给定的基准测试。</p>
<p>RunParallel会创建出多个goroutine，并将b.N分配给这些goroutine执行， 其中goroutine数量的默认值为GOMAXPROCS。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在RunParallel之前调用SetParallelism 。RunParallel通常会与-cpu标志一同使用。</p>
<p>func <strong>BenchmarkSplitParallel</strong> (b *testing.B) {</p>
<p><em>// b.SetParallelism(1) //</em> <em>设置使用的 <strong>CPU</strong> 数</em></p>
<p>b.RunParallel(func(pb *testing.PB) {</p>
<p><strong>for</strong> pb.Next() {</p>
<p>Split(&quot;枯藤老树昏鸦&quot;, &quot;老&quot;)</p>
<p>}</p>
<p>})</p>
<p>}</p>
<p>执行一下基准测试：</p>
<p><strong>split</strong> $ go test -bench=.</p>
<p>goos: darwin</p>
<p>goarch: amd64</p>
<p>pkg: github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong></p>
<p>BenchmarkSplit-810000000131 ns/op</p>
<p>BenchmarkSplitParallel-85000000036.1 ns/op</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/ <strong>split</strong> 3.308 <strong>s</strong></p>
<p>还可以通过在测试命令后添加-cpu参数如go test -bench=. -cpu 1来指定使用的CPU数量。</p>
<h2 id="Setup-与-TearDown"><a href="#Setup-与-TearDown" class="headerlink" title="Setup** 与 **TearDown"></a><strong>Setup**</strong> 与 <strong>**TearDown</strong></h2><p>测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）。</p>
<h3 id="TestMain"><a href="#TestMain" class="headerlink" title="TestMain"></a><strong>TestMain</strong></h3><p>通过在*_test.go文件中定义TestMain函数来可以在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）操作。</p>
<p>如果测试文件包含函数:func TestMain(m *testing.M)那么生成的测试会先调用 TestMain(m)，然后再运行具体测试。TestMain运行在主goroutine中, 可以在调用 m.Run前后做任何设置（setup）和拆卸（teardown）。退出测试的时候应该使用m.Run的返回值作为参数调用os.Exit。</p>
<p>一个使用TestMain来设置Setup和TearDown的示例如下：</p>
<p>func <strong>TestMain</strong> (m *testing.M) {</p>
<p>fmt.Println(&quot;write setup code here…&quot;) <em>//</em> <em>测试之前的做一些设置</em></p>
<p><em>//</em> <em>如果</em> <em>TestMain</em> <em>使用了</em> <em>flags <strong>，这里应该加上</strong> flag.Parse()</em></p>
<p>retCode := m.Run() <em>//</em> <em>执行测试</em></p>
<p>fmt.Println(&quot;write teardown code here…&quot;) <em>//</em> <em>测试之后做一些拆卸工作</em></p>
<p>os.Exit(retCode) <em>//</em> <em>退出测试</em></p>
<p>}</p>
<p>需要注意的是：在调用TestMain时, flag.Parse并没有被调用。所以如果TestMain 依赖于command-line标志 (包括 testing 包的标记), 则应该显示的调用flag.Parse。</p>
<h3 id="子测试的-Setup-与-Teardown"><a href="#子测试的-Setup-与-Teardown" class="headerlink" title="子测试的** Setup 与 Teardown**"></a><strong>子测试的**</strong> Setup <strong><strong>与</strong></strong> Teardown**</h3><p>有时候我们可能需要为每个测试集设置Setup与Teardown，也有可能需要为每个子测试设置Setup与Teardown。下面我们定义两个函数工具函数如下：</p>
<p><em>//</em> <em>测试集的 <em>_Setup</em></em> 与__Teardown_func <strong>setupTestCase</strong> (t *testing.T) <strong>func</strong> (t *testing.T) {</p>
<p>t.Log(&quot;如有需要在此执行:测试之前的setup&quot;)</p>
<p><strong>return</strong> func(t *testing.T) {</p>
<p>t.Log(&quot;如有需要在此执行:测试之后的teardown&quot;)</p>
<p>}</p>
<p>}</p>
<p><em>//</em> <em>子测试的 <em>_Setup</em></em> 与__Teardown_func <strong>setupSubTest</strong> (t *testing.T) <strong>func</strong> (t *testing.T) {</p>
<p>t.Log(&quot;如有需要在此执行:子测试之前的setup&quot;)</p>
<p><strong>return</strong> func(t *testing.T) {</p>
<p>t.Log(&quot;如有需要在此执行:子测试之后的teardown&quot;)</p>
<p>}</p>
<p>}</p>
<p>使用方式如下：</p>
<p>func <strong>TestSplit</strong> (t *testing.T) {</p>
<p>type test <strong>struct</strong> { <em>//</em> <em>定义 <strong>test</strong> 结构体</em></p>
<p>input <strong>string</strong></p>
<p>sep <strong>string</strong></p>
<p>want [] <strong>string</strong></p>
<p>}</p>
<p>tests := map[<strong>string</strong>]test{ <em>//</em> <em>测试用例使用 <strong>map</strong> 存储</em></p>
<p>&quot;simple&quot;: {input: &quot;a:b:c&quot;, sep: &quot;:&quot;, want: [] <strong>string</strong> {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},</p>
<p>&quot;wrong sep&quot;: {input: &quot;a:b:c&quot;, sep: &quot;,&quot;, want: [] <strong>string</strong> {&quot;a:b:c&quot;}},</p>
<p>&quot;more sep&quot;: {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: [] <strong>string</strong> {&quot;a&quot;, &quot;d&quot;}},</p>
<p>&quot;leading sep&quot;: {input: &quot;枯藤老树昏鸦&quot;, sep: &quot;老&quot;, want: [] <strong>string</strong> {&quot;&quot;, &quot;枯藤&quot;, &quot;树昏鸦&quot;}},</p>
<p>}</p>
<p>teardownTestCase := setupTestCase(t) <em>//</em> <em>测试之前执行 <strong>setup</strong> 操作</em></p>
<p>defer <strong>teardownTestCase</strong> (t) <em>//</em> <em>测试之后执行 <strong>testdoen</strong> 操作</em></p>
<p><strong>for</strong> name, tc := range tests {</p>
<p>t.Run(name, func(t *testing.T) { <em>//</em> <em>使用<strong>t.Run()</strong>执行子测试</em></p>
<p>teardownSubTest := setupSubTest(t) <em>//</em> <em>子测试之前执行 <strong>setup</strong> 操作</em></p>
<p>defer <strong>teardownSubTest</strong> (t) <em>//</em> <em>测试之后执行 <strong>testdoen</strong> 操作</em></p>
<p>got := Split(tc.input, tc.sep)</p>
<p><strong>if</strong>!reflect.DeepEqual(got, tc.want) {</p>
<p>t.Errorf(&quot;excepted:%#v, got:%#v&quot;, tc.want, got)</p>
<p>}</p>
<p>})</p>
<p>}</p>
<p>}</p>
<p>测试结果如下：</p>
<p>split $ go test -v</p>
<p><em>=== RUN TestSplit</em></p>
<p><em>=== RUN TestSplit/simple</em></p>
<p><em>=== RUN TestSplit/wrong_sep</em></p>
<p><em>=== RUN TestSplit/more_sep</em></p>
<p><em>=== RUN TestSplit/leading_sep</em></p>
<p>— PASS: TestSplit (0.00s)</p>
<p>split_test.go:71: 如有需要在此执行:测试之前的setup</p>
<p>— PASS: TestSplit/simple (0.00s)</p>
<p>split_test.go:79: 如有需要在此执行:子测试之前的setup</p>
<p>split_test.go:81: 如有需要在此执行:子测试之后的teardown</p>
<p>— PASS: TestSplit/wrong_sep (0.00s)</p>
<p>split_test.go:79: 如有需要在此执行:子测试之前的setup</p>
<p>split_test.go:81: 如有需要在此执行:子测试之后的teardown</p>
<p>— PASS: TestSplit/more_sep (0.00s)</p>
<p>split_test.go:79: 如有需要在此执行:子测试之前的setup</p>
<p>split_test.go:81: 如有需要在此执行:子测试之后的teardown</p>
<p>— PASS: TestSplit/leading_sep (0.00s)</p>
<p>split_test.go:79: 如有需要在此执行:子测试之前的setup</p>
<p>split_test.go:81: 如有需要在此执行:子测试之后的teardown</p>
<p>split_test.go:73: 如有需要在此执行:测试之后的teardown</p>
<p><em>=== RUN ExampleSplit</em></p>
<p>— PASS: ExampleSplit (0.00s)</p>
<p>PASS</p>
<p>ok github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s</p>
<h2 id="示例函数"><a href="#示例函数" class="headerlink" title="示例函数"></a><strong>示例函数</strong></h2><p>###示例函数的格式</p>
<p>被go test特殊对待的第三种函数就是示例函数，它们的函数名以Example为前缀。它们既没有参数也没有返回值。标准格式如下：</p>
<p>func <strong>ExampleName</strong> () {</p>
<p><em>// …</em></p>
<p>}</p>
<h3 id="示例函数示例"><a href="#示例函数示例" class="headerlink" title="示例函数示例"></a><strong>示例函数示例</strong></h3><p>下面的代码是我们为Split函数编写的一个示例函数：</p>
<p>func <strong>ExampleSplit</strong> () {</p>
<p>fmt.Println(split.Split(&quot;a:b:c&quot;, &quot;:&quot;))</p>
<p>fmt.Println(split.Split(&quot;枯藤老树昏鸦&quot;, &quot;老&quot;))</p>
<p><em>// Output:</em></p>
<p><em>// [a b c]</em></p>
<p><em>// [</em> <em>枯藤 树昏鸦__]</em></p>
<p>}</p>
<p>为你的代码编写示例代码有如下三个用处：</p>
<p>示例函数能够作为文档直接使用，例如基于web的godoc中能把示例函数与对应的函数或包相关联。</p>
<p>示例函数只要包含了// Output:也是可以通过go test运行的可执行测试。</p>
<p>split $ go test -run Example</p>
<p>PASS</p>
<p>ok github.com/pprof/studygo/code_demo/test_demo/split 0.006s</p>
<p>示例函数提供了可以直接运行的示例代码，可以直接在golang.org的godoc文档服务器上使用Go Playground运行示例代码。下图为strings.ToUpper函数在Playground的示例函数效果。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:yjw-1017@outlook.com">vio-jw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://1py1vm.coding-pages.com/2021/02/19/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">http://1py1vm.coding-pages.com/2021/02/19/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://1py1vm.coding-pages.com" target="_blank">Jw's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a></div><div class="post_share"><div class="social-share" data-image="https://wallroom.io/img/1920x1080/bg-12d9d47.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/02/19/%E9%97%AD%E5%8C%85%E3%80%81%E9%80%92%E5%BD%92/"><img class="prev_cover lazyload" data-src="https://wallroom.io/img/1920x1080/bg-2c050a7.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">闭包、递归</div></div></a></div><div class="next-post pull_right"><a href="/2021/02/19/%E5%AE%9A%E6%97%B6%E5%99%A8/"><img class="next_cover lazyload" data-src="https://wallroom.io/img/1920x1080/bg-0ecf3b1.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">定时器</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/01/07/golang内置类型和函数/" title="golang内置类型和函数"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-119e935.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-07</div><div class="relatedPosts_title">golang内置类型和函数</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/08/Init函数和main函数/" title="Init函数和main函数"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-0d4abee.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-08</div><div class="relatedPosts_title">Init函数和main函数</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/08/命令/" title="命令"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-0cf6fd0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-08</div><div class="relatedPosts_title">命令</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/09/”基本类型“/" title="基本类型"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-0ecf3b1.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-09</div><div class="relatedPosts_title">基本类型</div></div></a></div><div class="relatedPosts_item"><a href="/2021/02/19/GMP原理和调度/" title="GMP原理和调度"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-12d9d47.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-02-19</div><div class="relatedPosts_title">GMP原理和调度</div></div></a></div><div class="relatedPosts_item"><a href="/2021/02/19/Channel/" title="Channel"><img class="relatedPosts_cover lazyload"data-src="https://wallroom.io/img/1920x1080/bg-05e3c1f.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-02-19</div><div class="relatedPosts_title">Channel</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'iEgNuNBCTaihslibuDwal7C5-gzGzoHsz',
  appKey: 'm6S8TQcmY7gNtxgbvUV8dBhp',
  placeholder: '分享你的想法吧~',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" style="background-image: url(https://wallroom.io/img/1920x1080/bg-2b801d4.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By vio-jw</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a><img class="icp-icon" src="/img/icp.png"/><span>闽ICP备20007536</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script></body></html>